{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TorrentFile Documentation Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. hasher.md # Piece Hasher Objects. torrent.md # Bittorrent meta file objects. CLI.md # Command Line Interface API. Examples.md # Overview page. LICENSE.md # License file. Progress.md # Progress Module tests.md # Testing Suit API. utils.md # Utility Functions. Bittorrent File Creator (.torrent) Torrentfile is a CLI for creating .torrent files for bittorrent clients. The repo url is found on github at TorrentFile URL Features Simple interface Create files for Bittorrent v1 Create files for Bittorrent v2 Create files with multiple trackers Optionally specify size of individual packets of data for transfer Flag torrent file as private for private trackers. Check torrentfile against file or directory for match. A GUI for this project can be found at https://github.com/Torrentfile-GUI Documentation Documentation can be found by opening your webrowser in the docs directory or by visiting https://alexpdev.github.io/torrentfile . Installation via PyPi > pip install torrentfile via Git > git clone https://github.com/alexpdev/torrentfile.git download Or download the latest release from the Release page on github. https://github.com/alexpdev/torrentfile/releases Usage ```bash: usage: torrentfile -h -d [-s ] [-c ] [-a ] [--announce-list [ ...]] [-o ] [--meta-version ] [-l ] [-r <.torrent>] Create or Re-Check Bittorrent meta files for Bittorrent v1, v2 or v1, v2 combo Hybrids. positional arguments: path to .torrent file content optional arguments: -h, --help show this help message and exit -v, --version show program version and exit -d, --debug output debug information -p, --private create .torrent file for private tracker -s , --source specify source -c , --comment include a comment in file metadata -a , --announce announce url for Bittorrent tracker --announce-list [ ...] additional tracker announce URLs -o , --out output path for created .torrent file --meta-version .torrent file version. Options = 1, 2 or 3. (1) = Bittorrent v1;. (Default) (2) = Bittorrent v2. (3) = Bittorrent v1 & v2 hybrid. -l , --piece-length piece size used by Bittorrent transfer protocol. Acceptable values include numbers 14-35, will be treated as the exponent for 2^n power, or any power of 2 integer in 16KB-16MB. e.g. --piece-length 14 is the same as --piece-length 16384 If this option flag is not used, the program will calculate an appropriate value automatically. -r <.torrent>, --re-check <.torrent> <.torrent> is the path to a .torrent meta file. Check data integrity with <.torrent> file. When this option is active, all other options are ignored (except -d). ``` License Distributed under the GNU LGPL v3 license. See LICENSE for more information. https://github.com/alexpdev","title":"Home"},{"location":"#welcome-to-torrentfile-documentation","text":"","title":"Welcome to TorrentFile Documentation"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. hasher.md # Piece Hasher Objects. torrent.md # Bittorrent meta file objects. CLI.md # Command Line Interface API. Examples.md # Overview page. LICENSE.md # License file. Progress.md # Progress Module tests.md # Testing Suit API. utils.md # Utility Functions.","title":"Project layout"},{"location":"#bittorrent-file-creator-torrent","text":"Torrentfile is a CLI for creating .torrent files for bittorrent clients. The repo url is found on github at TorrentFile URL","title":"Bittorrent File Creator (.torrent)"},{"location":"#features","text":"Simple interface Create files for Bittorrent v1 Create files for Bittorrent v2 Create files with multiple trackers Optionally specify size of individual packets of data for transfer Flag torrent file as private for private trackers. Check torrentfile against file or directory for match. A GUI for this project can be found at https://github.com/Torrentfile-GUI","title":"Features"},{"location":"#documentation","text":"Documentation can be found by opening your webrowser in the docs directory or by visiting https://alexpdev.github.io/torrentfile .","title":"Documentation"},{"location":"#installation","text":"","title":"Installation"},{"location":"#via-pypi","text":"> pip install torrentfile","title":"via PyPi"},{"location":"#via-git","text":"> git clone https://github.com/alexpdev/torrentfile.git","title":"via Git"},{"location":"#download","text":"Or download the latest release from the Release page on github. https://github.com/alexpdev/torrentfile/releases","title":"download"},{"location":"#usage","text":"```bash: usage: torrentfile -h -d [-s ] [-c ] [-a ] [--announce-list [ ...]] [-o ] [--meta-version ] [-l ] [-r <.torrent>] Create or Re-Check Bittorrent meta files for Bittorrent v1, v2 or v1, v2 combo Hybrids. positional arguments: path to .torrent file content optional arguments: -h, --help show this help message and exit -v, --version show program version and exit -d, --debug output debug information -p, --private create .torrent file for private tracker -s , --source specify source -c , --comment include a comment in file metadata -a , --announce announce url for Bittorrent tracker --announce-list [ ...] additional tracker announce URLs -o , --out output path for created .torrent file --meta-version .torrent file version. Options = 1, 2 or 3. (1) = Bittorrent v1;. (Default) (2) = Bittorrent v2. (3) = Bittorrent v1 & v2 hybrid. -l , --piece-length piece size used by Bittorrent transfer protocol. Acceptable values include numbers 14-35, will be treated as the exponent for 2^n power, or any power of 2 integer in 16KB-16MB. e.g. --piece-length 14 is the same as --piece-length 16384 If this option flag is not used, the program will calculate an appropriate value automatically. -r <.torrent>, --re-check <.torrent> <.torrent> is the path to a .torrent meta file. Check data integrity with <.torrent> file. When this option is active, all other options are ignored (except -d). ```","title":"Usage"},{"location":"#license","text":"Distributed under the GNU LGPL v3 license. See LICENSE for more information. https://github.com/alexpdev","title":"License"},{"location":"CLI/","text":"Command Line Interface Main script entrypoint for creating .torrent files. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. !!! functions main_script: process command line arguments and run program. HelpFormat ( HelpFormatter ) Formatting class for help tips provided by the CLI. Parameters: Name Type Description Default prog `str` Name of the program. required width `int` Max width of help message output. required max_help_positions `int` max length until line wrap. required __init__ ( self , prog , width = 80 , max_help_pos = 45 ) special Construct HelpFormat class. Source code in torrentfile\\cli.py def __init__ ( self , prog , width = 80 , max_help_pos = 45 ): \"\"\"Construct HelpFormat class.\"\"\" super () . __init__ ( prog , width = width , max_help_position = max_help_pos ) main () Initiate main function for CLI script. Source code in torrentfile\\cli.py def main (): \"\"\"Initiate main function for CLI script.\"\"\" main_script () main_script ( args = None ) Initialize Command Line Interface for torrentfile. Parameters: Name Type Description Default args `list`, default=None Commandline arguments. None Source code in torrentfile\\cli.py def main_script ( args = None ): \"\"\"Initialize Command Line Interface for torrentfile. Args: args (`list`, default=None): Commandline arguments. \"\"\" if not args : args = sys . argv [ 1 :] desc = ( \"Create or Re-Check Bittorrent meta files for \" \"Bittorrent v1, v2 or v1, v2 combo Hybrids.\" ) parser = ArgumentParser ( \"torrentfile\" , description = desc , prefix_chars = \"-\" , formatter_class = HelpFormat ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = f \"torrentfile v { torrentfile . __version__ } \" , help = \"show program version and exit\" ) parser . add_argument ( \"-d\" , \"--debug\" , action = \"store_true\" , dest = \"debug\" , help = \"output debug information\" ) parser . add_argument ( \"-p\" , \"--private\" , action = \"store_true\" , dest = \"private\" , help = \"create .torrent file for private tracker\" , ) parser . add_argument ( \"-s\" , \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"specify source\" ) parser . add_argument ( \"-c\" , \"--comment\" , action = \"store\" , dest = \"comment\" , metavar = \"<comment>\" , help = \"include a comment in file metadata\" , ) parser . add_argument ( \"-a\" , \"--announce\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , nargs = \"+\" , default = \"\" , help = \"1 or more announce url's for Bittorrent tracker\" ) parser . add_argument ( \"-o\" , \"--out\" , action = \"store\" , dest = \"outfile\" , metavar = \"<path>\" , help = \"output path for created .torrent file\" , ) parser . add_argument ( \"--meta-version\" , default = \"1\" , choices = [ \"1\" , \"2\" , \"3\" ], action = \"store\" , dest = \"meta_version\" , metavar = \"<int>\" , help = \"\"\" .torrent file version. Options = 1, 2 or 3. (1) = Bittorrent v1;. (Default) (2) = Bittorrent v2. (3) = Bittorrent v1 & v2 hybrid. \"\"\" , ) parser . add_argument ( \"-l\" , \"--piece-length\" , action = \"store\" , dest = \"piece_length\" , metavar = \"<int>\" , help = \"\"\" piece size used by Bittorrent transfer protocol. Acceptable values include numbers 14-35, will be treated as the exponent for 2^n power, or any power of 2 integer in 16KB-16MB. e.g. `--piece-length 14` is the same as `--piece-length 16384` If this option flag is not used, the program will calculate an appropriate value automatically. \"\"\" , ) parser . add_argument ( \"-r\" , \"--check\" , \"--re-check\" , dest = \"checker\" , metavar = \"<.torrent>\" , help = \"\"\" <.torrent> is the path to a .torrent meta file. Check <content> data integrity with <.torrent> file. When this option is active, all other options are ignored (except -d). \"\"\" ) parser . add_argument ( \"content\" , action = \"store\" , metavar = \"<content>\" , help = \"path to .torrent file content\" ) if not args : args = [ \"-h\" ] flags = parser . parse_args ( args ) if flags . debug : level = logging . DEBUG else : level = logging . WARNING logging . basicConfig ( level = level , format = ' %(asctime)s %(message)s ' , datefmt = '%m/ %d /%Y %H:%M:%S' ) if flags . checker : metafile = flags . checker content = flags . content checker = CheckerClass ( metafile , content ) result = checker . result sys . stdout . write ( str ( result )) sys . stdout . flush () return result kwargs = { \"path\" : flags . content , \"announce\" : flags . announce , \"piece_length\" : flags . piece_length , \"source\" : flags . source , \"private\" : flags . private , \"outfile\" : flags . outfile , \"comment\" : flags . comment , } if flags . meta_version == \"2\" : torrent = TorrentFileV2 ( ** kwargs ) elif flags . meta_version == \"3\" : torrent = TorrentFileHybrid ( ** kwargs ) else : torrent = TorrentFile ( ** kwargs ) outfile , meta = torrent . write () parser . kwargs = kwargs parser . meta = meta parser . outfile = outfile return parser","title":"CLI"},{"location":"CLI/#command-line-interface","text":"Main script entrypoint for creating .torrent files. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. !!! functions main_script: process command line arguments and run program.","title":"Command Line Interface"},{"location":"CLI/#torrentfile.cli.HelpFormat","text":"Formatting class for help tips provided by the CLI. Parameters: Name Type Description Default prog `str` Name of the program. required width `int` Max width of help message output. required max_help_positions `int` max length until line wrap. required","title":"HelpFormat"},{"location":"CLI/#torrentfile.cli.HelpFormat.__init__","text":"Construct HelpFormat class. Source code in torrentfile\\cli.py def __init__ ( self , prog , width = 80 , max_help_pos = 45 ): \"\"\"Construct HelpFormat class.\"\"\" super () . __init__ ( prog , width = width , max_help_position = max_help_pos )","title":"__init__()"},{"location":"CLI/#torrentfile.cli.main","text":"Initiate main function for CLI script. Source code in torrentfile\\cli.py def main (): \"\"\"Initiate main function for CLI script.\"\"\" main_script ()","title":"main()"},{"location":"CLI/#torrentfile.cli.main_script","text":"Initialize Command Line Interface for torrentfile. Parameters: Name Type Description Default args `list`, default=None Commandline arguments. None Source code in torrentfile\\cli.py def main_script ( args = None ): \"\"\"Initialize Command Line Interface for torrentfile. Args: args (`list`, default=None): Commandline arguments. \"\"\" if not args : args = sys . argv [ 1 :] desc = ( \"Create or Re-Check Bittorrent meta files for \" \"Bittorrent v1, v2 or v1, v2 combo Hybrids.\" ) parser = ArgumentParser ( \"torrentfile\" , description = desc , prefix_chars = \"-\" , formatter_class = HelpFormat ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = f \"torrentfile v { torrentfile . __version__ } \" , help = \"show program version and exit\" ) parser . add_argument ( \"-d\" , \"--debug\" , action = \"store_true\" , dest = \"debug\" , help = \"output debug information\" ) parser . add_argument ( \"-p\" , \"--private\" , action = \"store_true\" , dest = \"private\" , help = \"create .torrent file for private tracker\" , ) parser . add_argument ( \"-s\" , \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"specify source\" ) parser . add_argument ( \"-c\" , \"--comment\" , action = \"store\" , dest = \"comment\" , metavar = \"<comment>\" , help = \"include a comment in file metadata\" , ) parser . add_argument ( \"-a\" , \"--announce\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , nargs = \"+\" , default = \"\" , help = \"1 or more announce url's for Bittorrent tracker\" ) parser . add_argument ( \"-o\" , \"--out\" , action = \"store\" , dest = \"outfile\" , metavar = \"<path>\" , help = \"output path for created .torrent file\" , ) parser . add_argument ( \"--meta-version\" , default = \"1\" , choices = [ \"1\" , \"2\" , \"3\" ], action = \"store\" , dest = \"meta_version\" , metavar = \"<int>\" , help = \"\"\" .torrent file version. Options = 1, 2 or 3. (1) = Bittorrent v1;. (Default) (2) = Bittorrent v2. (3) = Bittorrent v1 & v2 hybrid. \"\"\" , ) parser . add_argument ( \"-l\" , \"--piece-length\" , action = \"store\" , dest = \"piece_length\" , metavar = \"<int>\" , help = \"\"\" piece size used by Bittorrent transfer protocol. Acceptable values include numbers 14-35, will be treated as the exponent for 2^n power, or any power of 2 integer in 16KB-16MB. e.g. `--piece-length 14` is the same as `--piece-length 16384` If this option flag is not used, the program will calculate an appropriate value automatically. \"\"\" , ) parser . add_argument ( \"-r\" , \"--check\" , \"--re-check\" , dest = \"checker\" , metavar = \"<.torrent>\" , help = \"\"\" <.torrent> is the path to a .torrent meta file. Check <content> data integrity with <.torrent> file. When this option is active, all other options are ignored (except -d). \"\"\" ) parser . add_argument ( \"content\" , action = \"store\" , metavar = \"<content>\" , help = \"path to .torrent file content\" ) if not args : args = [ \"-h\" ] flags = parser . parse_args ( args ) if flags . debug : level = logging . DEBUG else : level = logging . WARNING logging . basicConfig ( level = level , format = ' %(asctime)s %(message)s ' , datefmt = '%m/ %d /%Y %H:%M:%S' ) if flags . checker : metafile = flags . checker content = flags . content checker = CheckerClass ( metafile , content ) result = checker . result sys . stdout . write ( str ( result )) sys . stdout . flush () return result kwargs = { \"path\" : flags . content , \"announce\" : flags . announce , \"piece_length\" : flags . piece_length , \"source\" : flags . source , \"private\" : flags . private , \"outfile\" : flags . outfile , \"comment\" : flags . comment , } if flags . meta_version == \"2\" : torrent = TorrentFileV2 ( ** kwargs ) elif flags . meta_version == \"3\" : torrent = TorrentFileHybrid ( ** kwargs ) else : torrent = TorrentFile ( ** kwargs ) outfile , meta = torrent . write () parser . kwargs = kwargs parser . meta = meta parser . outfile = outfile return parser","title":"main_script()"},{"location":"LICENSE/","text":"GNU Lesser General Public License Version 3, 29 June 2007 Copyright \u00a9 2007 Free Software Foundation, Inc. < http://fsf.org/ > Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below. 0. Additional Definitions As used herein, \u201cthis License\u201d refers to version 3 of the GNU Lesser General Public License, and the \u201cGNU GPL\u201d refers to version 3 of the GNU General Public License. \u201cThe Library\u201d refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \u201cApplication\u201d is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \u201cCombined Work\u201d is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \u201cLinked Version\u201d. The \u201cMinimal Corresponding Source\u201d for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \u201cCorresponding Application Code\u201d for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work. 1. Exception to Section 3 of the GNU GPL You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL. 2. Conveying Modified Versions If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy. 3. Object Code Incorporating Material from Library Header Files The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document. 4. Combined Works You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0) Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1) Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 4d0 , the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 4d1 , you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.) 5. Combined Libraries You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. 6. Revised Versions of the GNU Lesser General Public License The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \u201cor any later version\u201d applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"License"},{"location":"LICENSE/#gnu-lesser-general-public-license","text":"Version 3, 29 June 2007 Copyright \u00a9 2007 Free Software Foundation, Inc. < http://fsf.org/ > Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below.","title":"GNU Lesser General Public License"},{"location":"LICENSE/#0-additional-definitions","text":"As used herein, \u201cthis License\u201d refers to version 3 of the GNU Lesser General Public License, and the \u201cGNU GPL\u201d refers to version 3 of the GNU General Public License. \u201cThe Library\u201d refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \u201cApplication\u201d is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \u201cCombined Work\u201d is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \u201cLinked Version\u201d. The \u201cMinimal Corresponding Source\u201d for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \u201cCorresponding Application Code\u201d for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work.","title":"0. Additional Definitions"},{"location":"LICENSE/#1-exception-to-section-3-of-the-gnu-gpl","text":"You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL.","title":"1. Exception to Section 3 of the GNU GPL"},{"location":"LICENSE/#2-conveying-modified-versions","text":"If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy.","title":"2. Conveying Modified Versions"},{"location":"LICENSE/#3-object-code-incorporating-material-from-library-header-files","text":"The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document.","title":"3. Object Code Incorporating Material from Library Header Files"},{"location":"LICENSE/#4-combined-works","text":"You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0) Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1) Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 4d0 , the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 4d1 , you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.)","title":"4. Combined Works"},{"location":"LICENSE/#5-combined-libraries","text":"You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work.","title":"5. Combined Libraries"},{"location":"LICENSE/#6-revised-versions-of-the-gnu-lesser-general-public-license","text":"The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \u201cor any later version\u201d applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"6. Revised Versions of the GNU Lesser General Public License"},{"location":"examples/","text":"Overview Using ```bash: usage: torrentfile -h -d [-s ] [-c ] [-a [ ...]] [-o ] [--meta-version ] [-l ] [-r <.torrent>] Create or Re-Check Bittorrent meta files for Bittorrent v1, v2 or v1, v2 combo Hybrids. positional arguments: path to .torrent file content optional arguments: -h, --help show this help message and exit -v, --version show program version and exit -d, --debug output debug information -p, --private create .torrent file for private tracker -s , --source specify source -c , --comment include a comment in file metadata -o , --out output path for created .torrent file -a [ ...], --announce [ ...] One or more announce urls for Bittorrent tracker --meta-version .torrent file version. Options = 1, 2 or 3. (1) = Bittorrent v1;. (Default) (2) = Bittorrent v2. (3) = Bittorrent v1 & v2 hybrid. -l , --piece-length piece size used by Bittorrent transfer protocol. Acceptable values include numbers 14-35, will be treated as the exponent for 2^n power, or any power of 2 integer in 16KB-16MB. e.g. --piece-length 14 is the same as --piece-length 16384 If this option flag is not used, the program will calculate an appropriate value automatically. -r <.torrent>, --re-check <.torrent> <.torrent> is the path to a .torrent meta file. Check data integrity with <.torrent> file. When this option is active, all other options are ignored (except -d). ``` CLI Usage Examples Example 1 torrentfile /path/to/data --announce https://tracker.com/announce_1234 --private Create a .torrent file with: contents: /path/to/data tracker : https://tracker.com/announce_1234 set for private tracker. Example 2 torrentfile -d --a https://traker2.com/annce https://traker3.com/annce --piece-length 18 /contnts/path Create .torrent file in debug mode with: contents: /some/dir trackers: https://tracker2.com/announce , https://tracker3.com/announce piece length: 262144 or 2 18 bytes Example 3 torrentfile /home/document -o /home/document_1.torrent -a https://tracker.com --meta-version 3 Create a .torrent file with Bittorrent v1 & 2 Hybrid format: contents: /home/document tracker: https://tracker.com output file: /home/document_1.torrent Example 4 $ torrentfile -d -r /path/to/file.torrent /path/to/contents >> 100% Check a .torrent file in debug mode against directory contents.","title":"Overview"},{"location":"examples/#overview","text":"","title":"Overview"},{"location":"examples/#using","text":"```bash: usage: torrentfile -h -d [-s ] [-c ] [-a [ ...]] [-o ] [--meta-version ] [-l ] [-r <.torrent>] Create or Re-Check Bittorrent meta files for Bittorrent v1, v2 or v1, v2 combo Hybrids. positional arguments: path to .torrent file content optional arguments: -h, --help show this help message and exit -v, --version show program version and exit -d, --debug output debug information -p, --private create .torrent file for private tracker -s , --source specify source -c , --comment include a comment in file metadata -o , --out output path for created .torrent file -a [ ...], --announce [ ...] One or more announce urls for Bittorrent tracker --meta-version .torrent file version. Options = 1, 2 or 3. (1) = Bittorrent v1;. (Default) (2) = Bittorrent v2. (3) = Bittorrent v1 & v2 hybrid. -l , --piece-length piece size used by Bittorrent transfer protocol. Acceptable values include numbers 14-35, will be treated as the exponent for 2^n power, or any power of 2 integer in 16KB-16MB. e.g. --piece-length 14 is the same as --piece-length 16384 If this option flag is not used, the program will calculate an appropriate value automatically. -r <.torrent>, --re-check <.torrent> <.torrent> is the path to a .torrent meta file. Check data integrity with <.torrent> file. When this option is active, all other options are ignored (except -d). ```","title":"Using"},{"location":"examples/#cli-usage-examples","text":"","title":"CLI Usage Examples"},{"location":"examples/#example-1","text":"torrentfile /path/to/data --announce https://tracker.com/announce_1234 --private Create a .torrent file with: contents: /path/to/data tracker : https://tracker.com/announce_1234 set for private tracker.","title":"Example 1"},{"location":"examples/#example-2","text":"torrentfile -d --a https://traker2.com/annce https://traker3.com/annce --piece-length 18 /contnts/path Create .torrent file in debug mode with: contents: /some/dir trackers: https://tracker2.com/announce , https://tracker3.com/announce piece length: 262144 or 2 18 bytes","title":"Example 2"},{"location":"examples/#example-3","text":"torrentfile /home/document -o /home/document_1.torrent -a https://tracker.com --meta-version 3 Create a .torrent file with Bittorrent v1 & 2 Hybrid format: contents: /home/document tracker: https://tracker.com output file: /home/document_1.torrent","title":"Example 3"},{"location":"examples/#example-4","text":"$ torrentfile -d -r /path/to/file.torrent /path/to/contents >> 100% Check a .torrent file in debug mode against directory contents.","title":"Example 4"},{"location":"hasher/","text":"Hasher Module Piece/File Hashers for Bittorrent meta file contents. Feeder Construct the Feeder class. Seemlesly generate hashes of piece length data from filelist contents. Parameters: Name Type Description Default paths `list` List of files. required piece_length `int` Size of chuncks to split the data into. required total `int` Sum of all files in file list. required __init__ ( self , paths , piece_length , total ) special Generate hashes of piece length data from filelist contents. Source code in torrentfile\\hasher.py def __init__ ( self , paths , piece_length , total ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . total = total self . pieces = [] self . index = 0 self . piece_count = 0 self . num_pieces = math . ceil ( self . total // self . piece_length ) self . current = open ( self . paths [ 0 ], \"rb\" ) self . iterator = None __iter__ ( self ) special Iterate through feed pieces. Returns: Type Description self (`iterator`) Iterator for leaves/hash pieces. Source code in torrentfile\\hasher.py def __iter__ ( self ): \"\"\"Iterate through feed pieces. Returns: self (`iterator`): Iterator for leaves/hash pieces. \"\"\" self . iterator = self . leaves () return self . iterator handle_partial ( self , arr , partial ) Seemlessly move to next file for input data. Parameters: Name Type Description Default arr `bytearray` Incomplete piece containing partial data required partial `int` Size of incomplete piece_length required Returns: Type Description digest (`bytes`) SHA1 digest of the complete piece. Source code in torrentfile\\hasher.py def handle_partial ( self , arr , partial ): \"\"\"Seemlessly move to next file for input data. Args: arr (`bytearray`): Incomplete piece containing partial data partial (`int`): Size of incomplete piece_length Returns: digest (`bytes`): SHA1 digest of the complete piece. \"\"\" while partial < self . piece_length and self . next_file (): target = self . piece_length - partial temp = bytearray ( target ) size = self . current . readinto ( temp ) arr . extend ( temp [: size ]) partial += size if size == target : break return sha1 ( arr ) . digest () # nosec leaves ( self ) Generate piece-length pieces of data from input file list. Source code in torrentfile\\hasher.py def leaves ( self ): \"\"\"Generate piece-length pieces of data from input file list.\"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): break elif size < self . piece_length : yield self . handle_partial ( piece [: size ], size ) else : yield sha1 ( piece ) . digest () # nosec self . piece_count += 1 next_file ( self ) Seemlessly transition to next file in file list. Source code in torrentfile\\hasher.py def next_file ( self ): \"\"\"Seemlessly transition to next file in file list.\"\"\" self . index += 1 if self . index < len ( self . paths ): self . current . close () self . current = open ( self . paths [ self . index ], \"rb\" ) return True return False HybridHash Calculate hashes for Hybrid torrentfile. Uses sha1 and sha256 hashes for each version # nosec of the Bittorrent protocols meta files respectively. Parameters: Name Type Description Default path `str` path to target file. required piece_length `int` piece length for data chunks. required __init__ ( self , path , piece_length ) special Construct Hasher class instances for each file in torrent. Source code in torrentfile\\hasher.py def __init__ ( self , path , piece_length ): \"\"\"Construct Hasher class instances for each file in torrent.\"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None self . amount = piece_length // BLOCK_SIZE logging . debug ( \"Beginning file hashing: %s \" , self . path ) with open ( path , \"rb\" ) as data : self . _process_file ( data ) calculate_root ( self ) Calculate the root hash for opened file. Source code in torrentfile\\hasher.py def calculate_root ( self ): \"\"\"Calculate the root hash for opened file.\"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) next_pow_two = 1 << ( len ( self . layer_hashes ) - 1 ) . bit_length () remainder = next_pow_two - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes ) V2Hash Calculate the root hash and piece layers for file contents. Iterates over 16KiB blocks of data from given file, hashes the data, then creates a hash tree from the individual block hashes until size of hashed data equals the piece-length. Then continues the hash tree until root hash is calculated. Parameters: Name Type Description Default path `str` Path to file. required piece_length `int` Size of layer hashes pieces. required __init__ ( self , path , piece_length ) special Calculate and store hash information for specific file. Source code in torrentfile\\hasher.py def __init__ ( self , path , piece_length ): \"\"\"Calculate and store hash information for specific file.\"\"\" self . path = path self . root = None self . piece_layer = None self . layer_hashes = [] self . piece_length = piece_length self . num_blocks = piece_length // BLOCK_SIZE logging . debug ( \"Hashing v2: %s \" , self . path ) with open ( self . path , \"rb\" ) as fd : self . process_file ( fd ) process_file ( self , fd ) Calculate hashes over 16KiB chuncks of file content. Parameters: Name Type Description Default fd `str` Opened file in read mode. required Source code in torrentfile\\hasher.py def process_file ( self , fd ): \"\"\"Calculate hashes over 16KiB chuncks of file content. Args: fd (`str`): Opened file in read mode. \"\"\" while True : total = 0 blocks = [] leaf = bytearray ( BLOCK_SIZE ) # generate leaves of merkle tree for _ in range ( self . num_blocks ): size = fd . readinto ( leaf ) total += size if not size : break blocks . append ( sha256 ( leaf [: size ]) . digest ()) # blocks is empty mean eof if not blocks : break if len ( blocks ) != self . num_blocks : if not self . layer_hashes : next_pow_2 = 1 << int ( math . log2 ( total ) + 1 ) remaining = (( next_pow_2 - total ) // BLOCK_SIZE ) + 1 else : remaining = self . num_blocks - size padding = [ bytes ( HASH_SIZE ) for _ in range ( remaining )] blocks . extend ( padding ) # if the file is smaller than piece length layer_hash = merkle_root ( blocks ) self . layer_hashes . append ( layer_hash ) self . _calculate_root () merkle_root ( blocks ) Calculate the merkle root for a seq of sha256 hash digests. Source code in torrentfile\\hasher.py def merkle_root ( blocks ): \"\"\"Calculate the merkle root for a seq of sha256 hash digests.\"\"\" while len ( blocks ) > 1 : blocks = [ sha256 ( x + y ) . digest () for x , y in zip ( * [ iter ( blocks )] * 2 )] return blocks [ 0 ]","title":"Hasher"},{"location":"hasher/#hasher-module","text":"Piece/File Hashers for Bittorrent meta file contents.","title":"Hasher Module"},{"location":"hasher/#torrentfile.hasher.Feeder","text":"Construct the Feeder class. Seemlesly generate hashes of piece length data from filelist contents. Parameters: Name Type Description Default paths `list` List of files. required piece_length `int` Size of chuncks to split the data into. required total `int` Sum of all files in file list. required","title":"Feeder"},{"location":"hasher/#torrentfile.hasher.Feeder.__init__","text":"Generate hashes of piece length data from filelist contents. Source code in torrentfile\\hasher.py def __init__ ( self , paths , piece_length , total ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . total = total self . pieces = [] self . index = 0 self . piece_count = 0 self . num_pieces = math . ceil ( self . total // self . piece_length ) self . current = open ( self . paths [ 0 ], \"rb\" ) self . iterator = None","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.Feeder.__iter__","text":"Iterate through feed pieces. Returns: Type Description self (`iterator`) Iterator for leaves/hash pieces. Source code in torrentfile\\hasher.py def __iter__ ( self ): \"\"\"Iterate through feed pieces. Returns: self (`iterator`): Iterator for leaves/hash pieces. \"\"\" self . iterator = self . leaves () return self . iterator","title":"__iter__()"},{"location":"hasher/#torrentfile.hasher.Feeder.handle_partial","text":"Seemlessly move to next file for input data. Parameters: Name Type Description Default arr `bytearray` Incomplete piece containing partial data required partial `int` Size of incomplete piece_length required Returns: Type Description digest (`bytes`) SHA1 digest of the complete piece. Source code in torrentfile\\hasher.py def handle_partial ( self , arr , partial ): \"\"\"Seemlessly move to next file for input data. Args: arr (`bytearray`): Incomplete piece containing partial data partial (`int`): Size of incomplete piece_length Returns: digest (`bytes`): SHA1 digest of the complete piece. \"\"\" while partial < self . piece_length and self . next_file (): target = self . piece_length - partial temp = bytearray ( target ) size = self . current . readinto ( temp ) arr . extend ( temp [: size ]) partial += size if size == target : break return sha1 ( arr ) . digest () # nosec","title":"handle_partial()"},{"location":"hasher/#torrentfile.hasher.Feeder.leaves","text":"Generate piece-length pieces of data from input file list. Source code in torrentfile\\hasher.py def leaves ( self ): \"\"\"Generate piece-length pieces of data from input file list.\"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): break elif size < self . piece_length : yield self . handle_partial ( piece [: size ], size ) else : yield sha1 ( piece ) . digest () # nosec self . piece_count += 1","title":"leaves()"},{"location":"hasher/#torrentfile.hasher.Feeder.next_file","text":"Seemlessly transition to next file in file list. Source code in torrentfile\\hasher.py def next_file ( self ): \"\"\"Seemlessly transition to next file in file list.\"\"\" self . index += 1 if self . index < len ( self . paths ): self . current . close () self . current = open ( self . paths [ self . index ], \"rb\" ) return True return False","title":"next_file()"},{"location":"hasher/#torrentfile.hasher.HybridHash","text":"Calculate hashes for Hybrid torrentfile. Uses sha1 and sha256 hashes for each version # nosec of the Bittorrent protocols meta files respectively. Parameters: Name Type Description Default path `str` path to target file. required piece_length `int` piece length for data chunks. required","title":"HybridHash"},{"location":"hasher/#torrentfile.hasher.HybridHash.__init__","text":"Construct Hasher class instances for each file in torrent. Source code in torrentfile\\hasher.py def __init__ ( self , path , piece_length ): \"\"\"Construct Hasher class instances for each file in torrent.\"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None self . amount = piece_length // BLOCK_SIZE logging . debug ( \"Beginning file hashing: %s \" , self . path ) with open ( path , \"rb\" ) as data : self . _process_file ( data )","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.HybridHash.calculate_root","text":"Calculate the root hash for opened file. Source code in torrentfile\\hasher.py def calculate_root ( self ): \"\"\"Calculate the root hash for opened file.\"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) next_pow_two = 1 << ( len ( self . layer_hashes ) - 1 ) . bit_length () remainder = next_pow_two - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes )","title":"calculate_root()"},{"location":"hasher/#torrentfile.hasher.V2Hash","text":"Calculate the root hash and piece layers for file contents. Iterates over 16KiB blocks of data from given file, hashes the data, then creates a hash tree from the individual block hashes until size of hashed data equals the piece-length. Then continues the hash tree until root hash is calculated. Parameters: Name Type Description Default path `str` Path to file. required piece_length `int` Size of layer hashes pieces. required","title":"V2Hash"},{"location":"hasher/#torrentfile.hasher.V2Hash.__init__","text":"Calculate and store hash information for specific file. Source code in torrentfile\\hasher.py def __init__ ( self , path , piece_length ): \"\"\"Calculate and store hash information for specific file.\"\"\" self . path = path self . root = None self . piece_layer = None self . layer_hashes = [] self . piece_length = piece_length self . num_blocks = piece_length // BLOCK_SIZE logging . debug ( \"Hashing v2: %s \" , self . path ) with open ( self . path , \"rb\" ) as fd : self . process_file ( fd )","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.V2Hash.process_file","text":"Calculate hashes over 16KiB chuncks of file content. Parameters: Name Type Description Default fd `str` Opened file in read mode. required Source code in torrentfile\\hasher.py def process_file ( self , fd ): \"\"\"Calculate hashes over 16KiB chuncks of file content. Args: fd (`str`): Opened file in read mode. \"\"\" while True : total = 0 blocks = [] leaf = bytearray ( BLOCK_SIZE ) # generate leaves of merkle tree for _ in range ( self . num_blocks ): size = fd . readinto ( leaf ) total += size if not size : break blocks . append ( sha256 ( leaf [: size ]) . digest ()) # blocks is empty mean eof if not blocks : break if len ( blocks ) != self . num_blocks : if not self . layer_hashes : next_pow_2 = 1 << int ( math . log2 ( total ) + 1 ) remaining = (( next_pow_2 - total ) // BLOCK_SIZE ) + 1 else : remaining = self . num_blocks - size padding = [ bytes ( HASH_SIZE ) for _ in range ( remaining )] blocks . extend ( padding ) # if the file is smaller than piece length layer_hash = merkle_root ( blocks ) self . layer_hashes . append ( layer_hash ) self . _calculate_root ()","title":"process_file()"},{"location":"hasher/#torrentfile.hasher.merkle_root","text":"Calculate the merkle root for a seq of sha256 hash digests. Source code in torrentfile\\hasher.py def merkle_root ( blocks ): \"\"\"Calculate the merkle root for a seq of sha256 hash digests.\"\"\" while len ( blocks ) > 1 : blocks = [ sha256 ( x + y ) . digest () for x , y in zip ( * [ iter ( blocks )] * 2 )] return blocks [ 0 ]","title":"merkle_root()"},{"location":"progress/","text":"Progress Module Module container Checker classes and providing checker functionality. CheckerClass Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters: Name Type Description Default metafile `str` Path to \".torrent\" file. required location `str` Path where the content is located in filesystem. required Examples: metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" location = \"/path/to/location\" os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True checker = Checker(metafile, location) result property readonly Generate result percentage and store for future calls. __init__ ( self , metafile , path ) special Validate data against hashes contained in .torrent file. Parameters: Name Type Description Default metafile `str` path to .torrent file required path `str` path to content or contents parent directory. required Source code in torrentfile\\progress.py def __init__ ( self , metafile , path ): \"\"\"Validate data against hashes contained in .torrent file. Args: metafile (`str`): path to .torrent file path (`str`): path to content or contents parent directory. \"\"\" self . _result = None self . meta_version = None self . metafile = metafile self . log_msg ( \"Checking: %s , %s \" , metafile , path ) self . info = self . parse_metafile () self . name = self . info [ \"name\" ] self . piece_length = self . info [ \"piece length\" ] self . root = self . find_root ( path ) self . total = 0 self . paths = [] self . fileinfo = {} self . check_paths () check_paths ( self ) Gather all file paths described in the torrent file. Source code in torrentfile\\progress.py def check_paths ( self ): \"\"\"Gather all file paths described in the torrent file.\"\"\" if os . path . isfile ( self . root ): self . log_msg ( \" %s points to a single file\" , self . root ) self . paths . append ( self . root ) if self . meta_version == 1 : self . fileinfo [ self . root ] = { \"length\" : self . info [ \"length\" ]} self . total = self . info [ \"length\" ] self . pieces = split_pieces ( self . info [ \"pieces\" ], SHA1 ) else : info = self . info [ \"file tree\" ][ self . name ][ \"\" ] info [ \"partial\" ] = self . name self . total = info [ \"length\" ] if self . total > self . piece_length : layers = self . info [ \"piece layers\" ][ info [ \"pieces root\" ]] info [ \"layer hashes\" ] = split_pieces ( layers , SHA256 ) self . fileinfo [ self . root ] = info return # Otherwise Content is more than 1 file. self . log_msg ( \" %s points to a directory\" , self . root ) if self . meta_version == 1 : for path in self . info [ \"files\" ]: self . total += path [ \"length\" ] rlpath = os . path . join ( * path [ \"path\" ]) full = os . path . join ( self . root , rlpath ) self . log_msg ( \"Including file path: %s \" , rlpath ) self . fileinfo [ full ] = { \"length\" : path [ \"length\" ]} self . paths . append ( full ) # Split pieces into individual hash digests. self . pieces = split_pieces ( self . info [ \"pieces\" ], SHA1 ) return self . walk_file_tree ( self . info [ \"file tree\" ], []) find_root ( self , path ) Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Returns: Type Description `str` root path to content Source code in torrentfile\\progress.py def find_root ( self , path ): \"\"\"Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Returns: `str`: root path to content \"\"\" if not os . path . exists ( path ): self . log_msg ( \"Could not locate torrent content %s .\" , path ) raise FileNotFoundError ( path ) root = os . path . abspath ( path ) base = os . path . basename ( root ) if base == self . name : self . log_msg ( \"Content found: %s .\" , root ) return root self . log_msg ( \"Searching for torrent root in %s \" , root ) for name in os . listdir ( root ): if name == self . name : root = os . path . join ( root , name ) self . log_msg ( \"Content Found: %s \" , root ) return root self . log_msg ( \"Could not locate torrent content in: %s \" , root ) raise FileNotFoundError ( root ) iter_hashes ( self ) Produce results of comparing torrent contents piece by piece. !!! yields chunck ( bytes ): hash of data found on disk piece ( bytes ): hash of data when complete and correct path ( str ): path to file being hashed size ( int ): length of bytes hashed for piece Source code in torrentfile\\progress.py def iter_hashes ( self ): \"\"\"Produce results of comparing torrent contents piece by piece. Yields: chunck (`bytes`): hash of data found on disk piece (`bytes`): hash of data when complete and correct path (`str`): path to file being hashed size (`int`): length of bytes hashed for piece \"\"\" matched = consumed = 0 if self . meta_version == 1 : checker = FeedChecker args = ( self . paths , self . piece_length , self . fileinfo , self . pieces ) else : checker = HashChecker hasher = V2Hash if self . meta_version == 2 else HybridHash args = ( self . paths , self . piece_length , self . fileinfo , hasher ) for chunk , piece , path , size in checker ( * args ): consumed += size if chunk == piece : matched += size logging . debug ( \"Match Success: %s , %s \" , path , size ) else : logging . debug ( \"Match Fail: %s , %s \" , path , size ) yield chunk , piece , path , size total_consumed = str ( int ( consumed / self . total * 100 )) percent_matched = str ( int ( matched / consumed * 100 )) self . log_msg ( \"Processed: %s%% , Matched: %s%% \" , total_consumed , percent_matched ) if consumed : self . log_msg ( \"Re-Check Complete: \\n %s%% of %s found at %s \" , percent_matched , self . metafile , self . root ) self . _result = percent_matched else : # pragma: no cover self . log_msg ( \"Re-Check Complete: \\n 0 %% of %s found at %s \" , self . metafile , self . root ) self . _result = \"0\" log_msg ( self , * args , * , level = 20 ) Log message msg to logger and send msg to callback hook. Parameters: Name Type Description Default `*args` `Iterable`[`str`] formatting args for log message required level `int`, default=`logging.INFO`) Log level for this message 20 Source code in torrentfile\\progress.py def log_msg ( self , * args , level = logging . INFO ): \"\"\"Log message `msg` to logger and send `msg` to callback hook. Args: `*args` (`Iterable`[`str`]): formatting args for log message level (`int`, default=`logging.INFO`) : Log level for this message \"\"\" logging . log ( level , * args ) if self . _hook and level == logging . INFO : if len ( args ) == 1 : msg = args [ 0 ] elif len ( args ) == 2 : msg = ( args [ 0 ] % args [ 1 ]) elif len ( args ) >= 3 : msg = ( args [ 0 ] % tuple ( args [ 1 :])) self . _hook ( msg ) parse_metafile ( self ) Flatten Meta dictionary of torrent file. Returns: Type Description `dict` flattened meta dictionary. Source code in torrentfile\\progress.py def parse_metafile ( self ): \"\"\"Flatten Meta dictionary of torrent file. Returns: `dict`: flattened meta dictionary. \"\"\" if not os . path . exists ( self . metafile ): self . log_msg ( \"File %s could not be found.\" , self . metafile ) raise FileNotFoundError ( self . metafile ) info = {} has_pieces = has_meta_version = False for k , v in pyben . load ( self . metafile ) . items (): if k == \"info\" : for key , val in v . items (): info [ key ] = val if key == \"pieces\" : has_pieces = True if key == \"meta version\" : has_meta_version = True else : info [ k ] = v if has_meta_version and has_pieces : self . meta_version = 3 elif has_meta_version : self . meta_version = 2 else : self . meta_version = 1 self . log_msg ( \"Detected Meta Version %s .\" , str ( self . meta_version )) return info register_callback ( hook ) classmethod Register hooks from 3rd party programs to access generated info. Parameters: Name Type Description Default hook `function` callback function for the logging feature. required Source code in torrentfile\\progress.py @classmethod def register_callback ( cls , hook ): \"\"\"Register hooks from 3rd party programs to access generated info. Args: hook (`function`): callback function for the logging feature. \"\"\" cls . _hook = hook walk_file_tree ( self , tree , partials ) Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Parameters: Name Type Description Default tree `dict` File Tree dict extracted from torrent file. required partials `list` list of intermediate pathnames. required Source code in torrentfile\\progress.py def walk_file_tree ( self , tree , partials ): \"\"\"Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Args: tree (`dict`): File Tree dict extracted from torrent file. partials (`list`): list of intermediate pathnames. \"\"\" for key , val in tree . items (): # Empty string means the tree's leaf is value if \"\" in val : path = os . path . join ( self . root , * partials , key ) info = self . fileinfo [ path ] = val [ \"\" ] info [ \"partial\" ] = key size = val [ \"\" ][ \"length\" ] # get layer hashes for this file if size > self . piece_length : root = val [ \"\" ][ \"pieces root\" ] layer_hashes = self . info [ \"piece layers\" ][ root ] info [ \"layer hashes\" ] = split_pieces ( layer_hashes , SHA256 ) self . paths . append ( path ) self . total += size self . log_msg ( \"Including: path - %s , length - %s \" , path , size ) else : self . walk_file_tree ( val , partials + [ key ]) FeedChecker Validates torrent content. Seemlesly validate torrent file contents by comparing hashes in metafile against data on disk. Parameters: Name Type Description Default paths `list` List of stirngs indicating file paths. required piece_length `int` Size of data blocks to split the data into. required total `int` Sum total in bytes of all files in file list. required fileinfo `dict` Info and meta dictionary from .torrent file. required current_length property readonly Length of current file contents in bytes. __init__ ( self , paths , piece_length , fileinfo , pieces ) special Generate hashes of piece length data from filelist contents. Source code in torrentfile\\progress.py def __init__ ( self , paths , piece_length , fileinfo , pieces ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . pieces = pieces self . fileinfo = fileinfo self . piece_map = {} self . index = 0 self . piece_count = 0 self . itor = None __iter__ ( self ) special Assign iterator and return self. Source code in torrentfile\\progress.py def __iter__ ( self ): \"\"\"Assign iterator and return self.\"\"\" self . itor = self . iter_pieces () return self __next__ ( self ) special Yield back result of comparison. Source code in torrentfile\\progress.py def __next__ ( self ): \"\"\"Yield back result of comparison.\"\"\" partial = next ( self . itor ) chunck = sha1 ( partial ) . digest () # nosec try : piece = self . pieces [ self . piece_count ] except IndexError : raise StopIteration # pragma: no cover path = self . paths [ self . index ] self . piece_count += 1 return chunck , piece , path , len ( partial ) extract ( self , path , partial ) Split file paths contents into blocks of data for hash pieces. Parameters: Name Type Description Default path `str` path to content. required partial `bytes` any remaining content from last file. required !!! yields partial ( bytes ): Hash digest for block of .torrent contents. Source code in torrentfile\\progress.py def extract ( self , path , partial ): \"\"\"Split file paths contents into blocks of data for hash pieces. Args: path (`str`): path to content. partial (`bytes`): any remaining content from last file. Yields: partial (`bytes`): Hash digest for block of .torrent contents. \"\"\" read = 0 size = os . path . getsize ( path ) length = self . fileinfo [ path ][ \"length\" ] with open ( path , \"rb\" ) as current : while True : bitlength = self . piece_length - len ( partial ) part = bytearray ( bitlength ) amount = current . readinto ( part ) read += amount partial . extend ( part [: amount ]) if amount < bitlength : if size == read == length : yield partial break yield partial partial = bytearray ( 0 ) while length - size > 0 : left = self . piece_length - len ( partial ) if length - size > left : padding = bytearray ( left ) size += left partial . extend ( padding ) yield partial partial = bytearray ( 0 ) else : partial . extend ( bytearray ( length - size )) size += ( length - size ) yield partial iter_pieces ( self ) Iterate through, and hash pieces of torrent contents. !!! yields piece ( bytes ): hash digest for block of torrent data. Source code in torrentfile\\progress.py def iter_pieces ( self ): \"\"\"Iterate through, and hash pieces of torrent contents. Yields: piece (`bytes`): hash digest for block of torrent data. \"\"\" partial = bytearray () for i , path in enumerate ( self . paths ): self . index = i if os . path . exists ( path ): for piece in self . extract ( path , partial ): if len ( piece ) == self . piece_length : yield piece partial = bytearray () elif i + 1 == len ( self . paths ): yield piece else : partial = piece else : for blank in self . _gen_blanks ( partial ): if len ( blank ) == self . piece_length : yield blank partial = bytearray () else : partial = blank HashChecker Construct the HybridChecker. Verify that root hashes of content files match the .torrent files. Parameters: Name Type Description Default paths `list` List of files. required piece_length `int` Size of chuncks to split the data into. required fileinfo `dict` Info from .torrent file being checked. required __init__ ( self , paths , piece_length , fileinfo , hasher ) special Construct a HybridChecker instance. Source code in torrentfile\\progress.py def __init__ ( self , paths , piece_length , fileinfo , hasher ): \"\"\"Construct a HybridChecker instance.\"\"\" self . paths = paths self . hasher = hasher self . piece_length = piece_length self . fileinfo = fileinfo self . itor = None logging . debug ( \"Starting Hash Checker. piece length: %s \" , piece_length ) __iter__ ( self ) special Assign iterator and return self. Source code in torrentfile\\progress.py def __iter__ ( self ): \"\"\"Assign iterator and return self.\"\"\" self . itor = self . iter_paths () return self __next__ ( self ) special Provide the result of comparison. Source code in torrentfile\\progress.py def __next__ ( self ): \"\"\"Provide the result of comparison.\"\"\" try : value = next ( self . itor ) return value except StopIteration as stopiter : raise StopIteration () from stopiter iter_paths ( self ) Iterate through and compare root file hashes to .torrent file. Parameters: Name Type Description Default hasher class The class user to caluclate root hash. required !!! yields results ( tuple ): The size of the file and result of match. Source code in torrentfile\\progress.py def iter_paths ( self ): \"\"\"Iterate through and compare root file hashes to .torrent file. Args: hasher (class): The class user to caluclate root hash. Yields: results (`tuple`): The size of the file and result of match. \"\"\" for path in tqdm ( self . paths ): info = self . fileinfo [ path ] length = info [ \"length\" ] logging . debug ( \" %s length: %s \" , path , str ( length )) roothash = info [ \"pieces root\" ] logging . debug ( \" %s root hash %s \" , path , str ( roothash )) if not os . path . exists ( path ): if \"layer hashes\" in info and info [ \"layer hashes\" ]: pieces = info [ \"layer hashes\" ] else : pieces = [ roothash ] for i , piece in enumerate ( pieces ): if len ( pieces ) == 1 : size = length elif i < len ( pieces ) - 1 : size = self . piece_length else : size = length - (( len ( pieces ) - 1 ) * self . piece_length ) logging . debug ( \"Yielding: %s %s %s %s \" , str ( bytes ( SHA256 )), str ( piece ), path , str ( size )) yield bytes ( SHA256 ), piece , path , size continue hashed = self . hasher ( path , self . piece_length ) if \"layer hashes\" in info : hash_pieces = split_pieces ( hashed . piece_layer , SHA256 ) info_pieces = info [ \"layer hashes\" ] else : hash_pieces = [ hashed . root ] info_pieces = [ info [ \"pieces root\" ]] diff = len ( info_pieces ) - len ( hash_pieces ) if diff > 0 : hash_pieces += [ bytes ( SHA256 )] * diff num_pieces = len ( hash_pieces ) size = self . piece_length for chunk , piece in zip ( hash_pieces , info_pieces ): if num_pieces == 1 : size = length - (( len ( hash_pieces ) - 1 ) * size ) logging . debug ( \"Yielding: %s , %s , %s , %s \" , str ( chunk ), str ( piece ), str ( path ), str ( size )) yield chunk , piece , path , size num_pieces -= 1 split_pieces ( pieces , hash_size ) Split bytes into 20 piece chuncks for sha1 digest. Parameters: Name Type Description Default pieces `bytes` Initial data. required Returns: Type Description lst (`list`) Pieces broken into groups of 20 bytes. Source code in torrentfile\\progress.py def split_pieces ( pieces , hash_size ): \"\"\"Split bytes into 20 piece chuncks for sha1 digest. Args: pieces (`bytes`): Initial data. Returns: lst (`list`): Pieces broken into groups of 20 bytes. \"\"\" lst = [] start = 0 while start < len ( pieces ): lst . append ( pieces [ start : start + hash_size ]) start += hash_size return lst","title":"Progress"},{"location":"progress/#progress-module","text":"Module container Checker classes and providing checker functionality.","title":"Progress Module"},{"location":"progress/#torrentfile.progress.CheckerClass","text":"Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters: Name Type Description Default metafile `str` Path to \".torrent\" file. required location `str` Path where the content is located in filesystem. required Examples: metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" location = \"/path/to/location\" os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True checker = Checker(metafile, location)","title":"CheckerClass"},{"location":"progress/#torrentfile.progress.CheckerClass.result","text":"Generate result percentage and store for future calls.","title":"result"},{"location":"progress/#torrentfile.progress.CheckerClass.__init__","text":"Validate data against hashes contained in .torrent file. Parameters: Name Type Description Default metafile `str` path to .torrent file required path `str` path to content or contents parent directory. required Source code in torrentfile\\progress.py def __init__ ( self , metafile , path ): \"\"\"Validate data against hashes contained in .torrent file. Args: metafile (`str`): path to .torrent file path (`str`): path to content or contents parent directory. \"\"\" self . _result = None self . meta_version = None self . metafile = metafile self . log_msg ( \"Checking: %s , %s \" , metafile , path ) self . info = self . parse_metafile () self . name = self . info [ \"name\" ] self . piece_length = self . info [ \"piece length\" ] self . root = self . find_root ( path ) self . total = 0 self . paths = [] self . fileinfo = {} self . check_paths ()","title":"__init__()"},{"location":"progress/#torrentfile.progress.CheckerClass.check_paths","text":"Gather all file paths described in the torrent file. Source code in torrentfile\\progress.py def check_paths ( self ): \"\"\"Gather all file paths described in the torrent file.\"\"\" if os . path . isfile ( self . root ): self . log_msg ( \" %s points to a single file\" , self . root ) self . paths . append ( self . root ) if self . meta_version == 1 : self . fileinfo [ self . root ] = { \"length\" : self . info [ \"length\" ]} self . total = self . info [ \"length\" ] self . pieces = split_pieces ( self . info [ \"pieces\" ], SHA1 ) else : info = self . info [ \"file tree\" ][ self . name ][ \"\" ] info [ \"partial\" ] = self . name self . total = info [ \"length\" ] if self . total > self . piece_length : layers = self . info [ \"piece layers\" ][ info [ \"pieces root\" ]] info [ \"layer hashes\" ] = split_pieces ( layers , SHA256 ) self . fileinfo [ self . root ] = info return # Otherwise Content is more than 1 file. self . log_msg ( \" %s points to a directory\" , self . root ) if self . meta_version == 1 : for path in self . info [ \"files\" ]: self . total += path [ \"length\" ] rlpath = os . path . join ( * path [ \"path\" ]) full = os . path . join ( self . root , rlpath ) self . log_msg ( \"Including file path: %s \" , rlpath ) self . fileinfo [ full ] = { \"length\" : path [ \"length\" ]} self . paths . append ( full ) # Split pieces into individual hash digests. self . pieces = split_pieces ( self . info [ \"pieces\" ], SHA1 ) return self . walk_file_tree ( self . info [ \"file tree\" ], [])","title":"check_paths()"},{"location":"progress/#torrentfile.progress.CheckerClass.find_root","text":"Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Returns: Type Description `str` root path to content Source code in torrentfile\\progress.py def find_root ( self , path ): \"\"\"Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Returns: `str`: root path to content \"\"\" if not os . path . exists ( path ): self . log_msg ( \"Could not locate torrent content %s .\" , path ) raise FileNotFoundError ( path ) root = os . path . abspath ( path ) base = os . path . basename ( root ) if base == self . name : self . log_msg ( \"Content found: %s .\" , root ) return root self . log_msg ( \"Searching for torrent root in %s \" , root ) for name in os . listdir ( root ): if name == self . name : root = os . path . join ( root , name ) self . log_msg ( \"Content Found: %s \" , root ) return root self . log_msg ( \"Could not locate torrent content in: %s \" , root ) raise FileNotFoundError ( root )","title":"find_root()"},{"location":"progress/#torrentfile.progress.CheckerClass.iter_hashes","text":"Produce results of comparing torrent contents piece by piece. !!! yields chunck ( bytes ): hash of data found on disk piece ( bytes ): hash of data when complete and correct path ( str ): path to file being hashed size ( int ): length of bytes hashed for piece Source code in torrentfile\\progress.py def iter_hashes ( self ): \"\"\"Produce results of comparing torrent contents piece by piece. Yields: chunck (`bytes`): hash of data found on disk piece (`bytes`): hash of data when complete and correct path (`str`): path to file being hashed size (`int`): length of bytes hashed for piece \"\"\" matched = consumed = 0 if self . meta_version == 1 : checker = FeedChecker args = ( self . paths , self . piece_length , self . fileinfo , self . pieces ) else : checker = HashChecker hasher = V2Hash if self . meta_version == 2 else HybridHash args = ( self . paths , self . piece_length , self . fileinfo , hasher ) for chunk , piece , path , size in checker ( * args ): consumed += size if chunk == piece : matched += size logging . debug ( \"Match Success: %s , %s \" , path , size ) else : logging . debug ( \"Match Fail: %s , %s \" , path , size ) yield chunk , piece , path , size total_consumed = str ( int ( consumed / self . total * 100 )) percent_matched = str ( int ( matched / consumed * 100 )) self . log_msg ( \"Processed: %s%% , Matched: %s%% \" , total_consumed , percent_matched ) if consumed : self . log_msg ( \"Re-Check Complete: \\n %s%% of %s found at %s \" , percent_matched , self . metafile , self . root ) self . _result = percent_matched else : # pragma: no cover self . log_msg ( \"Re-Check Complete: \\n 0 %% of %s found at %s \" , self . metafile , self . root ) self . _result = \"0\"","title":"iter_hashes()"},{"location":"progress/#torrentfile.progress.CheckerClass.log_msg","text":"Log message msg to logger and send msg to callback hook. Parameters: Name Type Description Default `*args` `Iterable`[`str`] formatting args for log message required level `int`, default=`logging.INFO`) Log level for this message 20 Source code in torrentfile\\progress.py def log_msg ( self , * args , level = logging . INFO ): \"\"\"Log message `msg` to logger and send `msg` to callback hook. Args: `*args` (`Iterable`[`str`]): formatting args for log message level (`int`, default=`logging.INFO`) : Log level for this message \"\"\" logging . log ( level , * args ) if self . _hook and level == logging . INFO : if len ( args ) == 1 : msg = args [ 0 ] elif len ( args ) == 2 : msg = ( args [ 0 ] % args [ 1 ]) elif len ( args ) >= 3 : msg = ( args [ 0 ] % tuple ( args [ 1 :])) self . _hook ( msg )","title":"log_msg()"},{"location":"progress/#torrentfile.progress.CheckerClass.parse_metafile","text":"Flatten Meta dictionary of torrent file. Returns: Type Description `dict` flattened meta dictionary. Source code in torrentfile\\progress.py def parse_metafile ( self ): \"\"\"Flatten Meta dictionary of torrent file. Returns: `dict`: flattened meta dictionary. \"\"\" if not os . path . exists ( self . metafile ): self . log_msg ( \"File %s could not be found.\" , self . metafile ) raise FileNotFoundError ( self . metafile ) info = {} has_pieces = has_meta_version = False for k , v in pyben . load ( self . metafile ) . items (): if k == \"info\" : for key , val in v . items (): info [ key ] = val if key == \"pieces\" : has_pieces = True if key == \"meta version\" : has_meta_version = True else : info [ k ] = v if has_meta_version and has_pieces : self . meta_version = 3 elif has_meta_version : self . meta_version = 2 else : self . meta_version = 1 self . log_msg ( \"Detected Meta Version %s .\" , str ( self . meta_version )) return info","title":"parse_metafile()"},{"location":"progress/#torrentfile.progress.CheckerClass.register_callback","text":"Register hooks from 3rd party programs to access generated info. Parameters: Name Type Description Default hook `function` callback function for the logging feature. required Source code in torrentfile\\progress.py @classmethod def register_callback ( cls , hook ): \"\"\"Register hooks from 3rd party programs to access generated info. Args: hook (`function`): callback function for the logging feature. \"\"\" cls . _hook = hook","title":"register_callback()"},{"location":"progress/#torrentfile.progress.CheckerClass.walk_file_tree","text":"Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Parameters: Name Type Description Default tree `dict` File Tree dict extracted from torrent file. required partials `list` list of intermediate pathnames. required Source code in torrentfile\\progress.py def walk_file_tree ( self , tree , partials ): \"\"\"Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Args: tree (`dict`): File Tree dict extracted from torrent file. partials (`list`): list of intermediate pathnames. \"\"\" for key , val in tree . items (): # Empty string means the tree's leaf is value if \"\" in val : path = os . path . join ( self . root , * partials , key ) info = self . fileinfo [ path ] = val [ \"\" ] info [ \"partial\" ] = key size = val [ \"\" ][ \"length\" ] # get layer hashes for this file if size > self . piece_length : root = val [ \"\" ][ \"pieces root\" ] layer_hashes = self . info [ \"piece layers\" ][ root ] info [ \"layer hashes\" ] = split_pieces ( layer_hashes , SHA256 ) self . paths . append ( path ) self . total += size self . log_msg ( \"Including: path - %s , length - %s \" , path , size ) else : self . walk_file_tree ( val , partials + [ key ])","title":"walk_file_tree()"},{"location":"progress/#torrentfile.progress.FeedChecker","text":"Validates torrent content. Seemlesly validate torrent file contents by comparing hashes in metafile against data on disk. Parameters: Name Type Description Default paths `list` List of stirngs indicating file paths. required piece_length `int` Size of data blocks to split the data into. required total `int` Sum total in bytes of all files in file list. required fileinfo `dict` Info and meta dictionary from .torrent file. required","title":"FeedChecker"},{"location":"progress/#torrentfile.progress.FeedChecker.current_length","text":"Length of current file contents in bytes.","title":"current_length"},{"location":"progress/#torrentfile.progress.FeedChecker.__init__","text":"Generate hashes of piece length data from filelist contents. Source code in torrentfile\\progress.py def __init__ ( self , paths , piece_length , fileinfo , pieces ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . pieces = pieces self . fileinfo = fileinfo self . piece_map = {} self . index = 0 self . piece_count = 0 self . itor = None","title":"__init__()"},{"location":"progress/#torrentfile.progress.FeedChecker.__iter__","text":"Assign iterator and return self. Source code in torrentfile\\progress.py def __iter__ ( self ): \"\"\"Assign iterator and return self.\"\"\" self . itor = self . iter_pieces () return self","title":"__iter__()"},{"location":"progress/#torrentfile.progress.FeedChecker.__next__","text":"Yield back result of comparison. Source code in torrentfile\\progress.py def __next__ ( self ): \"\"\"Yield back result of comparison.\"\"\" partial = next ( self . itor ) chunck = sha1 ( partial ) . digest () # nosec try : piece = self . pieces [ self . piece_count ] except IndexError : raise StopIteration # pragma: no cover path = self . paths [ self . index ] self . piece_count += 1 return chunck , piece , path , len ( partial )","title":"__next__()"},{"location":"progress/#torrentfile.progress.FeedChecker.extract","text":"Split file paths contents into blocks of data for hash pieces. Parameters: Name Type Description Default path `str` path to content. required partial `bytes` any remaining content from last file. required !!! yields partial ( bytes ): Hash digest for block of .torrent contents. Source code in torrentfile\\progress.py def extract ( self , path , partial ): \"\"\"Split file paths contents into blocks of data for hash pieces. Args: path (`str`): path to content. partial (`bytes`): any remaining content from last file. Yields: partial (`bytes`): Hash digest for block of .torrent contents. \"\"\" read = 0 size = os . path . getsize ( path ) length = self . fileinfo [ path ][ \"length\" ] with open ( path , \"rb\" ) as current : while True : bitlength = self . piece_length - len ( partial ) part = bytearray ( bitlength ) amount = current . readinto ( part ) read += amount partial . extend ( part [: amount ]) if amount < bitlength : if size == read == length : yield partial break yield partial partial = bytearray ( 0 ) while length - size > 0 : left = self . piece_length - len ( partial ) if length - size > left : padding = bytearray ( left ) size += left partial . extend ( padding ) yield partial partial = bytearray ( 0 ) else : partial . extend ( bytearray ( length - size )) size += ( length - size ) yield partial","title":"extract()"},{"location":"progress/#torrentfile.progress.FeedChecker.iter_pieces","text":"Iterate through, and hash pieces of torrent contents. !!! yields piece ( bytes ): hash digest for block of torrent data. Source code in torrentfile\\progress.py def iter_pieces ( self ): \"\"\"Iterate through, and hash pieces of torrent contents. Yields: piece (`bytes`): hash digest for block of torrent data. \"\"\" partial = bytearray () for i , path in enumerate ( self . paths ): self . index = i if os . path . exists ( path ): for piece in self . extract ( path , partial ): if len ( piece ) == self . piece_length : yield piece partial = bytearray () elif i + 1 == len ( self . paths ): yield piece else : partial = piece else : for blank in self . _gen_blanks ( partial ): if len ( blank ) == self . piece_length : yield blank partial = bytearray () else : partial = blank","title":"iter_pieces()"},{"location":"progress/#torrentfile.progress.HashChecker","text":"Construct the HybridChecker. Verify that root hashes of content files match the .torrent files. Parameters: Name Type Description Default paths `list` List of files. required piece_length `int` Size of chuncks to split the data into. required fileinfo `dict` Info from .torrent file being checked. required","title":"HashChecker"},{"location":"progress/#torrentfile.progress.HashChecker.__init__","text":"Construct a HybridChecker instance. Source code in torrentfile\\progress.py def __init__ ( self , paths , piece_length , fileinfo , hasher ): \"\"\"Construct a HybridChecker instance.\"\"\" self . paths = paths self . hasher = hasher self . piece_length = piece_length self . fileinfo = fileinfo self . itor = None logging . debug ( \"Starting Hash Checker. piece length: %s \" , piece_length )","title":"__init__()"},{"location":"progress/#torrentfile.progress.HashChecker.__iter__","text":"Assign iterator and return self. Source code in torrentfile\\progress.py def __iter__ ( self ): \"\"\"Assign iterator and return self.\"\"\" self . itor = self . iter_paths () return self","title":"__iter__()"},{"location":"progress/#torrentfile.progress.HashChecker.__next__","text":"Provide the result of comparison. Source code in torrentfile\\progress.py def __next__ ( self ): \"\"\"Provide the result of comparison.\"\"\" try : value = next ( self . itor ) return value except StopIteration as stopiter : raise StopIteration () from stopiter","title":"__next__()"},{"location":"progress/#torrentfile.progress.HashChecker.iter_paths","text":"Iterate through and compare root file hashes to .torrent file. Parameters: Name Type Description Default hasher class The class user to caluclate root hash. required !!! yields results ( tuple ): The size of the file and result of match. Source code in torrentfile\\progress.py def iter_paths ( self ): \"\"\"Iterate through and compare root file hashes to .torrent file. Args: hasher (class): The class user to caluclate root hash. Yields: results (`tuple`): The size of the file and result of match. \"\"\" for path in tqdm ( self . paths ): info = self . fileinfo [ path ] length = info [ \"length\" ] logging . debug ( \" %s length: %s \" , path , str ( length )) roothash = info [ \"pieces root\" ] logging . debug ( \" %s root hash %s \" , path , str ( roothash )) if not os . path . exists ( path ): if \"layer hashes\" in info and info [ \"layer hashes\" ]: pieces = info [ \"layer hashes\" ] else : pieces = [ roothash ] for i , piece in enumerate ( pieces ): if len ( pieces ) == 1 : size = length elif i < len ( pieces ) - 1 : size = self . piece_length else : size = length - (( len ( pieces ) - 1 ) * self . piece_length ) logging . debug ( \"Yielding: %s %s %s %s \" , str ( bytes ( SHA256 )), str ( piece ), path , str ( size )) yield bytes ( SHA256 ), piece , path , size continue hashed = self . hasher ( path , self . piece_length ) if \"layer hashes\" in info : hash_pieces = split_pieces ( hashed . piece_layer , SHA256 ) info_pieces = info [ \"layer hashes\" ] else : hash_pieces = [ hashed . root ] info_pieces = [ info [ \"pieces root\" ]] diff = len ( info_pieces ) - len ( hash_pieces ) if diff > 0 : hash_pieces += [ bytes ( SHA256 )] * diff num_pieces = len ( hash_pieces ) size = self . piece_length for chunk , piece in zip ( hash_pieces , info_pieces ): if num_pieces == 1 : size = length - (( len ( hash_pieces ) - 1 ) * size ) logging . debug ( \"Yielding: %s , %s , %s , %s \" , str ( chunk ), str ( piece ), str ( path ), str ( size )) yield chunk , piece , path , size num_pieces -= 1","title":"iter_paths()"},{"location":"progress/#torrentfile.progress.split_pieces","text":"Split bytes into 20 piece chuncks for sha1 digest. Parameters: Name Type Description Default pieces `bytes` Initial data. required Returns: Type Description lst (`list`) Pieces broken into groups of 20 bytes. Source code in torrentfile\\progress.py def split_pieces ( pieces , hash_size ): \"\"\"Split bytes into 20 piece chuncks for sha1 digest. Args: pieces (`bytes`): Initial data. Returns: lst (`list`): Pieces broken into groups of 20 bytes. \"\"\" lst = [] start = 0 while start < len ( pieces ): lst . append ( pieces [ start : start + hash_size ]) start += hash_size return lst","title":"split_pieces()"},{"location":"tests/","text":"Test Suit API Torrentfile testing modules. context Context Functions used throughout testing suite. Temp Temp class for holding context variables. rmdirs () classmethod Remove created directories on completion. Source code in tests\\context.py @classmethod def rmdirs ( cls ): \"\"\"Remove created directories on completion.\"\"\" size = len ( cls . dirs ) - 1 while size >= 0 : if rmpath ( cls . dirs [ size ]): del cls . dirs [ size ] size -= 1 build ( * args , ** kwargs ) Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) mkdirs ( * args , ** kwargs ) Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) rmpath ( paths ) Recursively remove path. Source code in tests\\context.py def rmpath ( paths ): \"\"\"Recursively remove path.\"\"\" if isinstance ( paths , ( os . PathLike , str )): paths = [ paths ] no_errors = True for path in [ p for p in paths if os . path . exists ( p )]: try : if os . path . isdir ( path ): shutil . rmtree ( path ) else : os . remove ( path ) except PermissionError : # pragma: no cover no_errors = False continue return no_errors rootwrap ( func ) Wrap to ensure root folder exists. Source code in tests\\context.py def rootwrap ( func ): \"\"\"Wrap to ensure root folder exists.\"\"\" def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) return wrapper structs () Temporary directory structures for testing. Source code in tests\\context.py def structs (): \"\"\"Temporary directory structures for testing.\"\"\" return [[ \"Root1/dir1/file1\" , \"Root1/dir1/file2\" , \"Root1/dir2/file3\" , \"Root1/dir2/file4\" , \"Root1/file5\" , ], [ \"Root2/file1\" , \"Root2/file2\" , \"Root2/file3\" , \"Root2/file4\" , ], [ \"Root3/dir1/dir2/file1\" , \"Root3/dir1/file2\" , \"Root3/dir3/dir4/file3\" , \"Root3/file4\" , ]] teardown () Teardown function for the end of testing. Source code in tests\\context.py @atexit . register def teardown (): \"\"\"Teardown function for the end of testing.\"\"\" rmpath ( Temp . root ) testfile ( * args , ** kwargs ) Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) tstamp () Return timestamp corresponding to now. Source code in tests\\context.py def tstamp (): \"\"\"Return timestamp corresponding to now.\"\"\" return str ( datetime . timestamp ( datetime . now ())) test_cli Test CLI script functionality. test_cli_args_dir ( struct , start , stop ) Test CLI script with only path as arguement. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir ( struct , start , stop ): \"\"\"Test CLI script with only path as arguement.\"\"\" args = [ build ( struct , start , stop )] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_args_dir_v2 ( struct , start , stop ) Test CLI script with minimal arguments v2. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir_v2 ( struct , start , stop ): \"\"\"Test CLI script with minimal arguments v2.\"\"\" tdir = build ( struct , start , stop ) args = [ tdir , \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_args_dir_v3 ( struct , start , stop ) Test CLI script with minimal arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir_v3 ( struct , start , stop ): \"\"\"Test CLI script with minimal arguments v3.\"\"\" tdir = build ( struct , start , stop ) args = [ tdir , \"--meta-version\" , \"3\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_info_output_v1 ( struct , field ) Test CLI output files contents with specific arguments v1. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"field\" , [ \"piece length\" , \"name\" , \"pieces\" , \"comment\" , \"private\" , \"source\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_info_output_v1 ( struct , field ): \"\"\"Test CLI output files contents with specific arguments v1.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta [ \"info\" ] # nosec rmpath ( parser . outfile ) test_cli_info_output_v2_3 ( struct , field , version ) Test CLI output file info dict meta versions 2 & 3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"version\" , [ 2 , 3 ]) @pytest . mark . parametrize ( \"field\" , [ \"piece length\" , \"name\" , \"file tree\" , \"comment\" , \"private\" , \"source\" , \"meta version\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_info_output_v2_3 ( struct , field , version ): \"\"\"Test CLI output file info dict meta versions 2 & 3.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , str ( version ), \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta [ \"info\" ] # nosec rmpath ( parser . outfile ) test_cli_meta_output_v1 ( struct , field ) Test CLI output v1 file meta dict specific arguments. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"field\" , [ \"announce\" , \"created by\" , \"creation date\" , \"info\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_meta_output_v1 ( struct , field ): \"\"\"Test CLI output v1 file meta dict specific arguments.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta # nosec rmpath ( parser . outfile ) test_cli_meta_output_v2_3 ( struct , field , version ) Test CLI output torrentfile meta dict fields v2 and hybrid. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"version\" , [ 2 , 3 ]) @pytest . mark . parametrize ( \"field\" , [ \"announce\" , \"announce list\" , \"piece layers\" , \"created by\" , \"info\" , \"creation date\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_meta_output_v2_3 ( struct , field , version ): \"\"\"Test CLI output torrentfile meta dict fields v2 and hybrid.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , str ( version ), \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta # nosec rmpath ( parser . outfile ) test_cli_no_args () Test CLI script with no arguments. Source code in tests\\test_cli.py def test_cli_no_args (): \"\"\"Test CLI script with no arguments.\"\"\" sys . argv = [ sys . argv [ 0 ]] try : main () except SystemExit : assert True # nosec test_cli_with_all_args_dir ( struct , start , stop ) Test CLI script with other specific arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_dir ( struct , start , stop ): \"\"\"Test CLI script with other specific arguments v3.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"3\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 15 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_with_all_args_v2 ( struct , start , stop ) Test CLI script with all arguments v2. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_v2 ( struct , start , stop ): \"\"\"Test CLI script with all arguments v2.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"2\" , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_with_all_args_v3 ( struct , start , stop ) Test CLI script with all arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_v3 ( struct , start , stop ): \"\"\"Test CLI script with all arguments v3.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"3\" , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_context Testing operation and coverage for context module in tests directory. spaths () Return a list of each file in all structs. Source code in tests\\test_context.py def spaths (): \"\"\"Return a list of each file in all structs.\"\"\" paths = [ j for i in Temp . structs for j in i ] return paths test_build_func ( struct , start , stop ) Test testfile function result size from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 20 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 21 , 27 ))) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_build_func ( struct , start , stop ): \"\"\"Test testfile function result size from context module.\"\"\" root = build ( struct , start , stop ) assert os . path . exists ( root ) # nosec rmpath ( root ) test_mkdirs ( struct ) Test mkdirs function from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"struct\" , spaths ()) def test_mkdirs ( struct ): \"\"\"Test mkdirs function from context module.\"\"\" fd = mkdirs ( struct ) assert os . path . exists ( os . path . dirname ( fd )) # nosec rmpath ( os . path . dirname ( fd )) test_rmpath ( struct ) Test rmpath function from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"struct\" , spaths ()) def test_rmpath ( struct ): \"\"\"Test rmpath function from context module.\"\"\" fd = os . path . dirname ( mkdirs ( struct )) rmpath ( fd ) assert not os . path . exists ( fd ) # nosec rmpath ( fd ) test_seq () Test seq function for random string output. Source code in tests\\test_context.py def test_seq (): \"\"\"Test seq function for random string output.\"\"\" output = Temp . seq assert isinstance ( output , str ) # nosec test_structs () Test temp directory structures. Source code in tests\\test_context.py def test_structs (): \"\"\"Test temp directory structures.\"\"\" assert len ( Temp . structs ) == 3 # nosec test_testfile_func ( size ) Test testfile function result exists from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 27 ))) def test_testfile_func ( size ): \"\"\"Test testfile function result exists from context module.\"\"\" path = testfile ( exp = size ) assert os . path . exists ( path ) # nosec rmpath ( path ) test_testfile_func1 ( size ) Test testfile function result size from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 27 ))) def test_testfile_func1 ( size ): \"\"\"Test testfile function result size from context module.\"\"\" path = testfile ( exp = size ) assert os . path . getsize ( path ) == 2 ** size # nosec rmpath ( path ) test_xz_teardown () Test teardown function from context module. Source code in tests\\test_context.py def test_xz_teardown (): \"\"\"Test teardown function from context module.\"\"\" teardown () assert not os . path . exists ( Temp . root ) # nosec os . mkdir ( Temp . root ) test_main Test main module functionality. test_class_annlist_v2 ( tfile ) Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_list_annlist ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : [ \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_list_annlist_v2 ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : [ \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_single_file_small ( hasher ) Test when single file is slightly larger than piece length. Source code in tests\\test_main.py @pytest . mark . parametrize ( \"hasher\" , [ TorrentFileV2 , TorrentFileHybrid ]) def test_class_single_file_small ( hasher ): \"\"\"Test when single file is slightly larger than piece length.\"\"\" path = testfile ( exp = 15 ) with open ( path , \"ab\" ) as binfile : binfile . write (( Temp . seq * 2 ) . encode ( \"utf-8\" )) args = { \"path\" : path , \"piece_length\" : 15 , \"source\" : \"example1\" } torrent = hasher ( ** args ) tpath , _ = torrent . write () assert os . path . exists ( tpath ) # nosec test_class_tuple_annlist ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker3/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_tuple_annlist_v2 ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_with_annlist ( tfile ) Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_with_annlist ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker3/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_main_annlist_single ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_main_annlist_single_v1 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v1 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"1\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_single_v2 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"2\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_single_v3 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"3\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_v2 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"2\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_v3 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"3\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker4/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_main_announce_list ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_announce_list ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ path , \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ] parser = main () url = \"https://tracker4/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_main_func ( tfile ) Test main script function. Source code in tests\\test_main.py def test_main_func ( tfile ): \"\"\"Test main script function.\"\"\" args , path = tfile opath = os . path . join ( Temp . root , \"test.torrent\" ) sys . argv = args + [ path , \"-o\" , opath ] main () assert os . path . exists ( opath ) # nosec rmpath ( opath ) tfile ( request ) Create fixture for tests. Source code in tests\\test_main.py @pytest . fixture ( scope = \"module\" , params = list ( range ( 14 , 26 ))) def tfile ( request ): \"\"\"Create fixture for tests.\"\"\" args = [ \"torrentfile\" , \"--private\" , \"--announce\" , \"https://tracker1.to/announce\" , \"--source\" , \"TFile\" , ] t_file = testfile ( exp = request . param ) yield args , t_file rmpath ( t_file ) test_progress Testing functions for the progress module. mktorrent ( args , v = None ) Compile bittorrent meta file. Source code in tests\\test_progress.py def mktorrent ( args , v = None ): \"\"\"Compile bittorrent meta file.\"\"\" if v == 3 : torrent = TorrentFileHybrid ( ** args ) elif v == 2 : torrent = TorrentFileV2 ( ** args ) else : torrent = TorrentFile ( ** args ) base = os . path . basename ( args [ 'path' ]) name = f \" { base } . { v } .torrent\" outfile = os . path . join ( Temp . root , name ) torrent . write ( outfile ) return outfile struct1 () Return single struct list. Source code in tests\\test_progress.py @pytest . fixture def struct1 (): \"\"\"Return single struct list.\"\"\" path = build ( Temp . structs [ 1 ]) return path test_checker_class ( struct , version ) Test Checker Class against meta files. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class ( struct , version ): \"\"\"Test Checker Class against meta files.\"\"\" path = build ( struct ) args = { \"path\" : path , \"announce\" : \"https://announce.com/announce\" } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) assert checker . result == \"100\" # nosec rmpath ([ outfile , path ]) test_checker_class_allfiles ( version , struct ) Test Checker class when all files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_allfiles ( version , struct ): \"\"\"Test Checker class when all files are missing from contents.\"\"\" path = Path ( build ( struct )) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) def traverse ( path ): \"\"\"Traverse internal subdirectories.\"\"\" if path . is_file (): rmpath ( path ) elif path . is_dir (): for item in path . iterdir (): traverse ( item ) traverse ( path ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec rmpath ( outfile ) Temp . rmdirs () test_checker_class_allpaths ( version , struct ) Test Checker class when all files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_class_allpaths ( version , struct ): \"\"\"Test Checker class when all files are missing from contents.\"\"\" path = Path ( build ( struct )) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) for item in path . iterdir (): rmpath ( item ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec test_checker_class_half_file ( version ) Test Checker class with half size single file. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_half_file ( version ): \"\"\"Test Checker class with half size single file.\"\"\" path = testfile ( exp = 25 ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 15 } outfile = mktorrent ( args , v = version ) half = int (( 2 ** 25 ) / 2 ) barr = bytearray ( half ) with open ( path , \"rb\" ) as content : content . readinto ( barr ) with open ( path , \"wb\" ) as content : content . write ( barr ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec test_checker_class_missing ( version , struct1 ) Test Checker class when files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_missing ( version , struct1 ): \"\"\"Test Checker class when files are missing from contents.\"\"\" path = struct1 args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) rmpath ( os . path . join ( path , \"file1\" )) rmpath ( os . path . join ( path , \"file3\" )) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec test_checker_cli_args ( struct , version ) Test exclusive Checker Mode CLI. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_cli_args ( struct , version ): \"\"\"Test exclusive Checker Mode CLI.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) sys . argv [ 1 :] = [ \"--re-check\" , outfile , t3dir ] output = main () assert output == \"100\" # nosec rmpath ( outfile ) Temp . rmdirs () test_checker_first_piece ( struct , version ) Test Checker Class when first piece is slightly alterred. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_first_piece ( struct , version ): \"\"\"Test Checker Class when first piece is slightly alterred.\"\"\" path = build ( struct ) args = { \"path\" : path , \"announce\" : \"https://announce.com/announce\" } outfile = mktorrent ( args , v = version ) def change ( path ): \"\"\"Change some bytes in file.\"\"\" if os . path . isfile ( path ): data = open ( path , \"rb\" ) . read () new = b 'some_different_bytes_to_swap' data = new + data [ len ( new ):] open ( path , \"wb\" ) . write ( data ) elif os . path . isdir ( path ): for item in os . listdir ( path ): change ( os . path . join ( path , item )) change ( path ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) != 100 # nosec rmpath ([ outfile , path ]) test_checker_no_content ( struct , version ) Test Checker class with directory that points to nothing. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_no_content ( struct , version ): \"\"\"Test Checker class with directory that points to nothing.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) CheckerClass . register_callback ( lambda * x : print ( x )) checker = CheckerClass ( outfile , t3dir ) assert checker . result == \"100\" # nosec rmpath ( outfile ) test_checker_no_meta_file () Test Checker when incorrect metafile is provided. Source code in tests\\test_progress.py def test_checker_no_meta_file (): \"\"\"Test Checker when incorrect metafile is provided.\"\"\" try : CheckerClass ( \"peaches\" , \"$\" ) except FileNotFoundError : assert True # nosec test_checker_no_root_dir ( struct ) Test Checker when incorrect root directory is provided. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_no_root_dir ( struct ): \"\"\"Test Checker when incorrect root directory is provided.\"\"\" tdir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : tdir , \"private\" : 1 } outfile = mktorrent ( args , v = 1 ) try : CheckerClass ( outfile , \"peaches\" ) except FileNotFoundError : assert True # nosec rmpath ( outfile ) test_checker_parent_dir ( struct , version ) Test providing the parent directory for torrent checking feature. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_parent_dir ( struct , version ): \"\"\"Test providing the parent directory for torrent checking feature.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , os . path . dirname ( t3dir )) assert checker . result == \"100\" # nosec rmpath ( outfile ) Temp . rmdirs () test_checker_result_property ( version ) Test Checker class with half size single file. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_result_property ( version ): \"\"\"Test Checker class with half size single file.\"\"\" path = testfile ( exp = 20 ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 14 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) result = checker . result assert checker . result == result # nosec rmpath ( outfile ) test_checker_with_file ( version , size ) Test checker with single file torrent. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 26 ))) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_with_file ( version , size ): \"\"\"Test checker with single file torrent.\"\"\" tfile = testfile ( exp = size ) args = { \"announce\" : \"announce\" , \"path\" : tfile , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , tfile ) assert checker . result == \"100\" # nosec rmpath ( outfile ) test_checker_wrong_root_dir ( struct ) Test Checker when incorrect root directory is provided. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_wrong_root_dir ( struct ): \"\"\"Test Checker when incorrect root directory is provided.\"\"\" tdir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : tdir , \"private\" : 1 } path = Path ( tdir ) newpath = path . parent / ( path . name + \"FAKE\" ) os . mkdir ( newpath ) newpath . touch ( newpath / \"file1\" ) outfile = mktorrent ( args , v = 1 ) try : CheckerClass ( outfile , str ( newpath )) except FileNotFoundError : assert True # nosec rmpath ( outfile ) rmpath ( newpath ) test_metafile_checker ( struct , version ) Test metadata checker class. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_metafile_checker ( struct , version ): \"\"\"Test metadata checker class.\"\"\" path = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) assert checker . result == \"100\" # nosec rmpath ([ outfile , path ]) test_partial_metafiles ( struct , version ) Test Checker with data that is expected to be incomplete. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_partial_metafiles ( struct , version ): \"\"\"Test Checker with data that is expected to be incomplete.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) def shortenfile ( path ): \"\"\"Shorten a few files for testing purposes.\"\"\" with open ( path , \"rb\" ) as bfile : data = bfile . read () with open ( path , \"wb\" ) as bfile : bfile . write ( data [: - 2 ** 12 ]) for item in os . listdir ( t3dir ): full = os . path . join ( t3dir , item ) if os . path . isfile ( full ): shortenfile ( full ) testdir = os . path . dirname ( t3dir ) checker = CheckerClass ( outfile , testdir ) assert checker . result != \"100\" # nosec rmpath ( outfile ) test_torrentfile Testing functions for torrentfile module. maketorrent ( args , v = None ) Torrent making factory. Source code in tests\\test_torrentfile.py def maketorrent ( args , v = None ): \"\"\"Torrent making factory.\"\"\" if v not in [ 2 , 3 ]: torrent = TorrentFile ( ** args ) elif v == 2 : torrent = TorrentFileV2 ( ** args ) elif v == 3 : torrent = TorrentFileHybrid ( ** args ) torrent . assemble () return torrent . write () metav1d ( tdir ) Return generated metadata v1 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav1d ( tdir ): \"\"\"Return generated metadata v1 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args ) yield outfile , meta rmpath ([ tdir , outfile ]) metav2d ( tdir ) Return generated metadata v2 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav2d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , v = 2 ) yield outfile , meta rmpath ([ tdir , outfile ]) metav3d ( tdir ) Return generated metadata v2 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav3d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , v = 3 ) yield outfile , meta rmpath ([ tdir , outfile ]) smallfile () Generate Sized file a tiny bit larger than BLOCK_SIZE. Source code in tests\\test_torrentfile.py @pytest . fixture def smallfile (): \"\"\"Generate Sized file a tiny bit larger than BLOCK_SIZE.\"\"\" path = testfile ( exp = 14 ) with open ( path , \"ab\" ) as fd : fd . write ( b \"000000000000000\" ) yield path rmpath ( path ) tdir ( request ) Return temp directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir ( request ): \"\"\"Return temp directory.\"\"\" return build ( request . param ) tdir1 ( request ) Return temporary directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir1 ( request ): \"\"\"Return temporary directory.\"\"\" folder = build ( request . param ) args = { \"path\" : folder , \"announce\" : \"https://tracker.com/announce\" } yield folder , args rmpath ( folder ) test_exception_path_error () Test MissingPathError exception. Source code in tests\\test_torrentfile.py def test_exception_path_error (): \"\"\"Test MissingPathError exception.\"\"\" try : raise utils . MissingPathError ( \"this is a message\" ) except utils . MissingPathError : assert True # nosec test_hybrid_0_length () Test Hybrid with zero length file. Source code in tests\\test_torrentfile.py def test_hybrid_0_length (): \"\"\"Test Hybrid with zero length file.\"\"\" path = Path ( Temp . root ) / \"empty\" path . touch () args = { \"path\" : str ( path ), \"announce\" : \"announce\" , } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"announce\" ] == \"announce\" # nosec torrent . write () torpath = path . with_suffix ( \".torrent\" ) assert os . path . exists ( torpath ) # nosec rmpath ([ path , torpath ]) test_hybrid_outfile ( tdir1 ) Test Hybrid class with output as argument. Source code in tests\\test_torrentfile.py def test_hybrid_outfile ( tdir1 ): \"\"\"Test Hybrid class with output as argument.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFileHybrid ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_hybrid_sized_file ( smallfile ) Test pad_remaining function in hybrid FileHash class. Source code in tests\\test_torrentfile.py def test_hybrid_sized_file ( smallfile ): \"\"\"Test pad_remaining function in hybrid FileHash class.\"\"\" args = { \"path\" : smallfile , \"announce\" : \"announce\" , \"piece_length\" : 15 } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"announce\" ] == args [ \"announce\" ] # nosec assert torrent . meta [ \"info\" ][ \"piece length\" ] == 2 ** 15 # nosec test_hybrid_under_block_sized () Test pad_remaining function in hybrid FileHash class. Source code in tests\\test_torrentfile.py def test_hybrid_under_block_sized (): \"\"\"Test pad_remaining function in hybrid FileHash class.\"\"\" smallest = os . path . join ( Temp . root , \"smallest\" ) with open ( smallest , \"wb\" ) as fd : letters = b \"abcdefghijklmnopqrstuvwxyzABZDEFGHIJKLMNOPQRSTUVWXYZ\" size = len ( letters ) while size < 16000 : fd . write ( letters ) size += len ( letters ) args = { \"path\" : smallest , \"piece_length\" : 2 ** 14 } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"info\" ][ \"piece length\" ] == 2 ** 14 # nosec rmpath ( smallest ) test_hybrid_with_outfile ( tdir1 ) Test Hybrid class with output in kwargs. Source code in tests\\test_torrentfile.py def test_hybrid_with_outfile ( tdir1 ): \"\"\"Test Hybrid class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFileHybrid ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_meta_no_args_v1 () Test construct TorrentFile with no arguments. Source code in tests\\test_torrentfile.py def test_meta_no_args_v1 (): \"\"\"Test construct TorrentFile with no arguments.\"\"\" try : assert TorrentFile ( announce = \"url\" ) # nosec except utils . MissingPathError : assert True # nosec test_meta_no_args_v2 () Test construct TorrentFileV2 with no arguments. Source code in tests\\test_torrentfile.py def test_meta_no_args_v2 (): \"\"\"Test construct TorrentFileV2 with no arguments.\"\"\" try : assert TorrentFileV2 ( private = True ) # nosec except utils . MissingPathError : assert True # nosec test_metafile_assemble ( tdir1 ) Test MetaFile assemble file Exception. Source code in tests\\test_torrentfile.py def test_metafile_assemble ( tdir1 ): \"\"\"Test MetaFile assemble file Exception.\"\"\" fd , args = tdir1 meta = MetaFile ( ** args ) try : meta . assemble () except NotImplementedError : assert True # nosec rmpath ( fd ) test_torrentfile_dir ( tdir1 ) Test temporary directory. Source code in tests\\test_torrentfile.py def test_torrentfile_dir ( tdir1 ): \"\"\"Test temporary directory.\"\"\" _ , args = tdir1 torrent = TorrentFile ( ** args ) assert torrent . meta is not None # nosec test_torrentfile_dir_comment ( tdir1 ) Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_comment ( tdir1 ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir1 args [ \"private\" ] = True args [ \"comment\" ] = \"This is a comment\" torrent = TorrentFile ( ** args ) meta = torrent . meta assert \"private\" in meta [ \"info\" ] and \"comment\" in meta [ \"info\" ] # nosec test_torrentfile_dir_private ( tdir1 ) Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_private ( tdir1 ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir1 args [ \"private\" ] = True args [ \"piece_length\" ] = 1048576 torrent = TorrentFile ( ** args ) meta = torrent . meta assert \"private\" in meta [ \"info\" ] # nosec test_torrentfile_with_outfile ( tdir1 ) Test TorrentFile class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfile_with_outfile ( tdir1 ): \"\"\"Test TorrentFile class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFile ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_torrentfile_write_outfile ( tdir1 ) Test TorrentFile class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfile_write_outfile ( tdir1 ): \"\"\"Test TorrentFile class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFile ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_torrentfilev2_outfile ( tdir1 ) Test TorrentFile2 class with output as argument. Source code in tests\\test_torrentfile.py def test_torrentfilev2_outfile ( tdir1 ): \"\"\"Test TorrentFile2 class with output as argument.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFileV2 ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_torrentfilev2_with_outfile ( tdir1 ) Test TorrentFileV2 class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfilev2_with_outfile ( tdir1 ): \"\"\"Test TorrentFileV2 class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFileV2 ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_v1_info_keys_dir ( metav1d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"name\" , \"private\" , \"source\" , \"comment\" , \"pieces\" ]) def test_v1_info_keys_dir ( metav1d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v1_meta_keys ( metav1d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"announce\" , \"info\" , \"creation date\" , \"created by\" ]) def test_v1_meta_keys ( metav1d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d assert key in meta # nosec assert os . path . exists ( outfile ) # nosec test_v2_0_length () Test TorrentFileV2 with zero length file. Source code in tests\\test_torrentfile.py def test_v2_0_length (): \"\"\"Test TorrentFileV2 with zero length file.\"\"\" path = Path ( Temp . root ) / \"empty\" path . touch () args = { \"path\" : str ( path ), \"announce\" : \"announce\" , } torrent = TorrentFileV2 ( ** args ) torrent . write () torpath = path . with_suffix ( \".torrent\" ) assert os . path . exists ( torpath ) # nosec rmpath ([ path , torpath ]) test_v2_info_keys_dir ( metav2d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" ]) def test_v2_info_keys_dir ( metav2d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v2_meta_keys ( metav2d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" , \"created by\" ]) def test_v2_meta_keys ( metav2d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d assert key in meta # nosec assert os . path . exists ( outfile ) # nosec test_v3_info_keys_dir ( metav3d , field ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'field' , [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" ]) def test_v3_info_keys_dir ( metav3d , field ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert field in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v3_info_keys_pieces ( metav3d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"name\" , \"private\" , \"source\" , \"comment\" , \"pieces\" ]) def test_v3_info_keys_pieces ( metav3d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v3_meta_keys ( metav3d , field ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'field' , [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" , \"created by\" ]) def test_v3_meta_keys ( metav3d , field ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert field in meta # nosec assert os . path . exists ( outfile ) # nosec test_utils Test functions for utils module. tdir ( request ) Return temporary directory. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir ( request ): \"\"\"Return temporary directory.\"\"\" drct = build ( request . param ) yield drct rmpath ( drct ) test_filelist_total_dir_files ( tdir ) Test Utility function filelist_total number of files. Source code in tests\\test_utils.py def test_filelist_total_dir_files ( tdir ): \"\"\"Test Utility function filelist_total number of files.\"\"\" _ , filelist = utils . filelist_total ( tdir ) assert len ( filelist ) > 0 # nosec test_filelist_total_len_tfile ( tfile ) Test Utility function filelist_total length for single. Source code in tests\\test_utils.py def test_filelist_total_len_tfile ( tfile ): \"\"\"Test Utility function filelist_total length for single.\"\"\" _ , filelist = utils . filelist_total ( tfile ) assert len ( filelist ) == 1 # nosec test_filelist_total_size_tfile ( tfile ) Test Utility function filelist_total total bytes. Source code in tests\\test_utils.py def test_filelist_total_size_tfile ( tfile ): \"\"\"Test Utility function filelist_total total bytes.\"\"\" size , _ = utils . filelist_total ( tfile ) assert os . path . getsize ( tfile ) == size # nosec test_filelist_total_tdir_sum ( tdir ) Test Utility function filelist_total sum total all files. Source code in tests\\test_utils.py def test_filelist_total_tdir_sum ( tdir ): \"\"\"Test Utility function filelist_total sum total all files.\"\"\" size , filelist = utils . filelist_total ( tdir ) assert sum ([ os . path . getsize ( fd ) for fd in filelist ]) == size # nosec test_filelist_total_tfile ( tfile ) Test Utility function filelist_total on single file. Source code in tests\\test_utils.py def test_filelist_total_tfile ( tfile ): \"\"\"Test Utility function filelist_total on single file.\"\"\" _ , filelist = utils . filelist_total ( tfile ) assert filelist [ 0 ] == tfile # nosec test_get_filelist_tdir ( tdir ) Test get_file_list function. Source code in tests\\test_utils.py def test_get_filelist_tdir ( tdir ): \"\"\"Test get_file_list function.\"\"\" result = utils . get_file_list ( tdir ) assert len ( result ) >= 1 # nosec test_get_filelist_tfile ( tfile ) Test get_file_list function. Source code in tests\\test_utils.py def test_get_filelist_tfile ( tfile ): \"\"\"Test get_file_list function.\"\"\" result = utils . get_file_list ( tfile ) assert len ( result ) == 1 # nosec test_get_piece_len ( tfile ) Test get_piece_length function does not exceed max. Source code in tests\\test_utils.py def test_get_piece_len ( tfile ): \"\"\"Test get_piece_length function does not exceed max.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result <= MAX_BLOCK # nosec test_get_piece_len_large () Test get_piece_length function does not exceed maximum. Source code in tests\\test_utils.py def test_get_piece_len_large (): \"\"\"Test get_piece_length function does not exceed maximum.\"\"\" size = 2 ** 31 result = utils . get_piece_length ( size ) assert result <= MAX_BLOCK # nosec test_get_piece_len_power_2 ( tfile ) Test get_piece_length function is a power of 2. Source code in tests\\test_utils.py def test_get_piece_len_power_2 ( tfile ): \"\"\"Test get_piece_length function is a power of 2.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result % MIN_BLOCK == 0 # nosec test_get_piece_length_min ( tfile ) Test get_piece_length function does not fall under minimum. Source code in tests\\test_utils.py def test_get_piece_length_min ( tfile ): \"\"\"Test get_piece_length function does not fall under minimum.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result >= MIN_BLOCK # nosec test_normalize_plength_fails ( piece_length ) Test to ensure incorrect piece length values fail. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 10 , 1 , 4425631 , 35 , \"1111\" , \"abc\" ]) def test_normalize_plength_fails ( piece_length ): \"\"\"Test to ensure incorrect piece length values fail.\"\"\" try : utils . normalize_piece_length ( piece_length ) except utils . PieceLengthValueError : assert True # nosec test_normalize_plength_type ( piece_length ) Test normalize piece length function output type. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 14 , 20 , 2 ** 15 , 2 ** 19 , \"22\" , \"21\" ]) def test_normalize_plength_type ( piece_length ): \"\"\"Test normalize piece length function output type.\"\"\" value = utils . normalize_piece_length ( piece_length ) assert isinstance ( value , int ) # nosec test_normalize_plength_value ( piece_length ) Test normalize piece length output perfect power of 2. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 14 , 20 , 2 ** 15 , 2 ** 19 , \"22\" , \"21\" ]) def test_normalize_plength_value ( piece_length ): \"\"\"Test normalize piece length output perfect power of 2.\"\"\" value = utils . normalize_piece_length ( piece_length ) log = math . log2 ( value ) assert int ( log ) == log # nosec test_path_piece_length_max ( tdir ) Test path_piece_length for dir return piece_length < Maximum. Source code in tests\\test_utils.py def test_path_piece_length_max ( tdir ): \"\"\"Test path_piece_length for dir return piece_length < Maximum.\"\"\" result = utils . path_piece_length ( tdir ) assert result <= MAX_BLOCK # nosec test_path_piece_length_min ( tdir ) Test path_piece_length for dir return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_min ( tdir ): \"\"\"Test path_piece_length for dir return piece_length is power of 2.\"\"\" result = utils . path_piece_length ( tdir ) assert result >= MIN_BLOCK # nosec test_path_piece_length_pow2 ( tdir ) Test path_piece_length for file return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_pow2 ( tdir ): \"\"\"Test path_piece_length for file return piece_length is power of 2.\"\"\" result = utils . path_piece_length ( tdir ) assert result % MIN_BLOCK == 0 # nosec test_path_size_file ( tfile ) Test path_size function for tempfile. Source code in tests\\test_utils.py def test_path_size_file ( tfile ): \"\"\"Test path_size function for tempfile.\"\"\" size = os . path . getsize ( tfile ) val = utils . path_size ( tfile ) assert size == val # nosec test_path_size_file_gt0 ( tfile ) Test path_size function for tempfile is greater than zero. Source code in tests\\test_utils.py def test_path_size_file_gt0 ( tfile ): \"\"\"Test path_size function for tempfile is greater than zero.\"\"\" val = utils . path_size ( tfile ) assert val > 0 # nosec test_path_stat_base2_plen ( tdir ) Test path_stat function return piece length is power of 2. Source code in tests\\test_utils.py def test_path_stat_base2_plen ( tdir ): \"\"\"Test path_stat function return piece length is power of 2.\"\"\" _ , _ , piece_length = utils . path_stat ( tdir ) assert piece_length % MIN_BLOCK == 0 # nosec test_path_stat_eq_filelist ( tdir ) Test path_stat function return filelist. Source code in tests\\test_utils.py def test_path_stat_eq_filelist ( tdir ): \"\"\"Test path_stat function return filelist.\"\"\" filelist , _ , _ = utils . path_stat ( tdir ) assert len ( filelist ) >= 1 # nosec test_path_stat_eq_size ( tdir ) Test path_stat function return identically correct size. Source code in tests\\test_utils.py def test_path_stat_eq_size ( tdir ): \"\"\"Test path_stat function return identically correct size.\"\"\" filelist , size , _ = utils . path_stat ( tdir ) assert size == sum ([ os . path . getsize ( x ) for x in filelist ]) # nosec test_path_stat_gt0_filelist ( tdir ) Test path_stat function for tempdir1 sorted > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_filelist ( tdir ): \"\"\"Test path_stat function for tempdir1 sorted > 0.\"\"\" filelist , _ , _ = utils . path_stat ( tdir ) assert len ( filelist ) > 0 # nosec test_path_stat_gt0_plen ( tdir ) Test path_stat function return piece length > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_plen ( tdir ): \"\"\"Test path_stat function return piece length > 0.\"\"\" _ , _ , piece_length = utils . path_stat ( tdir ) assert piece_length >= MIN_BLOCK # nosec test_path_stat_gt0_size ( tdir ) Test path_stat function return size > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_size ( tdir ): \"\"\"Test path_stat function return size > 0.\"\"\" _ , size , _ = utils . path_stat ( tdir ) assert size > 0 # nosec test_path_stat_gtsize_plen ( tdir ) Test path_stat function return size > piece length. Source code in tests\\test_utils.py def test_path_stat_gtsize_plen ( tdir ): \"\"\"Test path_stat function return size > piece length.\"\"\" _ , size , piece_length = utils . path_stat ( tdir ) assert size > piece_length # nosec tfile () Return temporary file. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temporary file.\"\"\" tle = testfile () yield tle rmpath ( tle ) Context Functions used throughout testing suite. Temp Temp class for holding context variables. rmdirs () classmethod Remove created directories on completion. Source code in tests\\context.py @classmethod def rmdirs ( cls ): \"\"\"Remove created directories on completion.\"\"\" size = len ( cls . dirs ) - 1 while size >= 0 : if rmpath ( cls . dirs [ size ]): del cls . dirs [ size ] size -= 1 build ( * args , ** kwargs ) Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) mkdirs ( * args , ** kwargs ) Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) rmpath ( paths ) Recursively remove path. Source code in tests\\context.py def rmpath ( paths ): \"\"\"Recursively remove path.\"\"\" if isinstance ( paths , ( os . PathLike , str )): paths = [ paths ] no_errors = True for path in [ p for p in paths if os . path . exists ( p )]: try : if os . path . isdir ( path ): shutil . rmtree ( path ) else : os . remove ( path ) except PermissionError : # pragma: no cover no_errors = False continue return no_errors rootwrap ( func ) Wrap to ensure root folder exists. Source code in tests\\context.py def rootwrap ( func ): \"\"\"Wrap to ensure root folder exists.\"\"\" def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) return wrapper structs () Temporary directory structures for testing. Source code in tests\\context.py def structs (): \"\"\"Temporary directory structures for testing.\"\"\" return [[ \"Root1/dir1/file1\" , \"Root1/dir1/file2\" , \"Root1/dir2/file3\" , \"Root1/dir2/file4\" , \"Root1/file5\" , ], [ \"Root2/file1\" , \"Root2/file2\" , \"Root2/file3\" , \"Root2/file4\" , ], [ \"Root3/dir1/dir2/file1\" , \"Root3/dir1/file2\" , \"Root3/dir3/dir4/file3\" , \"Root3/file4\" , ]] teardown () Teardown function for the end of testing. Source code in tests\\context.py @atexit . register def teardown (): \"\"\"Teardown function for the end of testing.\"\"\" rmpath ( Temp . root ) testfile ( * args , ** kwargs ) Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) tstamp () Return timestamp corresponding to now. Source code in tests\\context.py def tstamp (): \"\"\"Return timestamp corresponding to now.\"\"\" return str ( datetime . timestamp ( datetime . now ())) Test CLI script functionality. test_cli_args_dir ( struct , start , stop ) Test CLI script with only path as arguement. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir ( struct , start , stop ): \"\"\"Test CLI script with only path as arguement.\"\"\" args = [ build ( struct , start , stop )] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_args_dir_v2 ( struct , start , stop ) Test CLI script with minimal arguments v2. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir_v2 ( struct , start , stop ): \"\"\"Test CLI script with minimal arguments v2.\"\"\" tdir = build ( struct , start , stop ) args = [ tdir , \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_args_dir_v3 ( struct , start , stop ) Test CLI script with minimal arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir_v3 ( struct , start , stop ): \"\"\"Test CLI script with minimal arguments v3.\"\"\" tdir = build ( struct , start , stop ) args = [ tdir , \"--meta-version\" , \"3\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_info_output_v1 ( struct , field ) Test CLI output files contents with specific arguments v1. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"field\" , [ \"piece length\" , \"name\" , \"pieces\" , \"comment\" , \"private\" , \"source\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_info_output_v1 ( struct , field ): \"\"\"Test CLI output files contents with specific arguments v1.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta [ \"info\" ] # nosec rmpath ( parser . outfile ) test_cli_info_output_v2_3 ( struct , field , version ) Test CLI output file info dict meta versions 2 & 3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"version\" , [ 2 , 3 ]) @pytest . mark . parametrize ( \"field\" , [ \"piece length\" , \"name\" , \"file tree\" , \"comment\" , \"private\" , \"source\" , \"meta version\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_info_output_v2_3 ( struct , field , version ): \"\"\"Test CLI output file info dict meta versions 2 & 3.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , str ( version ), \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta [ \"info\" ] # nosec rmpath ( parser . outfile ) test_cli_meta_output_v1 ( struct , field ) Test CLI output v1 file meta dict specific arguments. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"field\" , [ \"announce\" , \"created by\" , \"creation date\" , \"info\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_meta_output_v1 ( struct , field ): \"\"\"Test CLI output v1 file meta dict specific arguments.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta # nosec rmpath ( parser . outfile ) test_cli_meta_output_v2_3 ( struct , field , version ) Test CLI output torrentfile meta dict fields v2 and hybrid. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"version\" , [ 2 , 3 ]) @pytest . mark . parametrize ( \"field\" , [ \"announce\" , \"announce list\" , \"piece layers\" , \"created by\" , \"info\" , \"creation date\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_meta_output_v2_3 ( struct , field , version ): \"\"\"Test CLI output torrentfile meta dict fields v2 and hybrid.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , str ( version ), \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta # nosec rmpath ( parser . outfile ) test_cli_no_args () Test CLI script with no arguments. Source code in tests\\test_cli.py def test_cli_no_args (): \"\"\"Test CLI script with no arguments.\"\"\" sys . argv = [ sys . argv [ 0 ]] try : main () except SystemExit : assert True # nosec test_cli_with_all_args_dir ( struct , start , stop ) Test CLI script with other specific arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_dir ( struct , start , stop ): \"\"\"Test CLI script with other specific arguments v3.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"3\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 15 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_with_all_args_v2 ( struct , start , stop ) Test CLI script with all arguments v2. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_v2 ( struct , start , stop ): \"\"\"Test CLI script with all arguments v2.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"2\" , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) test_cli_with_all_args_v3 ( struct , start , stop ) Test CLI script with all arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_v3 ( struct , start , stop ): \"\"\"Test CLI script with all arguments v3.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"3\" , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) Test functions for utils module. tdir ( request ) Return temporary directory. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir ( request ): \"\"\"Return temporary directory.\"\"\" drct = build ( request . param ) yield drct rmpath ( drct ) test_filelist_total_dir_files ( tdir ) Test Utility function filelist_total number of files. Source code in tests\\test_utils.py def test_filelist_total_dir_files ( tdir ): \"\"\"Test Utility function filelist_total number of files.\"\"\" _ , filelist = utils . filelist_total ( tdir ) assert len ( filelist ) > 0 # nosec test_filelist_total_len_tfile ( tfile ) Test Utility function filelist_total length for single. Source code in tests\\test_utils.py def test_filelist_total_len_tfile ( tfile ): \"\"\"Test Utility function filelist_total length for single.\"\"\" _ , filelist = utils . filelist_total ( tfile ) assert len ( filelist ) == 1 # nosec test_filelist_total_size_tfile ( tfile ) Test Utility function filelist_total total bytes. Source code in tests\\test_utils.py def test_filelist_total_size_tfile ( tfile ): \"\"\"Test Utility function filelist_total total bytes.\"\"\" size , _ = utils . filelist_total ( tfile ) assert os . path . getsize ( tfile ) == size # nosec test_filelist_total_tdir_sum ( tdir ) Test Utility function filelist_total sum total all files. Source code in tests\\test_utils.py def test_filelist_total_tdir_sum ( tdir ): \"\"\"Test Utility function filelist_total sum total all files.\"\"\" size , filelist = utils . filelist_total ( tdir ) assert sum ([ os . path . getsize ( fd ) for fd in filelist ]) == size # nosec test_filelist_total_tfile ( tfile ) Test Utility function filelist_total on single file. Source code in tests\\test_utils.py def test_filelist_total_tfile ( tfile ): \"\"\"Test Utility function filelist_total on single file.\"\"\" _ , filelist = utils . filelist_total ( tfile ) assert filelist [ 0 ] == tfile # nosec test_get_filelist_tdir ( tdir ) Test get_file_list function. Source code in tests\\test_utils.py def test_get_filelist_tdir ( tdir ): \"\"\"Test get_file_list function.\"\"\" result = utils . get_file_list ( tdir ) assert len ( result ) >= 1 # nosec test_get_filelist_tfile ( tfile ) Test get_file_list function. Source code in tests\\test_utils.py def test_get_filelist_tfile ( tfile ): \"\"\"Test get_file_list function.\"\"\" result = utils . get_file_list ( tfile ) assert len ( result ) == 1 # nosec test_get_piece_len ( tfile ) Test get_piece_length function does not exceed max. Source code in tests\\test_utils.py def test_get_piece_len ( tfile ): \"\"\"Test get_piece_length function does not exceed max.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result <= MAX_BLOCK # nosec test_get_piece_len_large () Test get_piece_length function does not exceed maximum. Source code in tests\\test_utils.py def test_get_piece_len_large (): \"\"\"Test get_piece_length function does not exceed maximum.\"\"\" size = 2 ** 31 result = utils . get_piece_length ( size ) assert result <= MAX_BLOCK # nosec test_get_piece_len_power_2 ( tfile ) Test get_piece_length function is a power of 2. Source code in tests\\test_utils.py def test_get_piece_len_power_2 ( tfile ): \"\"\"Test get_piece_length function is a power of 2.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result % MIN_BLOCK == 0 # nosec test_get_piece_length_min ( tfile ) Test get_piece_length function does not fall under minimum. Source code in tests\\test_utils.py def test_get_piece_length_min ( tfile ): \"\"\"Test get_piece_length function does not fall under minimum.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result >= MIN_BLOCK # nosec test_normalize_plength_fails ( piece_length ) Test to ensure incorrect piece length values fail. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 10 , 1 , 4425631 , 35 , \"1111\" , \"abc\" ]) def test_normalize_plength_fails ( piece_length ): \"\"\"Test to ensure incorrect piece length values fail.\"\"\" try : utils . normalize_piece_length ( piece_length ) except utils . PieceLengthValueError : assert True # nosec test_normalize_plength_type ( piece_length ) Test normalize piece length function output type. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 14 , 20 , 2 ** 15 , 2 ** 19 , \"22\" , \"21\" ]) def test_normalize_plength_type ( piece_length ): \"\"\"Test normalize piece length function output type.\"\"\" value = utils . normalize_piece_length ( piece_length ) assert isinstance ( value , int ) # nosec test_normalize_plength_value ( piece_length ) Test normalize piece length output perfect power of 2. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 14 , 20 , 2 ** 15 , 2 ** 19 , \"22\" , \"21\" ]) def test_normalize_plength_value ( piece_length ): \"\"\"Test normalize piece length output perfect power of 2.\"\"\" value = utils . normalize_piece_length ( piece_length ) log = math . log2 ( value ) assert int ( log ) == log # nosec test_path_piece_length_max ( tdir ) Test path_piece_length for dir return piece_length < Maximum. Source code in tests\\test_utils.py def test_path_piece_length_max ( tdir ): \"\"\"Test path_piece_length for dir return piece_length < Maximum.\"\"\" result = utils . path_piece_length ( tdir ) assert result <= MAX_BLOCK # nosec test_path_piece_length_min ( tdir ) Test path_piece_length for dir return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_min ( tdir ): \"\"\"Test path_piece_length for dir return piece_length is power of 2.\"\"\" result = utils . path_piece_length ( tdir ) assert result >= MIN_BLOCK # nosec test_path_piece_length_pow2 ( tdir ) Test path_piece_length for file return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_pow2 ( tdir ): \"\"\"Test path_piece_length for file return piece_length is power of 2.\"\"\" result = utils . path_piece_length ( tdir ) assert result % MIN_BLOCK == 0 # nosec test_path_size_file ( tfile ) Test path_size function for tempfile. Source code in tests\\test_utils.py def test_path_size_file ( tfile ): \"\"\"Test path_size function for tempfile.\"\"\" size = os . path . getsize ( tfile ) val = utils . path_size ( tfile ) assert size == val # nosec test_path_size_file_gt0 ( tfile ) Test path_size function for tempfile is greater than zero. Source code in tests\\test_utils.py def test_path_size_file_gt0 ( tfile ): \"\"\"Test path_size function for tempfile is greater than zero.\"\"\" val = utils . path_size ( tfile ) assert val > 0 # nosec test_path_stat_base2_plen ( tdir ) Test path_stat function return piece length is power of 2. Source code in tests\\test_utils.py def test_path_stat_base2_plen ( tdir ): \"\"\"Test path_stat function return piece length is power of 2.\"\"\" _ , _ , piece_length = utils . path_stat ( tdir ) assert piece_length % MIN_BLOCK == 0 # nosec test_path_stat_eq_filelist ( tdir ) Test path_stat function return filelist. Source code in tests\\test_utils.py def test_path_stat_eq_filelist ( tdir ): \"\"\"Test path_stat function return filelist.\"\"\" filelist , _ , _ = utils . path_stat ( tdir ) assert len ( filelist ) >= 1 # nosec test_path_stat_eq_size ( tdir ) Test path_stat function return identically correct size. Source code in tests\\test_utils.py def test_path_stat_eq_size ( tdir ): \"\"\"Test path_stat function return identically correct size.\"\"\" filelist , size , _ = utils . path_stat ( tdir ) assert size == sum ([ os . path . getsize ( x ) for x in filelist ]) # nosec test_path_stat_gt0_filelist ( tdir ) Test path_stat function for tempdir1 sorted > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_filelist ( tdir ): \"\"\"Test path_stat function for tempdir1 sorted > 0.\"\"\" filelist , _ , _ = utils . path_stat ( tdir ) assert len ( filelist ) > 0 # nosec test_path_stat_gt0_plen ( tdir ) Test path_stat function return piece length > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_plen ( tdir ): \"\"\"Test path_stat function return piece length > 0.\"\"\" _ , _ , piece_length = utils . path_stat ( tdir ) assert piece_length >= MIN_BLOCK # nosec test_path_stat_gt0_size ( tdir ) Test path_stat function return size > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_size ( tdir ): \"\"\"Test path_stat function return size > 0.\"\"\" _ , size , _ = utils . path_stat ( tdir ) assert size > 0 # nosec test_path_stat_gtsize_plen ( tdir ) Test path_stat function return size > piece length. Source code in tests\\test_utils.py def test_path_stat_gtsize_plen ( tdir ): \"\"\"Test path_stat function return size > piece length.\"\"\" _ , size , piece_length = utils . path_stat ( tdir ) assert size > piece_length # nosec tfile () Return temporary file. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temporary file.\"\"\" tle = testfile () yield tle rmpath ( tle ) Testing functions for torrentfile module. maketorrent ( args , v = None ) Torrent making factory. Source code in tests\\test_torrentfile.py def maketorrent ( args , v = None ): \"\"\"Torrent making factory.\"\"\" if v not in [ 2 , 3 ]: torrent = TorrentFile ( ** args ) elif v == 2 : torrent = TorrentFileV2 ( ** args ) elif v == 3 : torrent = TorrentFileHybrid ( ** args ) torrent . assemble () return torrent . write () metav1d ( tdir ) Return generated metadata v1 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav1d ( tdir ): \"\"\"Return generated metadata v1 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args ) yield outfile , meta rmpath ([ tdir , outfile ]) metav2d ( tdir ) Return generated metadata v2 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav2d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , v = 2 ) yield outfile , meta rmpath ([ tdir , outfile ]) metav3d ( tdir ) Return generated metadata v2 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav3d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , v = 3 ) yield outfile , meta rmpath ([ tdir , outfile ]) smallfile () Generate Sized file a tiny bit larger than BLOCK_SIZE. Source code in tests\\test_torrentfile.py @pytest . fixture def smallfile (): \"\"\"Generate Sized file a tiny bit larger than BLOCK_SIZE.\"\"\" path = testfile ( exp = 14 ) with open ( path , \"ab\" ) as fd : fd . write ( b \"000000000000000\" ) yield path rmpath ( path ) tdir ( request ) Return temp directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir ( request ): \"\"\"Return temp directory.\"\"\" return build ( request . param ) tdir1 ( request ) Return temporary directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir1 ( request ): \"\"\"Return temporary directory.\"\"\" folder = build ( request . param ) args = { \"path\" : folder , \"announce\" : \"https://tracker.com/announce\" } yield folder , args rmpath ( folder ) test_exception_path_error () Test MissingPathError exception. Source code in tests\\test_torrentfile.py def test_exception_path_error (): \"\"\"Test MissingPathError exception.\"\"\" try : raise utils . MissingPathError ( \"this is a message\" ) except utils . MissingPathError : assert True # nosec test_hybrid_0_length () Test Hybrid with zero length file. Source code in tests\\test_torrentfile.py def test_hybrid_0_length (): \"\"\"Test Hybrid with zero length file.\"\"\" path = Path ( Temp . root ) / \"empty\" path . touch () args = { \"path\" : str ( path ), \"announce\" : \"announce\" , } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"announce\" ] == \"announce\" # nosec torrent . write () torpath = path . with_suffix ( \".torrent\" ) assert os . path . exists ( torpath ) # nosec rmpath ([ path , torpath ]) test_hybrid_outfile ( tdir1 ) Test Hybrid class with output as argument. Source code in tests\\test_torrentfile.py def test_hybrid_outfile ( tdir1 ): \"\"\"Test Hybrid class with output as argument.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFileHybrid ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_hybrid_sized_file ( smallfile ) Test pad_remaining function in hybrid FileHash class. Source code in tests\\test_torrentfile.py def test_hybrid_sized_file ( smallfile ): \"\"\"Test pad_remaining function in hybrid FileHash class.\"\"\" args = { \"path\" : smallfile , \"announce\" : \"announce\" , \"piece_length\" : 15 } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"announce\" ] == args [ \"announce\" ] # nosec assert torrent . meta [ \"info\" ][ \"piece length\" ] == 2 ** 15 # nosec test_hybrid_under_block_sized () Test pad_remaining function in hybrid FileHash class. Source code in tests\\test_torrentfile.py def test_hybrid_under_block_sized (): \"\"\"Test pad_remaining function in hybrid FileHash class.\"\"\" smallest = os . path . join ( Temp . root , \"smallest\" ) with open ( smallest , \"wb\" ) as fd : letters = b \"abcdefghijklmnopqrstuvwxyzABZDEFGHIJKLMNOPQRSTUVWXYZ\" size = len ( letters ) while size < 16000 : fd . write ( letters ) size += len ( letters ) args = { \"path\" : smallest , \"piece_length\" : 2 ** 14 } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"info\" ][ \"piece length\" ] == 2 ** 14 # nosec rmpath ( smallest ) test_hybrid_with_outfile ( tdir1 ) Test Hybrid class with output in kwargs. Source code in tests\\test_torrentfile.py def test_hybrid_with_outfile ( tdir1 ): \"\"\"Test Hybrid class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFileHybrid ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_meta_no_args_v1 () Test construct TorrentFile with no arguments. Source code in tests\\test_torrentfile.py def test_meta_no_args_v1 (): \"\"\"Test construct TorrentFile with no arguments.\"\"\" try : assert TorrentFile ( announce = \"url\" ) # nosec except utils . MissingPathError : assert True # nosec test_meta_no_args_v2 () Test construct TorrentFileV2 with no arguments. Source code in tests\\test_torrentfile.py def test_meta_no_args_v2 (): \"\"\"Test construct TorrentFileV2 with no arguments.\"\"\" try : assert TorrentFileV2 ( private = True ) # nosec except utils . MissingPathError : assert True # nosec test_metafile_assemble ( tdir1 ) Test MetaFile assemble file Exception. Source code in tests\\test_torrentfile.py def test_metafile_assemble ( tdir1 ): \"\"\"Test MetaFile assemble file Exception.\"\"\" fd , args = tdir1 meta = MetaFile ( ** args ) try : meta . assemble () except NotImplementedError : assert True # nosec rmpath ( fd ) test_torrentfile_dir ( tdir1 ) Test temporary directory. Source code in tests\\test_torrentfile.py def test_torrentfile_dir ( tdir1 ): \"\"\"Test temporary directory.\"\"\" _ , args = tdir1 torrent = TorrentFile ( ** args ) assert torrent . meta is not None # nosec test_torrentfile_dir_comment ( tdir1 ) Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_comment ( tdir1 ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir1 args [ \"private\" ] = True args [ \"comment\" ] = \"This is a comment\" torrent = TorrentFile ( ** args ) meta = torrent . meta assert \"private\" in meta [ \"info\" ] and \"comment\" in meta [ \"info\" ] # nosec test_torrentfile_dir_private ( tdir1 ) Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_private ( tdir1 ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir1 args [ \"private\" ] = True args [ \"piece_length\" ] = 1048576 torrent = TorrentFile ( ** args ) meta = torrent . meta assert \"private\" in meta [ \"info\" ] # nosec test_torrentfile_with_outfile ( tdir1 ) Test TorrentFile class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfile_with_outfile ( tdir1 ): \"\"\"Test TorrentFile class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFile ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_torrentfile_write_outfile ( tdir1 ) Test TorrentFile class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfile_write_outfile ( tdir1 ): \"\"\"Test TorrentFile class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFile ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_torrentfilev2_outfile ( tdir1 ) Test TorrentFile2 class with output as argument. Source code in tests\\test_torrentfile.py def test_torrentfilev2_outfile ( tdir1 ): \"\"\"Test TorrentFile2 class with output as argument.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFileV2 ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_torrentfilev2_with_outfile ( tdir1 ) Test TorrentFileV2 class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfilev2_with_outfile ( tdir1 ): \"\"\"Test TorrentFileV2 class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFileV2 ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile ) test_v1_info_keys_dir ( metav1d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"name\" , \"private\" , \"source\" , \"comment\" , \"pieces\" ]) def test_v1_info_keys_dir ( metav1d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v1_meta_keys ( metav1d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"announce\" , \"info\" , \"creation date\" , \"created by\" ]) def test_v1_meta_keys ( metav1d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d assert key in meta # nosec assert os . path . exists ( outfile ) # nosec test_v2_0_length () Test TorrentFileV2 with zero length file. Source code in tests\\test_torrentfile.py def test_v2_0_length (): \"\"\"Test TorrentFileV2 with zero length file.\"\"\" path = Path ( Temp . root ) / \"empty\" path . touch () args = { \"path\" : str ( path ), \"announce\" : \"announce\" , } torrent = TorrentFileV2 ( ** args ) torrent . write () torpath = path . with_suffix ( \".torrent\" ) assert os . path . exists ( torpath ) # nosec rmpath ([ path , torpath ]) test_v2_info_keys_dir ( metav2d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" ]) def test_v2_info_keys_dir ( metav2d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v2_meta_keys ( metav2d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" , \"created by\" ]) def test_v2_meta_keys ( metav2d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d assert key in meta # nosec assert os . path . exists ( outfile ) # nosec test_v3_info_keys_dir ( metav3d , field ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'field' , [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" ]) def test_v3_info_keys_dir ( metav3d , field ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert field in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v3_info_keys_pieces ( metav3d , key ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"name\" , \"private\" , \"source\" , \"comment\" , \"pieces\" ]) def test_v3_info_keys_pieces ( metav3d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v3_meta_keys ( metav3d , field ) Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'field' , [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" , \"created by\" ]) def test_v3_meta_keys ( metav3d , field ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert field in meta # nosec assert os . path . exists ( outfile ) # nosec Test main module functionality. test_class_annlist_v2 ( tfile ) Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_list_annlist ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : [ \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_list_annlist_v2 ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : [ \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_single_file_small ( hasher ) Test when single file is slightly larger than piece length. Source code in tests\\test_main.py @pytest . mark . parametrize ( \"hasher\" , [ TorrentFileV2 , TorrentFileHybrid ]) def test_class_single_file_small ( hasher ): \"\"\"Test when single file is slightly larger than piece length.\"\"\" path = testfile ( exp = 15 ) with open ( path , \"ab\" ) as binfile : binfile . write (( Temp . seq * 2 ) . encode ( \"utf-8\" )) args = { \"path\" : path , \"piece_length\" : 15 , \"source\" : \"example1\" } torrent = hasher ( ** args ) tpath , _ = torrent . write () assert os . path . exists ( tpath ) # nosec test_class_tuple_annlist ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker3/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_tuple_annlist_v2 ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_class_with_annlist ( tfile ) Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_with_annlist ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker3/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_main_annlist_single ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_main_annlist_single_v1 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v1 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"1\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_single_v2 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"2\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_single_v3 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"3\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_v2 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"2\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_v3 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"3\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker4/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_main_announce_list ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_announce_list ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ path , \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ] parser = main () url = \"https://tracker4/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec test_main_func ( tfile ) Test main script function. Source code in tests\\test_main.py def test_main_func ( tfile ): \"\"\"Test main script function.\"\"\" args , path = tfile opath = os . path . join ( Temp . root , \"test.torrent\" ) sys . argv = args + [ path , \"-o\" , opath ] main () assert os . path . exists ( opath ) # nosec rmpath ( opath ) tfile ( request ) Create fixture for tests. Source code in tests\\test_main.py @pytest . fixture ( scope = \"module\" , params = list ( range ( 14 , 26 ))) def tfile ( request ): \"\"\"Create fixture for tests.\"\"\" args = [ \"torrentfile\" , \"--private\" , \"--announce\" , \"https://tracker1.to/announce\" , \"--source\" , \"TFile\" , ] t_file = testfile ( exp = request . param ) yield args , t_file rmpath ( t_file ) Testing functions for the progress module. mktorrent ( args , v = None ) Compile bittorrent meta file. Source code in tests\\test_progress.py def mktorrent ( args , v = None ): \"\"\"Compile bittorrent meta file.\"\"\" if v == 3 : torrent = TorrentFileHybrid ( ** args ) elif v == 2 : torrent = TorrentFileV2 ( ** args ) else : torrent = TorrentFile ( ** args ) base = os . path . basename ( args [ 'path' ]) name = f \" { base } . { v } .torrent\" outfile = os . path . join ( Temp . root , name ) torrent . write ( outfile ) return outfile struct1 () Return single struct list. Source code in tests\\test_progress.py @pytest . fixture def struct1 (): \"\"\"Return single struct list.\"\"\" path = build ( Temp . structs [ 1 ]) return path test_checker_class ( struct , version ) Test Checker Class against meta files. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class ( struct , version ): \"\"\"Test Checker Class against meta files.\"\"\" path = build ( struct ) args = { \"path\" : path , \"announce\" : \"https://announce.com/announce\" } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) assert checker . result == \"100\" # nosec rmpath ([ outfile , path ]) test_checker_class_allfiles ( version , struct ) Test Checker class when all files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_allfiles ( version , struct ): \"\"\"Test Checker class when all files are missing from contents.\"\"\" path = Path ( build ( struct )) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) def traverse ( path ): \"\"\"Traverse internal subdirectories.\"\"\" if path . is_file (): rmpath ( path ) elif path . is_dir (): for item in path . iterdir (): traverse ( item ) traverse ( path ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec rmpath ( outfile ) Temp . rmdirs () test_checker_class_allpaths ( version , struct ) Test Checker class when all files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_class_allpaths ( version , struct ): \"\"\"Test Checker class when all files are missing from contents.\"\"\" path = Path ( build ( struct )) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) for item in path . iterdir (): rmpath ( item ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec test_checker_class_half_file ( version ) Test Checker class with half size single file. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_half_file ( version ): \"\"\"Test Checker class with half size single file.\"\"\" path = testfile ( exp = 25 ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 15 } outfile = mktorrent ( args , v = version ) half = int (( 2 ** 25 ) / 2 ) barr = bytearray ( half ) with open ( path , \"rb\" ) as content : content . readinto ( barr ) with open ( path , \"wb\" ) as content : content . write ( barr ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec test_checker_class_missing ( version , struct1 ) Test Checker class when files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_missing ( version , struct1 ): \"\"\"Test Checker class when files are missing from contents.\"\"\" path = struct1 args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) rmpath ( os . path . join ( path , \"file1\" )) rmpath ( os . path . join ( path , \"file3\" )) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec test_checker_cli_args ( struct , version ) Test exclusive Checker Mode CLI. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_cli_args ( struct , version ): \"\"\"Test exclusive Checker Mode CLI.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) sys . argv [ 1 :] = [ \"--re-check\" , outfile , t3dir ] output = main () assert output == \"100\" # nosec rmpath ( outfile ) Temp . rmdirs () test_checker_first_piece ( struct , version ) Test Checker Class when first piece is slightly alterred. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_first_piece ( struct , version ): \"\"\"Test Checker Class when first piece is slightly alterred.\"\"\" path = build ( struct ) args = { \"path\" : path , \"announce\" : \"https://announce.com/announce\" } outfile = mktorrent ( args , v = version ) def change ( path ): \"\"\"Change some bytes in file.\"\"\" if os . path . isfile ( path ): data = open ( path , \"rb\" ) . read () new = b 'some_different_bytes_to_swap' data = new + data [ len ( new ):] open ( path , \"wb\" ) . write ( data ) elif os . path . isdir ( path ): for item in os . listdir ( path ): change ( os . path . join ( path , item )) change ( path ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) != 100 # nosec rmpath ([ outfile , path ]) test_checker_no_content ( struct , version ) Test Checker class with directory that points to nothing. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_no_content ( struct , version ): \"\"\"Test Checker class with directory that points to nothing.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) CheckerClass . register_callback ( lambda * x : print ( x )) checker = CheckerClass ( outfile , t3dir ) assert checker . result == \"100\" # nosec rmpath ( outfile ) test_checker_no_meta_file () Test Checker when incorrect metafile is provided. Source code in tests\\test_progress.py def test_checker_no_meta_file (): \"\"\"Test Checker when incorrect metafile is provided.\"\"\" try : CheckerClass ( \"peaches\" , \"$\" ) except FileNotFoundError : assert True # nosec test_checker_no_root_dir ( struct ) Test Checker when incorrect root directory is provided. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_no_root_dir ( struct ): \"\"\"Test Checker when incorrect root directory is provided.\"\"\" tdir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : tdir , \"private\" : 1 } outfile = mktorrent ( args , v = 1 ) try : CheckerClass ( outfile , \"peaches\" ) except FileNotFoundError : assert True # nosec rmpath ( outfile ) test_checker_parent_dir ( struct , version ) Test providing the parent directory for torrent checking feature. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_parent_dir ( struct , version ): \"\"\"Test providing the parent directory for torrent checking feature.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , os . path . dirname ( t3dir )) assert checker . result == \"100\" # nosec rmpath ( outfile ) Temp . rmdirs () test_checker_result_property ( version ) Test Checker class with half size single file. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_result_property ( version ): \"\"\"Test Checker class with half size single file.\"\"\" path = testfile ( exp = 20 ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 14 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) result = checker . result assert checker . result == result # nosec rmpath ( outfile ) test_checker_with_file ( version , size ) Test checker with single file torrent. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 26 ))) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_with_file ( version , size ): \"\"\"Test checker with single file torrent.\"\"\" tfile = testfile ( exp = size ) args = { \"announce\" : \"announce\" , \"path\" : tfile , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , tfile ) assert checker . result == \"100\" # nosec rmpath ( outfile ) test_checker_wrong_root_dir ( struct ) Test Checker when incorrect root directory is provided. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_wrong_root_dir ( struct ): \"\"\"Test Checker when incorrect root directory is provided.\"\"\" tdir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : tdir , \"private\" : 1 } path = Path ( tdir ) newpath = path . parent / ( path . name + \"FAKE\" ) os . mkdir ( newpath ) newpath . touch ( newpath / \"file1\" ) outfile = mktorrent ( args , v = 1 ) try : CheckerClass ( outfile , str ( newpath )) except FileNotFoundError : assert True # nosec rmpath ( outfile ) rmpath ( newpath ) test_metafile_checker ( struct , version ) Test metadata checker class. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_metafile_checker ( struct , version ): \"\"\"Test metadata checker class.\"\"\" path = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) assert checker . result == \"100\" # nosec rmpath ([ outfile , path ]) test_partial_metafiles ( struct , version ) Test Checker with data that is expected to be incomplete. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_partial_metafiles ( struct , version ): \"\"\"Test Checker with data that is expected to be incomplete.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) def shortenfile ( path ): \"\"\"Shorten a few files for testing purposes.\"\"\" with open ( path , \"rb\" ) as bfile : data = bfile . read () with open ( path , \"wb\" ) as bfile : bfile . write ( data [: - 2 ** 12 ]) for item in os . listdir ( t3dir ): full = os . path . join ( t3dir , item ) if os . path . isfile ( full ): shortenfile ( full ) testdir = os . path . dirname ( t3dir ) checker = CheckerClass ( outfile , testdir ) assert checker . result != \"100\" # nosec rmpath ( outfile ) Testing operation and coverage for context module in tests directory. spaths () Return a list of each file in all structs. Source code in tests\\test_context.py def spaths (): \"\"\"Return a list of each file in all structs.\"\"\" paths = [ j for i in Temp . structs for j in i ] return paths test_build_func ( struct , start , stop ) Test testfile function result size from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 20 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 21 , 27 ))) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_build_func ( struct , start , stop ): \"\"\"Test testfile function result size from context module.\"\"\" root = build ( struct , start , stop ) assert os . path . exists ( root ) # nosec rmpath ( root ) test_mkdirs ( struct ) Test mkdirs function from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"struct\" , spaths ()) def test_mkdirs ( struct ): \"\"\"Test mkdirs function from context module.\"\"\" fd = mkdirs ( struct ) assert os . path . exists ( os . path . dirname ( fd )) # nosec rmpath ( os . path . dirname ( fd )) test_rmpath ( struct ) Test rmpath function from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"struct\" , spaths ()) def test_rmpath ( struct ): \"\"\"Test rmpath function from context module.\"\"\" fd = os . path . dirname ( mkdirs ( struct )) rmpath ( fd ) assert not os . path . exists ( fd ) # nosec rmpath ( fd ) test_seq () Test seq function for random string output. Source code in tests\\test_context.py def test_seq (): \"\"\"Test seq function for random string output.\"\"\" output = Temp . seq assert isinstance ( output , str ) # nosec test_structs () Test temp directory structures. Source code in tests\\test_context.py def test_structs (): \"\"\"Test temp directory structures.\"\"\" assert len ( Temp . structs ) == 3 # nosec test_testfile_func ( size ) Test testfile function result exists from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 27 ))) def test_testfile_func ( size ): \"\"\"Test testfile function result exists from context module.\"\"\" path = testfile ( exp = size ) assert os . path . exists ( path ) # nosec rmpath ( path ) test_testfile_func1 ( size ) Test testfile function result size from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 27 ))) def test_testfile_func1 ( size ): \"\"\"Test testfile function result size from context module.\"\"\" path = testfile ( exp = size ) assert os . path . getsize ( path ) == 2 ** size # nosec rmpath ( path ) test_xz_teardown () Test teardown function from context module. Source code in tests\\test_context.py def test_xz_teardown (): \"\"\"Test teardown function from context module.\"\"\" teardown () assert not os . path . exists ( Temp . root ) # nosec os . mkdir ( Temp . root )","title":"Tests"},{"location":"tests/#test-suit-api","text":"Torrentfile testing modules.","title":"Test Suit API"},{"location":"tests/#tests.context","text":"Context Functions used throughout testing suite.","title":"context"},{"location":"tests/#tests.context.Temp","text":"Temp class for holding context variables.","title":"Temp"},{"location":"tests/#tests.context.Temp.rmdirs","text":"Remove created directories on completion. Source code in tests\\context.py @classmethod def rmdirs ( cls ): \"\"\"Remove created directories on completion.\"\"\" size = len ( cls . dirs ) - 1 while size >= 0 : if rmpath ( cls . dirs [ size ]): del cls . dirs [ size ] size -= 1","title":"rmdirs()"},{"location":"tests/#tests.context.build","text":"Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs )","title":"build()"},{"location":"tests/#tests.context.mkdirs","text":"Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs )","title":"mkdirs()"},{"location":"tests/#tests.context.rmpath","text":"Recursively remove path. Source code in tests\\context.py def rmpath ( paths ): \"\"\"Recursively remove path.\"\"\" if isinstance ( paths , ( os . PathLike , str )): paths = [ paths ] no_errors = True for path in [ p for p in paths if os . path . exists ( p )]: try : if os . path . isdir ( path ): shutil . rmtree ( path ) else : os . remove ( path ) except PermissionError : # pragma: no cover no_errors = False continue return no_errors","title":"rmpath()"},{"location":"tests/#tests.context.rootwrap","text":"Wrap to ensure root folder exists. Source code in tests\\context.py def rootwrap ( func ): \"\"\"Wrap to ensure root folder exists.\"\"\" def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) return wrapper","title":"rootwrap()"},{"location":"tests/#tests.context.structs","text":"Temporary directory structures for testing. Source code in tests\\context.py def structs (): \"\"\"Temporary directory structures for testing.\"\"\" return [[ \"Root1/dir1/file1\" , \"Root1/dir1/file2\" , \"Root1/dir2/file3\" , \"Root1/dir2/file4\" , \"Root1/file5\" , ], [ \"Root2/file1\" , \"Root2/file2\" , \"Root2/file3\" , \"Root2/file4\" , ], [ \"Root3/dir1/dir2/file1\" , \"Root3/dir1/file2\" , \"Root3/dir3/dir4/file3\" , \"Root3/file4\" , ]]","title":"structs()"},{"location":"tests/#tests.context.teardown","text":"Teardown function for the end of testing. Source code in tests\\context.py @atexit . register def teardown (): \"\"\"Teardown function for the end of testing.\"\"\" rmpath ( Temp . root )","title":"teardown()"},{"location":"tests/#tests.context.testfile","text":"Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs )","title":"testfile()"},{"location":"tests/#tests.context.tstamp","text":"Return timestamp corresponding to now. Source code in tests\\context.py def tstamp (): \"\"\"Return timestamp corresponding to now.\"\"\" return str ( datetime . timestamp ( datetime . now ()))","title":"tstamp()"},{"location":"tests/#tests.test_cli","text":"Test CLI script functionality.","title":"test_cli"},{"location":"tests/#tests.test_cli.test_cli_args_dir","text":"Test CLI script with only path as arguement. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir ( struct , start , stop ): \"\"\"Test CLI script with only path as arguement.\"\"\" args = [ build ( struct , start , stop )] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_args_dir()"},{"location":"tests/#tests.test_cli.test_cli_args_dir_v2","text":"Test CLI script with minimal arguments v2. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir_v2 ( struct , start , stop ): \"\"\"Test CLI script with minimal arguments v2.\"\"\" tdir = build ( struct , start , stop ) args = [ tdir , \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_args_dir_v2()"},{"location":"tests/#tests.test_cli.test_cli_args_dir_v3","text":"Test CLI script with minimal arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir_v3 ( struct , start , stop ): \"\"\"Test CLI script with minimal arguments v3.\"\"\" tdir = build ( struct , start , stop ) args = [ tdir , \"--meta-version\" , \"3\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_args_dir_v3()"},{"location":"tests/#tests.test_cli.test_cli_info_output_v1","text":"Test CLI output files contents with specific arguments v1. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"field\" , [ \"piece length\" , \"name\" , \"pieces\" , \"comment\" , \"private\" , \"source\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_info_output_v1 ( struct , field ): \"\"\"Test CLI output files contents with specific arguments v1.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta [ \"info\" ] # nosec rmpath ( parser . outfile )","title":"test_cli_info_output_v1()"},{"location":"tests/#tests.test_cli.test_cli_info_output_v2_3","text":"Test CLI output file info dict meta versions 2 & 3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"version\" , [ 2 , 3 ]) @pytest . mark . parametrize ( \"field\" , [ \"piece length\" , \"name\" , \"file tree\" , \"comment\" , \"private\" , \"source\" , \"meta version\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_info_output_v2_3 ( struct , field , version ): \"\"\"Test CLI output file info dict meta versions 2 & 3.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , str ( version ), \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta [ \"info\" ] # nosec rmpath ( parser . outfile )","title":"test_cli_info_output_v2_3()"},{"location":"tests/#tests.test_cli.test_cli_meta_output_v1","text":"Test CLI output v1 file meta dict specific arguments. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"field\" , [ \"announce\" , \"created by\" , \"creation date\" , \"info\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_meta_output_v1 ( struct , field ): \"\"\"Test CLI output v1 file meta dict specific arguments.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta # nosec rmpath ( parser . outfile )","title":"test_cli_meta_output_v1()"},{"location":"tests/#tests.test_cli.test_cli_meta_output_v2_3","text":"Test CLI output torrentfile meta dict fields v2 and hybrid. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"version\" , [ 2 , 3 ]) @pytest . mark . parametrize ( \"field\" , [ \"announce\" , \"announce list\" , \"piece layers\" , \"created by\" , \"info\" , \"creation date\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_meta_output_v2_3 ( struct , field , version ): \"\"\"Test CLI output torrentfile meta dict fields v2 and hybrid.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , str ( version ), \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta # nosec rmpath ( parser . outfile )","title":"test_cli_meta_output_v2_3()"},{"location":"tests/#tests.test_cli.test_cli_no_args","text":"Test CLI script with no arguments. Source code in tests\\test_cli.py def test_cli_no_args (): \"\"\"Test CLI script with no arguments.\"\"\" sys . argv = [ sys . argv [ 0 ]] try : main () except SystemExit : assert True # nosec","title":"test_cli_no_args()"},{"location":"tests/#tests.test_cli.test_cli_with_all_args_dir","text":"Test CLI script with other specific arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_dir ( struct , start , stop ): \"\"\"Test CLI script with other specific arguments v3.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"3\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 15 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_with_all_args_dir()"},{"location":"tests/#tests.test_cli.test_cli_with_all_args_v2","text":"Test CLI script with all arguments v2. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_v2 ( struct , start , stop ): \"\"\"Test CLI script with all arguments v2.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"2\" , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_with_all_args_v2()"},{"location":"tests/#tests.test_cli.test_cli_with_all_args_v3","text":"Test CLI script with all arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_v3 ( struct , start , stop ): \"\"\"Test CLI script with all arguments v3.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"3\" , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_with_all_args_v3()"},{"location":"tests/#tests.test_context","text":"Testing operation and coverage for context module in tests directory.","title":"test_context"},{"location":"tests/#tests.test_context.spaths","text":"Return a list of each file in all structs. Source code in tests\\test_context.py def spaths (): \"\"\"Return a list of each file in all structs.\"\"\" paths = [ j for i in Temp . structs for j in i ] return paths","title":"spaths()"},{"location":"tests/#tests.test_context.test_build_func","text":"Test testfile function result size from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 20 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 21 , 27 ))) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_build_func ( struct , start , stop ): \"\"\"Test testfile function result size from context module.\"\"\" root = build ( struct , start , stop ) assert os . path . exists ( root ) # nosec rmpath ( root )","title":"test_build_func()"},{"location":"tests/#tests.test_context.test_mkdirs","text":"Test mkdirs function from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"struct\" , spaths ()) def test_mkdirs ( struct ): \"\"\"Test mkdirs function from context module.\"\"\" fd = mkdirs ( struct ) assert os . path . exists ( os . path . dirname ( fd )) # nosec rmpath ( os . path . dirname ( fd ))","title":"test_mkdirs()"},{"location":"tests/#tests.test_context.test_rmpath","text":"Test rmpath function from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"struct\" , spaths ()) def test_rmpath ( struct ): \"\"\"Test rmpath function from context module.\"\"\" fd = os . path . dirname ( mkdirs ( struct )) rmpath ( fd ) assert not os . path . exists ( fd ) # nosec rmpath ( fd )","title":"test_rmpath()"},{"location":"tests/#tests.test_context.test_seq","text":"Test seq function for random string output. Source code in tests\\test_context.py def test_seq (): \"\"\"Test seq function for random string output.\"\"\" output = Temp . seq assert isinstance ( output , str ) # nosec","title":"test_seq()"},{"location":"tests/#tests.test_context.test_structs","text":"Test temp directory structures. Source code in tests\\test_context.py def test_structs (): \"\"\"Test temp directory structures.\"\"\" assert len ( Temp . structs ) == 3 # nosec","title":"test_structs()"},{"location":"tests/#tests.test_context.test_testfile_func","text":"Test testfile function result exists from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 27 ))) def test_testfile_func ( size ): \"\"\"Test testfile function result exists from context module.\"\"\" path = testfile ( exp = size ) assert os . path . exists ( path ) # nosec rmpath ( path )","title":"test_testfile_func()"},{"location":"tests/#tests.test_context.test_testfile_func1","text":"Test testfile function result size from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 27 ))) def test_testfile_func1 ( size ): \"\"\"Test testfile function result size from context module.\"\"\" path = testfile ( exp = size ) assert os . path . getsize ( path ) == 2 ** size # nosec rmpath ( path )","title":"test_testfile_func1()"},{"location":"tests/#tests.test_context.test_xz_teardown","text":"Test teardown function from context module. Source code in tests\\test_context.py def test_xz_teardown (): \"\"\"Test teardown function from context module.\"\"\" teardown () assert not os . path . exists ( Temp . root ) # nosec os . mkdir ( Temp . root )","title":"test_xz_teardown()"},{"location":"tests/#tests.test_main","text":"Test main module functionality.","title":"test_main"},{"location":"tests/#tests.test_main.test_class_annlist_v2","text":"Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_annlist_v2()"},{"location":"tests/#tests.test_main.test_class_list_annlist","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : [ \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_list_annlist()"},{"location":"tests/#tests.test_main.test_class_list_annlist_v2","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : [ \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_list_annlist_v2()"},{"location":"tests/#tests.test_main.test_class_single_file_small","text":"Test when single file is slightly larger than piece length. Source code in tests\\test_main.py @pytest . mark . parametrize ( \"hasher\" , [ TorrentFileV2 , TorrentFileHybrid ]) def test_class_single_file_small ( hasher ): \"\"\"Test when single file is slightly larger than piece length.\"\"\" path = testfile ( exp = 15 ) with open ( path , \"ab\" ) as binfile : binfile . write (( Temp . seq * 2 ) . encode ( \"utf-8\" )) args = { \"path\" : path , \"piece_length\" : 15 , \"source\" : \"example1\" } torrent = hasher ( ** args ) tpath , _ = torrent . write () assert os . path . exists ( tpath ) # nosec","title":"test_class_single_file_small()"},{"location":"tests/#tests.test_main.test_class_tuple_annlist","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker3/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_tuple_annlist()"},{"location":"tests/#tests.test_main.test_class_tuple_annlist_v2","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_tuple_annlist_v2()"},{"location":"tests/#tests.test_main.test_class_with_annlist","text":"Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_with_annlist ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker3/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_with_annlist()"},{"location":"tests/#tests.test_main.test_main_annlist_single","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_main_annlist_single()"},{"location":"tests/#tests.test_main.test_main_annlist_single_v1","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v1 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"1\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single_v1()"},{"location":"tests/#tests.test_main.test_main_annlist_single_v2","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"2\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single_v2()"},{"location":"tests/#tests.test_main.test_main_annlist_single_v3","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"3\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single_v3()"},{"location":"tests/#tests.test_main.test_main_annlist_v2","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"2\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_v2()"},{"location":"tests/#tests.test_main.test_main_annlist_v3","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"3\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker4/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_main_annlist_v3()"},{"location":"tests/#tests.test_main.test_main_announce_list","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_announce_list ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ path , \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ] parser = main () url = \"https://tracker4/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_main_announce_list()"},{"location":"tests/#tests.test_main.test_main_func","text":"Test main script function. Source code in tests\\test_main.py def test_main_func ( tfile ): \"\"\"Test main script function.\"\"\" args , path = tfile opath = os . path . join ( Temp . root , \"test.torrent\" ) sys . argv = args + [ path , \"-o\" , opath ] main () assert os . path . exists ( opath ) # nosec rmpath ( opath )","title":"test_main_func()"},{"location":"tests/#tests.test_main.tfile","text":"Create fixture for tests. Source code in tests\\test_main.py @pytest . fixture ( scope = \"module\" , params = list ( range ( 14 , 26 ))) def tfile ( request ): \"\"\"Create fixture for tests.\"\"\" args = [ \"torrentfile\" , \"--private\" , \"--announce\" , \"https://tracker1.to/announce\" , \"--source\" , \"TFile\" , ] t_file = testfile ( exp = request . param ) yield args , t_file rmpath ( t_file )","title":"tfile()"},{"location":"tests/#tests.test_progress","text":"Testing functions for the progress module.","title":"test_progress"},{"location":"tests/#tests.test_progress.mktorrent","text":"Compile bittorrent meta file. Source code in tests\\test_progress.py def mktorrent ( args , v = None ): \"\"\"Compile bittorrent meta file.\"\"\" if v == 3 : torrent = TorrentFileHybrid ( ** args ) elif v == 2 : torrent = TorrentFileV2 ( ** args ) else : torrent = TorrentFile ( ** args ) base = os . path . basename ( args [ 'path' ]) name = f \" { base } . { v } .torrent\" outfile = os . path . join ( Temp . root , name ) torrent . write ( outfile ) return outfile","title":"mktorrent()"},{"location":"tests/#tests.test_progress.struct1","text":"Return single struct list. Source code in tests\\test_progress.py @pytest . fixture def struct1 (): \"\"\"Return single struct list.\"\"\" path = build ( Temp . structs [ 1 ]) return path","title":"struct1()"},{"location":"tests/#tests.test_progress.test_checker_class","text":"Test Checker Class against meta files. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class ( struct , version ): \"\"\"Test Checker Class against meta files.\"\"\" path = build ( struct ) args = { \"path\" : path , \"announce\" : \"https://announce.com/announce\" } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) assert checker . result == \"100\" # nosec rmpath ([ outfile , path ])","title":"test_checker_class()"},{"location":"tests/#tests.test_progress.test_checker_class_allfiles","text":"Test Checker class when all files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_allfiles ( version , struct ): \"\"\"Test Checker class when all files are missing from contents.\"\"\" path = Path ( build ( struct )) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) def traverse ( path ): \"\"\"Traverse internal subdirectories.\"\"\" if path . is_file (): rmpath ( path ) elif path . is_dir (): for item in path . iterdir (): traverse ( item ) traverse ( path ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec rmpath ( outfile ) Temp . rmdirs ()","title":"test_checker_class_allfiles()"},{"location":"tests/#tests.test_progress.test_checker_class_allpaths","text":"Test Checker class when all files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_class_allpaths ( version , struct ): \"\"\"Test Checker class when all files are missing from contents.\"\"\" path = Path ( build ( struct )) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) for item in path . iterdir (): rmpath ( item ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec","title":"test_checker_class_allpaths()"},{"location":"tests/#tests.test_progress.test_checker_class_half_file","text":"Test Checker class with half size single file. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_half_file ( version ): \"\"\"Test Checker class with half size single file.\"\"\" path = testfile ( exp = 25 ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 15 } outfile = mktorrent ( args , v = version ) half = int (( 2 ** 25 ) / 2 ) barr = bytearray ( half ) with open ( path , \"rb\" ) as content : content . readinto ( barr ) with open ( path , \"wb\" ) as content : content . write ( barr ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec","title":"test_checker_class_half_file()"},{"location":"tests/#tests.test_progress.test_checker_class_missing","text":"Test Checker class when files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_missing ( version , struct1 ): \"\"\"Test Checker class when files are missing from contents.\"\"\" path = struct1 args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) rmpath ( os . path . join ( path , \"file1\" )) rmpath ( os . path . join ( path , \"file3\" )) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec","title":"test_checker_class_missing()"},{"location":"tests/#tests.test_progress.test_checker_cli_args","text":"Test exclusive Checker Mode CLI. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_cli_args ( struct , version ): \"\"\"Test exclusive Checker Mode CLI.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) sys . argv [ 1 :] = [ \"--re-check\" , outfile , t3dir ] output = main () assert output == \"100\" # nosec rmpath ( outfile ) Temp . rmdirs ()","title":"test_checker_cli_args()"},{"location":"tests/#tests.test_progress.test_checker_first_piece","text":"Test Checker Class when first piece is slightly alterred. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_first_piece ( struct , version ): \"\"\"Test Checker Class when first piece is slightly alterred.\"\"\" path = build ( struct ) args = { \"path\" : path , \"announce\" : \"https://announce.com/announce\" } outfile = mktorrent ( args , v = version ) def change ( path ): \"\"\"Change some bytes in file.\"\"\" if os . path . isfile ( path ): data = open ( path , \"rb\" ) . read () new = b 'some_different_bytes_to_swap' data = new + data [ len ( new ):] open ( path , \"wb\" ) . write ( data ) elif os . path . isdir ( path ): for item in os . listdir ( path ): change ( os . path . join ( path , item )) change ( path ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) != 100 # nosec rmpath ([ outfile , path ])","title":"test_checker_first_piece()"},{"location":"tests/#tests.test_progress.test_checker_no_content","text":"Test Checker class with directory that points to nothing. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_no_content ( struct , version ): \"\"\"Test Checker class with directory that points to nothing.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) CheckerClass . register_callback ( lambda * x : print ( x )) checker = CheckerClass ( outfile , t3dir ) assert checker . result == \"100\" # nosec rmpath ( outfile )","title":"test_checker_no_content()"},{"location":"tests/#tests.test_progress.test_checker_no_meta_file","text":"Test Checker when incorrect metafile is provided. Source code in tests\\test_progress.py def test_checker_no_meta_file (): \"\"\"Test Checker when incorrect metafile is provided.\"\"\" try : CheckerClass ( \"peaches\" , \"$\" ) except FileNotFoundError : assert True # nosec","title":"test_checker_no_meta_file()"},{"location":"tests/#tests.test_progress.test_checker_no_root_dir","text":"Test Checker when incorrect root directory is provided. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_no_root_dir ( struct ): \"\"\"Test Checker when incorrect root directory is provided.\"\"\" tdir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : tdir , \"private\" : 1 } outfile = mktorrent ( args , v = 1 ) try : CheckerClass ( outfile , \"peaches\" ) except FileNotFoundError : assert True # nosec rmpath ( outfile )","title":"test_checker_no_root_dir()"},{"location":"tests/#tests.test_progress.test_checker_parent_dir","text":"Test providing the parent directory for torrent checking feature. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_parent_dir ( struct , version ): \"\"\"Test providing the parent directory for torrent checking feature.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , os . path . dirname ( t3dir )) assert checker . result == \"100\" # nosec rmpath ( outfile ) Temp . rmdirs ()","title":"test_checker_parent_dir()"},{"location":"tests/#tests.test_progress.test_checker_result_property","text":"Test Checker class with half size single file. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_result_property ( version ): \"\"\"Test Checker class with half size single file.\"\"\" path = testfile ( exp = 20 ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 14 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) result = checker . result assert checker . result == result # nosec rmpath ( outfile )","title":"test_checker_result_property()"},{"location":"tests/#tests.test_progress.test_checker_with_file","text":"Test checker with single file torrent. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 26 ))) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_with_file ( version , size ): \"\"\"Test checker with single file torrent.\"\"\" tfile = testfile ( exp = size ) args = { \"announce\" : \"announce\" , \"path\" : tfile , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , tfile ) assert checker . result == \"100\" # nosec rmpath ( outfile )","title":"test_checker_with_file()"},{"location":"tests/#tests.test_progress.test_checker_wrong_root_dir","text":"Test Checker when incorrect root directory is provided. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_wrong_root_dir ( struct ): \"\"\"Test Checker when incorrect root directory is provided.\"\"\" tdir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : tdir , \"private\" : 1 } path = Path ( tdir ) newpath = path . parent / ( path . name + \"FAKE\" ) os . mkdir ( newpath ) newpath . touch ( newpath / \"file1\" ) outfile = mktorrent ( args , v = 1 ) try : CheckerClass ( outfile , str ( newpath )) except FileNotFoundError : assert True # nosec rmpath ( outfile ) rmpath ( newpath )","title":"test_checker_wrong_root_dir()"},{"location":"tests/#tests.test_progress.test_metafile_checker","text":"Test metadata checker class. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_metafile_checker ( struct , version ): \"\"\"Test metadata checker class.\"\"\" path = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) assert checker . result == \"100\" # nosec rmpath ([ outfile , path ])","title":"test_metafile_checker()"},{"location":"tests/#tests.test_progress.test_partial_metafiles","text":"Test Checker with data that is expected to be incomplete. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_partial_metafiles ( struct , version ): \"\"\"Test Checker with data that is expected to be incomplete.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) def shortenfile ( path ): \"\"\"Shorten a few files for testing purposes.\"\"\" with open ( path , \"rb\" ) as bfile : data = bfile . read () with open ( path , \"wb\" ) as bfile : bfile . write ( data [: - 2 ** 12 ]) for item in os . listdir ( t3dir ): full = os . path . join ( t3dir , item ) if os . path . isfile ( full ): shortenfile ( full ) testdir = os . path . dirname ( t3dir ) checker = CheckerClass ( outfile , testdir ) assert checker . result != \"100\" # nosec rmpath ( outfile )","title":"test_partial_metafiles()"},{"location":"tests/#tests.test_torrentfile","text":"Testing functions for torrentfile module.","title":"test_torrentfile"},{"location":"tests/#tests.test_torrentfile.maketorrent","text":"Torrent making factory. Source code in tests\\test_torrentfile.py def maketorrent ( args , v = None ): \"\"\"Torrent making factory.\"\"\" if v not in [ 2 , 3 ]: torrent = TorrentFile ( ** args ) elif v == 2 : torrent = TorrentFileV2 ( ** args ) elif v == 3 : torrent = TorrentFileHybrid ( ** args ) torrent . assemble () return torrent . write ()","title":"maketorrent()"},{"location":"tests/#tests.test_torrentfile.metav1d","text":"Return generated metadata v1 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav1d ( tdir ): \"\"\"Return generated metadata v1 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args ) yield outfile , meta rmpath ([ tdir , outfile ])","title":"metav1d()"},{"location":"tests/#tests.test_torrentfile.metav2d","text":"Return generated metadata v2 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav2d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , v = 2 ) yield outfile , meta rmpath ([ tdir , outfile ])","title":"metav2d()"},{"location":"tests/#tests.test_torrentfile.metav3d","text":"Return generated metadata v2 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav3d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , v = 3 ) yield outfile , meta rmpath ([ tdir , outfile ])","title":"metav3d()"},{"location":"tests/#tests.test_torrentfile.smallfile","text":"Generate Sized file a tiny bit larger than BLOCK_SIZE. Source code in tests\\test_torrentfile.py @pytest . fixture def smallfile (): \"\"\"Generate Sized file a tiny bit larger than BLOCK_SIZE.\"\"\" path = testfile ( exp = 14 ) with open ( path , \"ab\" ) as fd : fd . write ( b \"000000000000000\" ) yield path rmpath ( path )","title":"smallfile()"},{"location":"tests/#tests.test_torrentfile.tdir","text":"Return temp directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir ( request ): \"\"\"Return temp directory.\"\"\" return build ( request . param )","title":"tdir()"},{"location":"tests/#tests.test_torrentfile.tdir1","text":"Return temporary directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir1 ( request ): \"\"\"Return temporary directory.\"\"\" folder = build ( request . param ) args = { \"path\" : folder , \"announce\" : \"https://tracker.com/announce\" } yield folder , args rmpath ( folder )","title":"tdir1()"},{"location":"tests/#tests.test_torrentfile.test_exception_path_error","text":"Test MissingPathError exception. Source code in tests\\test_torrentfile.py def test_exception_path_error (): \"\"\"Test MissingPathError exception.\"\"\" try : raise utils . MissingPathError ( \"this is a message\" ) except utils . MissingPathError : assert True # nosec","title":"test_exception_path_error()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_0_length","text":"Test Hybrid with zero length file. Source code in tests\\test_torrentfile.py def test_hybrid_0_length (): \"\"\"Test Hybrid with zero length file.\"\"\" path = Path ( Temp . root ) / \"empty\" path . touch () args = { \"path\" : str ( path ), \"announce\" : \"announce\" , } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"announce\" ] == \"announce\" # nosec torrent . write () torpath = path . with_suffix ( \".torrent\" ) assert os . path . exists ( torpath ) # nosec rmpath ([ path , torpath ])","title":"test_hybrid_0_length()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_outfile","text":"Test Hybrid class with output as argument. Source code in tests\\test_torrentfile.py def test_hybrid_outfile ( tdir1 ): \"\"\"Test Hybrid class with output as argument.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFileHybrid ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_hybrid_outfile()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_sized_file","text":"Test pad_remaining function in hybrid FileHash class. Source code in tests\\test_torrentfile.py def test_hybrid_sized_file ( smallfile ): \"\"\"Test pad_remaining function in hybrid FileHash class.\"\"\" args = { \"path\" : smallfile , \"announce\" : \"announce\" , \"piece_length\" : 15 } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"announce\" ] == args [ \"announce\" ] # nosec assert torrent . meta [ \"info\" ][ \"piece length\" ] == 2 ** 15 # nosec","title":"test_hybrid_sized_file()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_under_block_sized","text":"Test pad_remaining function in hybrid FileHash class. Source code in tests\\test_torrentfile.py def test_hybrid_under_block_sized (): \"\"\"Test pad_remaining function in hybrid FileHash class.\"\"\" smallest = os . path . join ( Temp . root , \"smallest\" ) with open ( smallest , \"wb\" ) as fd : letters = b \"abcdefghijklmnopqrstuvwxyzABZDEFGHIJKLMNOPQRSTUVWXYZ\" size = len ( letters ) while size < 16000 : fd . write ( letters ) size += len ( letters ) args = { \"path\" : smallest , \"piece_length\" : 2 ** 14 } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"info\" ][ \"piece length\" ] == 2 ** 14 # nosec rmpath ( smallest )","title":"test_hybrid_under_block_sized()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_with_outfile","text":"Test Hybrid class with output in kwargs. Source code in tests\\test_torrentfile.py def test_hybrid_with_outfile ( tdir1 ): \"\"\"Test Hybrid class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFileHybrid ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_hybrid_with_outfile()"},{"location":"tests/#tests.test_torrentfile.test_meta_no_args_v1","text":"Test construct TorrentFile with no arguments. Source code in tests\\test_torrentfile.py def test_meta_no_args_v1 (): \"\"\"Test construct TorrentFile with no arguments.\"\"\" try : assert TorrentFile ( announce = \"url\" ) # nosec except utils . MissingPathError : assert True # nosec","title":"test_meta_no_args_v1()"},{"location":"tests/#tests.test_torrentfile.test_meta_no_args_v2","text":"Test construct TorrentFileV2 with no arguments. Source code in tests\\test_torrentfile.py def test_meta_no_args_v2 (): \"\"\"Test construct TorrentFileV2 with no arguments.\"\"\" try : assert TorrentFileV2 ( private = True ) # nosec except utils . MissingPathError : assert True # nosec","title":"test_meta_no_args_v2()"},{"location":"tests/#tests.test_torrentfile.test_metafile_assemble","text":"Test MetaFile assemble file Exception. Source code in tests\\test_torrentfile.py def test_metafile_assemble ( tdir1 ): \"\"\"Test MetaFile assemble file Exception.\"\"\" fd , args = tdir1 meta = MetaFile ( ** args ) try : meta . assemble () except NotImplementedError : assert True # nosec rmpath ( fd )","title":"test_metafile_assemble()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_dir","text":"Test temporary directory. Source code in tests\\test_torrentfile.py def test_torrentfile_dir ( tdir1 ): \"\"\"Test temporary directory.\"\"\" _ , args = tdir1 torrent = TorrentFile ( ** args ) assert torrent . meta is not None # nosec","title":"test_torrentfile_dir()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_dir_comment","text":"Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_comment ( tdir1 ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir1 args [ \"private\" ] = True args [ \"comment\" ] = \"This is a comment\" torrent = TorrentFile ( ** args ) meta = torrent . meta assert \"private\" in meta [ \"info\" ] and \"comment\" in meta [ \"info\" ] # nosec","title":"test_torrentfile_dir_comment()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_dir_private","text":"Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_private ( tdir1 ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir1 args [ \"private\" ] = True args [ \"piece_length\" ] = 1048576 torrent = TorrentFile ( ** args ) meta = torrent . meta assert \"private\" in meta [ \"info\" ] # nosec","title":"test_torrentfile_dir_private()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_with_outfile","text":"Test TorrentFile class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfile_with_outfile ( tdir1 ): \"\"\"Test TorrentFile class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFile ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_torrentfile_with_outfile()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_write_outfile","text":"Test TorrentFile class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfile_write_outfile ( tdir1 ): \"\"\"Test TorrentFile class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFile ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_torrentfile_write_outfile()"},{"location":"tests/#tests.test_torrentfile.test_torrentfilev2_outfile","text":"Test TorrentFile2 class with output as argument. Source code in tests\\test_torrentfile.py def test_torrentfilev2_outfile ( tdir1 ): \"\"\"Test TorrentFile2 class with output as argument.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFileV2 ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_torrentfilev2_outfile()"},{"location":"tests/#tests.test_torrentfile.test_torrentfilev2_with_outfile","text":"Test TorrentFileV2 class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfilev2_with_outfile ( tdir1 ): \"\"\"Test TorrentFileV2 class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFileV2 ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_torrentfilev2_with_outfile()"},{"location":"tests/#tests.test_torrentfile.test_v1_info_keys_dir","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"name\" , \"private\" , \"source\" , \"comment\" , \"pieces\" ]) def test_v1_info_keys_dir ( metav1d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v1_info_keys_dir()"},{"location":"tests/#tests.test_torrentfile.test_v1_meta_keys","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"announce\" , \"info\" , \"creation date\" , \"created by\" ]) def test_v1_meta_keys ( metav1d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d assert key in meta # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v1_meta_keys()"},{"location":"tests/#tests.test_torrentfile.test_v2_0_length","text":"Test TorrentFileV2 with zero length file. Source code in tests\\test_torrentfile.py def test_v2_0_length (): \"\"\"Test TorrentFileV2 with zero length file.\"\"\" path = Path ( Temp . root ) / \"empty\" path . touch () args = { \"path\" : str ( path ), \"announce\" : \"announce\" , } torrent = TorrentFileV2 ( ** args ) torrent . write () torpath = path . with_suffix ( \".torrent\" ) assert os . path . exists ( torpath ) # nosec rmpath ([ path , torpath ])","title":"test_v2_0_length()"},{"location":"tests/#tests.test_torrentfile.test_v2_info_keys_dir","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" ]) def test_v2_info_keys_dir ( metav2d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v2_info_keys_dir()"},{"location":"tests/#tests.test_torrentfile.test_v2_meta_keys","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" , \"created by\" ]) def test_v2_meta_keys ( metav2d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d assert key in meta # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v2_meta_keys()"},{"location":"tests/#tests.test_torrentfile.test_v3_info_keys_dir","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'field' , [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" ]) def test_v3_info_keys_dir ( metav3d , field ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert field in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v3_info_keys_dir()"},{"location":"tests/#tests.test_torrentfile.test_v3_info_keys_pieces","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"name\" , \"private\" , \"source\" , \"comment\" , \"pieces\" ]) def test_v3_info_keys_pieces ( metav3d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v3_info_keys_pieces()"},{"location":"tests/#tests.test_torrentfile.test_v3_meta_keys","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'field' , [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" , \"created by\" ]) def test_v3_meta_keys ( metav3d , field ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert field in meta # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v3_meta_keys()"},{"location":"tests/#tests.test_utils","text":"Test functions for utils module.","title":"test_utils"},{"location":"tests/#tests.test_utils.tdir","text":"Return temporary directory. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir ( request ): \"\"\"Return temporary directory.\"\"\" drct = build ( request . param ) yield drct rmpath ( drct )","title":"tdir()"},{"location":"tests/#tests.test_utils.test_filelist_total_dir_files","text":"Test Utility function filelist_total number of files. Source code in tests\\test_utils.py def test_filelist_total_dir_files ( tdir ): \"\"\"Test Utility function filelist_total number of files.\"\"\" _ , filelist = utils . filelist_total ( tdir ) assert len ( filelist ) > 0 # nosec","title":"test_filelist_total_dir_files()"},{"location":"tests/#tests.test_utils.test_filelist_total_len_tfile","text":"Test Utility function filelist_total length for single. Source code in tests\\test_utils.py def test_filelist_total_len_tfile ( tfile ): \"\"\"Test Utility function filelist_total length for single.\"\"\" _ , filelist = utils . filelist_total ( tfile ) assert len ( filelist ) == 1 # nosec","title":"test_filelist_total_len_tfile()"},{"location":"tests/#tests.test_utils.test_filelist_total_size_tfile","text":"Test Utility function filelist_total total bytes. Source code in tests\\test_utils.py def test_filelist_total_size_tfile ( tfile ): \"\"\"Test Utility function filelist_total total bytes.\"\"\" size , _ = utils . filelist_total ( tfile ) assert os . path . getsize ( tfile ) == size # nosec","title":"test_filelist_total_size_tfile()"},{"location":"tests/#tests.test_utils.test_filelist_total_tdir_sum","text":"Test Utility function filelist_total sum total all files. Source code in tests\\test_utils.py def test_filelist_total_tdir_sum ( tdir ): \"\"\"Test Utility function filelist_total sum total all files.\"\"\" size , filelist = utils . filelist_total ( tdir ) assert sum ([ os . path . getsize ( fd ) for fd in filelist ]) == size # nosec","title":"test_filelist_total_tdir_sum()"},{"location":"tests/#tests.test_utils.test_filelist_total_tfile","text":"Test Utility function filelist_total on single file. Source code in tests\\test_utils.py def test_filelist_total_tfile ( tfile ): \"\"\"Test Utility function filelist_total on single file.\"\"\" _ , filelist = utils . filelist_total ( tfile ) assert filelist [ 0 ] == tfile # nosec","title":"test_filelist_total_tfile()"},{"location":"tests/#tests.test_utils.test_get_filelist_tdir","text":"Test get_file_list function. Source code in tests\\test_utils.py def test_get_filelist_tdir ( tdir ): \"\"\"Test get_file_list function.\"\"\" result = utils . get_file_list ( tdir ) assert len ( result ) >= 1 # nosec","title":"test_get_filelist_tdir()"},{"location":"tests/#tests.test_utils.test_get_filelist_tfile","text":"Test get_file_list function. Source code in tests\\test_utils.py def test_get_filelist_tfile ( tfile ): \"\"\"Test get_file_list function.\"\"\" result = utils . get_file_list ( tfile ) assert len ( result ) == 1 # nosec","title":"test_get_filelist_tfile()"},{"location":"tests/#tests.test_utils.test_get_piece_len","text":"Test get_piece_length function does not exceed max. Source code in tests\\test_utils.py def test_get_piece_len ( tfile ): \"\"\"Test get_piece_length function does not exceed max.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result <= MAX_BLOCK # nosec","title":"test_get_piece_len()"},{"location":"tests/#tests.test_utils.test_get_piece_len_large","text":"Test get_piece_length function does not exceed maximum. Source code in tests\\test_utils.py def test_get_piece_len_large (): \"\"\"Test get_piece_length function does not exceed maximum.\"\"\" size = 2 ** 31 result = utils . get_piece_length ( size ) assert result <= MAX_BLOCK # nosec","title":"test_get_piece_len_large()"},{"location":"tests/#tests.test_utils.test_get_piece_len_power_2","text":"Test get_piece_length function is a power of 2. Source code in tests\\test_utils.py def test_get_piece_len_power_2 ( tfile ): \"\"\"Test get_piece_length function is a power of 2.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result % MIN_BLOCK == 0 # nosec","title":"test_get_piece_len_power_2()"},{"location":"tests/#tests.test_utils.test_get_piece_length_min","text":"Test get_piece_length function does not fall under minimum. Source code in tests\\test_utils.py def test_get_piece_length_min ( tfile ): \"\"\"Test get_piece_length function does not fall under minimum.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result >= MIN_BLOCK # nosec","title":"test_get_piece_length_min()"},{"location":"tests/#tests.test_utils.test_normalize_plength_fails","text":"Test to ensure incorrect piece length values fail. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 10 , 1 , 4425631 , 35 , \"1111\" , \"abc\" ]) def test_normalize_plength_fails ( piece_length ): \"\"\"Test to ensure incorrect piece length values fail.\"\"\" try : utils . normalize_piece_length ( piece_length ) except utils . PieceLengthValueError : assert True # nosec","title":"test_normalize_plength_fails()"},{"location":"tests/#tests.test_utils.test_normalize_plength_type","text":"Test normalize piece length function output type. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 14 , 20 , 2 ** 15 , 2 ** 19 , \"22\" , \"21\" ]) def test_normalize_plength_type ( piece_length ): \"\"\"Test normalize piece length function output type.\"\"\" value = utils . normalize_piece_length ( piece_length ) assert isinstance ( value , int ) # nosec","title":"test_normalize_plength_type()"},{"location":"tests/#tests.test_utils.test_normalize_plength_value","text":"Test normalize piece length output perfect power of 2. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 14 , 20 , 2 ** 15 , 2 ** 19 , \"22\" , \"21\" ]) def test_normalize_plength_value ( piece_length ): \"\"\"Test normalize piece length output perfect power of 2.\"\"\" value = utils . normalize_piece_length ( piece_length ) log = math . log2 ( value ) assert int ( log ) == log # nosec","title":"test_normalize_plength_value()"},{"location":"tests/#tests.test_utils.test_path_piece_length_max","text":"Test path_piece_length for dir return piece_length < Maximum. Source code in tests\\test_utils.py def test_path_piece_length_max ( tdir ): \"\"\"Test path_piece_length for dir return piece_length < Maximum.\"\"\" result = utils . path_piece_length ( tdir ) assert result <= MAX_BLOCK # nosec","title":"test_path_piece_length_max()"},{"location":"tests/#tests.test_utils.test_path_piece_length_min","text":"Test path_piece_length for dir return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_min ( tdir ): \"\"\"Test path_piece_length for dir return piece_length is power of 2.\"\"\" result = utils . path_piece_length ( tdir ) assert result >= MIN_BLOCK # nosec","title":"test_path_piece_length_min()"},{"location":"tests/#tests.test_utils.test_path_piece_length_pow2","text":"Test path_piece_length for file return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_pow2 ( tdir ): \"\"\"Test path_piece_length for file return piece_length is power of 2.\"\"\" result = utils . path_piece_length ( tdir ) assert result % MIN_BLOCK == 0 # nosec","title":"test_path_piece_length_pow2()"},{"location":"tests/#tests.test_utils.test_path_size_file","text":"Test path_size function for tempfile. Source code in tests\\test_utils.py def test_path_size_file ( tfile ): \"\"\"Test path_size function for tempfile.\"\"\" size = os . path . getsize ( tfile ) val = utils . path_size ( tfile ) assert size == val # nosec","title":"test_path_size_file()"},{"location":"tests/#tests.test_utils.test_path_size_file_gt0","text":"Test path_size function for tempfile is greater than zero. Source code in tests\\test_utils.py def test_path_size_file_gt0 ( tfile ): \"\"\"Test path_size function for tempfile is greater than zero.\"\"\" val = utils . path_size ( tfile ) assert val > 0 # nosec","title":"test_path_size_file_gt0()"},{"location":"tests/#tests.test_utils.test_path_stat_base2_plen","text":"Test path_stat function return piece length is power of 2. Source code in tests\\test_utils.py def test_path_stat_base2_plen ( tdir ): \"\"\"Test path_stat function return piece length is power of 2.\"\"\" _ , _ , piece_length = utils . path_stat ( tdir ) assert piece_length % MIN_BLOCK == 0 # nosec","title":"test_path_stat_base2_plen()"},{"location":"tests/#tests.test_utils.test_path_stat_eq_filelist","text":"Test path_stat function return filelist. Source code in tests\\test_utils.py def test_path_stat_eq_filelist ( tdir ): \"\"\"Test path_stat function return filelist.\"\"\" filelist , _ , _ = utils . path_stat ( tdir ) assert len ( filelist ) >= 1 # nosec","title":"test_path_stat_eq_filelist()"},{"location":"tests/#tests.test_utils.test_path_stat_eq_size","text":"Test path_stat function return identically correct size. Source code in tests\\test_utils.py def test_path_stat_eq_size ( tdir ): \"\"\"Test path_stat function return identically correct size.\"\"\" filelist , size , _ = utils . path_stat ( tdir ) assert size == sum ([ os . path . getsize ( x ) for x in filelist ]) # nosec","title":"test_path_stat_eq_size()"},{"location":"tests/#tests.test_utils.test_path_stat_gt0_filelist","text":"Test path_stat function for tempdir1 sorted > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_filelist ( tdir ): \"\"\"Test path_stat function for tempdir1 sorted > 0.\"\"\" filelist , _ , _ = utils . path_stat ( tdir ) assert len ( filelist ) > 0 # nosec","title":"test_path_stat_gt0_filelist()"},{"location":"tests/#tests.test_utils.test_path_stat_gt0_plen","text":"Test path_stat function return piece length > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_plen ( tdir ): \"\"\"Test path_stat function return piece length > 0.\"\"\" _ , _ , piece_length = utils . path_stat ( tdir ) assert piece_length >= MIN_BLOCK # nosec","title":"test_path_stat_gt0_plen()"},{"location":"tests/#tests.test_utils.test_path_stat_gt0_size","text":"Test path_stat function return size > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_size ( tdir ): \"\"\"Test path_stat function return size > 0.\"\"\" _ , size , _ = utils . path_stat ( tdir ) assert size > 0 # nosec","title":"test_path_stat_gt0_size()"},{"location":"tests/#tests.test_utils.test_path_stat_gtsize_plen","text":"Test path_stat function return size > piece length. Source code in tests\\test_utils.py def test_path_stat_gtsize_plen ( tdir ): \"\"\"Test path_stat function return size > piece length.\"\"\" _ , size , piece_length = utils . path_stat ( tdir ) assert size > piece_length # nosec","title":"test_path_stat_gtsize_plen()"},{"location":"tests/#tests.test_utils.tfile","text":"Return temporary file. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temporary file.\"\"\" tle = testfile () yield tle rmpath ( tle ) Context Functions used throughout testing suite.","title":"tfile()"},{"location":"tests/#tests.context.Temp","text":"Temp class for holding context variables.","title":"Temp"},{"location":"tests/#tests.context.Temp.rmdirs","text":"Remove created directories on completion. Source code in tests\\context.py @classmethod def rmdirs ( cls ): \"\"\"Remove created directories on completion.\"\"\" size = len ( cls . dirs ) - 1 while size >= 0 : if rmpath ( cls . dirs [ size ]): del cls . dirs [ size ] size -= 1","title":"rmdirs()"},{"location":"tests/#tests.context.build","text":"Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs )","title":"build()"},{"location":"tests/#tests.context.mkdirs","text":"Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs )","title":"mkdirs()"},{"location":"tests/#tests.context.rmpath","text":"Recursively remove path. Source code in tests\\context.py def rmpath ( paths ): \"\"\"Recursively remove path.\"\"\" if isinstance ( paths , ( os . PathLike , str )): paths = [ paths ] no_errors = True for path in [ p for p in paths if os . path . exists ( p )]: try : if os . path . isdir ( path ): shutil . rmtree ( path ) else : os . remove ( path ) except PermissionError : # pragma: no cover no_errors = False continue return no_errors","title":"rmpath()"},{"location":"tests/#tests.context.rootwrap","text":"Wrap to ensure root folder exists. Source code in tests\\context.py def rootwrap ( func ): \"\"\"Wrap to ensure root folder exists.\"\"\" def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs ) return wrapper","title":"rootwrap()"},{"location":"tests/#tests.context.structs","text":"Temporary directory structures for testing. Source code in tests\\context.py def structs (): \"\"\"Temporary directory structures for testing.\"\"\" return [[ \"Root1/dir1/file1\" , \"Root1/dir1/file2\" , \"Root1/dir2/file3\" , \"Root1/dir2/file4\" , \"Root1/file5\" , ], [ \"Root2/file1\" , \"Root2/file2\" , \"Root2/file3\" , \"Root2/file4\" , ], [ \"Root3/dir1/dir2/file1\" , \"Root3/dir1/file2\" , \"Root3/dir3/dir4/file3\" , \"Root3/file4\" , ]]","title":"structs()"},{"location":"tests/#tests.context.teardown","text":"Teardown function for the end of testing. Source code in tests\\context.py @atexit . register def teardown (): \"\"\"Teardown function for the end of testing.\"\"\" rmpath ( Temp . root )","title":"teardown()"},{"location":"tests/#tests.context.testfile","text":"Execute function wrapper internal func. Source code in tests\\context.py def wrapper ( * args , ** kwargs ): \"\"\"Execute function wrapper internal func.\"\"\" if not os . path . exists ( Temp . root ): os . mkdir ( Temp . root ) return func ( * args , ** kwargs )","title":"testfile()"},{"location":"tests/#tests.context.tstamp","text":"Return timestamp corresponding to now. Source code in tests\\context.py def tstamp (): \"\"\"Return timestamp corresponding to now.\"\"\" return str ( datetime . timestamp ( datetime . now ())) Test CLI script functionality.","title":"tstamp()"},{"location":"tests/#tests.test_cli.test_cli_args_dir","text":"Test CLI script with only path as arguement. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir ( struct , start , stop ): \"\"\"Test CLI script with only path as arguement.\"\"\" args = [ build ( struct , start , stop )] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_args_dir()"},{"location":"tests/#tests.test_cli.test_cli_args_dir_v2","text":"Test CLI script with minimal arguments v2. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir_v2 ( struct , start , stop ): \"\"\"Test CLI script with minimal arguments v2.\"\"\" tdir = build ( struct , start , stop ) args = [ tdir , \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_args_dir_v2()"},{"location":"tests/#tests.test_cli.test_cli_args_dir_v3","text":"Test CLI script with minimal arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_args_dir_v3 ( struct , start , stop ): \"\"\"Test CLI script with minimal arguments v3.\"\"\" tdir = build ( struct , start , stop ) args = [ tdir , \"--meta-version\" , \"3\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_args_dir_v3()"},{"location":"tests/#tests.test_cli.test_cli_info_output_v1","text":"Test CLI output files contents with specific arguments v1. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"field\" , [ \"piece length\" , \"name\" , \"pieces\" , \"comment\" , \"private\" , \"source\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_info_output_v1 ( struct , field ): \"\"\"Test CLI output files contents with specific arguments v1.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta [ \"info\" ] # nosec rmpath ( parser . outfile )","title":"test_cli_info_output_v1()"},{"location":"tests/#tests.test_cli.test_cli_info_output_v2_3","text":"Test CLI output file info dict meta versions 2 & 3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"version\" , [ 2 , 3 ]) @pytest . mark . parametrize ( \"field\" , [ \"piece length\" , \"name\" , \"file tree\" , \"comment\" , \"private\" , \"source\" , \"meta version\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_info_output_v2_3 ( struct , field , version ): \"\"\"Test CLI output file info dict meta versions 2 & 3.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , str ( version ), \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta [ \"info\" ] # nosec rmpath ( parser . outfile )","title":"test_cli_info_output_v2_3()"},{"location":"tests/#tests.test_cli.test_cli_meta_output_v1","text":"Test CLI output v1 file meta dict specific arguments. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"field\" , [ \"announce\" , \"created by\" , \"creation date\" , \"info\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_meta_output_v1 ( struct , field ): \"\"\"Test CLI output v1 file meta dict specific arguments.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta # nosec rmpath ( parser . outfile )","title":"test_cli_meta_output_v1()"},{"location":"tests/#tests.test_cli.test_cli_meta_output_v2_3","text":"Test CLI output torrentfile meta dict fields v2 and hybrid. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"version\" , [ 2 , 3 ]) @pytest . mark . parametrize ( \"field\" , [ \"announce\" , \"announce list\" , \"piece layers\" , \"created by\" , \"info\" , \"creation date\" ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_cli_meta_output_v2_3 ( struct , field , version ): \"\"\"Test CLI output torrentfile meta dict fields v2 and hybrid.\"\"\" tdir = build ( struct ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , str ( version ), \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"https://tracker2-url.com/announce\" , \"https://tracker3-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () meta = pyben . load ( parser . outfile ) assert field in meta # nosec rmpath ( parser . outfile )","title":"test_cli_meta_output_v2_3()"},{"location":"tests/#tests.test_cli.test_cli_no_args","text":"Test CLI script with no arguments. Source code in tests\\test_cli.py def test_cli_no_args (): \"\"\"Test CLI script with no arguments.\"\"\" sys . argv = [ sys . argv [ 0 ]] try : main () except SystemExit : assert True # nosec","title":"test_cli_no_args()"},{"location":"tests/#tests.test_cli.test_cli_with_all_args_dir","text":"Test CLI script with other specific arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_dir ( struct , start , stop ): \"\"\"Test CLI script with other specific arguments v3.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"3\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 15 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_with_all_args_dir()"},{"location":"tests/#tests.test_cli.test_cli_with_all_args_v2","text":"Test CLI script with all arguments v2. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_v2 ( struct , start , stop ): \"\"\"Test CLI script with all arguments v2.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"2\" , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile )","title":"test_cli_with_all_args_v2()"},{"location":"tests/#tests.test_cli.test_cli_with_all_args_v3","text":"Test CLI script with all arguments v3. Source code in tests\\test_cli.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 19 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 19 , 23 ))) def test_cli_with_all_args_v3 ( struct , start , stop ): \"\"\"Test CLI script with all arguments v3.\"\"\" tdir = build ( struct , start , stop ) sys . argv = [ \"torrentfile\" , tdir , \"--meta-version\" , \"3\" , \"-d\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 16 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main_script () assert os . path . exists ( parser . outfile ) # nosec rmpath ( parser . outfile ) Test functions for utils module.","title":"test_cli_with_all_args_v3()"},{"location":"tests/#tests.test_utils.tdir","text":"Return temporary directory. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir ( request ): \"\"\"Return temporary directory.\"\"\" drct = build ( request . param ) yield drct rmpath ( drct )","title":"tdir()"},{"location":"tests/#tests.test_utils.test_filelist_total_dir_files","text":"Test Utility function filelist_total number of files. Source code in tests\\test_utils.py def test_filelist_total_dir_files ( tdir ): \"\"\"Test Utility function filelist_total number of files.\"\"\" _ , filelist = utils . filelist_total ( tdir ) assert len ( filelist ) > 0 # nosec","title":"test_filelist_total_dir_files()"},{"location":"tests/#tests.test_utils.test_filelist_total_len_tfile","text":"Test Utility function filelist_total length for single. Source code in tests\\test_utils.py def test_filelist_total_len_tfile ( tfile ): \"\"\"Test Utility function filelist_total length for single.\"\"\" _ , filelist = utils . filelist_total ( tfile ) assert len ( filelist ) == 1 # nosec","title":"test_filelist_total_len_tfile()"},{"location":"tests/#tests.test_utils.test_filelist_total_size_tfile","text":"Test Utility function filelist_total total bytes. Source code in tests\\test_utils.py def test_filelist_total_size_tfile ( tfile ): \"\"\"Test Utility function filelist_total total bytes.\"\"\" size , _ = utils . filelist_total ( tfile ) assert os . path . getsize ( tfile ) == size # nosec","title":"test_filelist_total_size_tfile()"},{"location":"tests/#tests.test_utils.test_filelist_total_tdir_sum","text":"Test Utility function filelist_total sum total all files. Source code in tests\\test_utils.py def test_filelist_total_tdir_sum ( tdir ): \"\"\"Test Utility function filelist_total sum total all files.\"\"\" size , filelist = utils . filelist_total ( tdir ) assert sum ([ os . path . getsize ( fd ) for fd in filelist ]) == size # nosec","title":"test_filelist_total_tdir_sum()"},{"location":"tests/#tests.test_utils.test_filelist_total_tfile","text":"Test Utility function filelist_total on single file. Source code in tests\\test_utils.py def test_filelist_total_tfile ( tfile ): \"\"\"Test Utility function filelist_total on single file.\"\"\" _ , filelist = utils . filelist_total ( tfile ) assert filelist [ 0 ] == tfile # nosec","title":"test_filelist_total_tfile()"},{"location":"tests/#tests.test_utils.test_get_filelist_tdir","text":"Test get_file_list function. Source code in tests\\test_utils.py def test_get_filelist_tdir ( tdir ): \"\"\"Test get_file_list function.\"\"\" result = utils . get_file_list ( tdir ) assert len ( result ) >= 1 # nosec","title":"test_get_filelist_tdir()"},{"location":"tests/#tests.test_utils.test_get_filelist_tfile","text":"Test get_file_list function. Source code in tests\\test_utils.py def test_get_filelist_tfile ( tfile ): \"\"\"Test get_file_list function.\"\"\" result = utils . get_file_list ( tfile ) assert len ( result ) == 1 # nosec","title":"test_get_filelist_tfile()"},{"location":"tests/#tests.test_utils.test_get_piece_len","text":"Test get_piece_length function does not exceed max. Source code in tests\\test_utils.py def test_get_piece_len ( tfile ): \"\"\"Test get_piece_length function does not exceed max.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result <= MAX_BLOCK # nosec","title":"test_get_piece_len()"},{"location":"tests/#tests.test_utils.test_get_piece_len_large","text":"Test get_piece_length function does not exceed maximum. Source code in tests\\test_utils.py def test_get_piece_len_large (): \"\"\"Test get_piece_length function does not exceed maximum.\"\"\" size = 2 ** 31 result = utils . get_piece_length ( size ) assert result <= MAX_BLOCK # nosec","title":"test_get_piece_len_large()"},{"location":"tests/#tests.test_utils.test_get_piece_len_power_2","text":"Test get_piece_length function is a power of 2. Source code in tests\\test_utils.py def test_get_piece_len_power_2 ( tfile ): \"\"\"Test get_piece_length function is a power of 2.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result % MIN_BLOCK == 0 # nosec","title":"test_get_piece_len_power_2()"},{"location":"tests/#tests.test_utils.test_get_piece_length_min","text":"Test get_piece_length function does not fall under minimum. Source code in tests\\test_utils.py def test_get_piece_length_min ( tfile ): \"\"\"Test get_piece_length function does not fall under minimum.\"\"\" size = os . path . getsize ( tfile ) result = utils . get_piece_length ( size ) assert result >= MIN_BLOCK # nosec","title":"test_get_piece_length_min()"},{"location":"tests/#tests.test_utils.test_normalize_plength_fails","text":"Test to ensure incorrect piece length values fail. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 10 , 1 , 4425631 , 35 , \"1111\" , \"abc\" ]) def test_normalize_plength_fails ( piece_length ): \"\"\"Test to ensure incorrect piece length values fail.\"\"\" try : utils . normalize_piece_length ( piece_length ) except utils . PieceLengthValueError : assert True # nosec","title":"test_normalize_plength_fails()"},{"location":"tests/#tests.test_utils.test_normalize_plength_type","text":"Test normalize piece length function output type. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 14 , 20 , 2 ** 15 , 2 ** 19 , \"22\" , \"21\" ]) def test_normalize_plength_type ( piece_length ): \"\"\"Test normalize piece length function output type.\"\"\" value = utils . normalize_piece_length ( piece_length ) assert isinstance ( value , int ) # nosec","title":"test_normalize_plength_type()"},{"location":"tests/#tests.test_utils.test_normalize_plength_value","text":"Test normalize piece length output perfect power of 2. Source code in tests\\test_utils.py @pytest . mark . parametrize ( \"piece_length\" , [ 14 , 20 , 2 ** 15 , 2 ** 19 , \"22\" , \"21\" ]) def test_normalize_plength_value ( piece_length ): \"\"\"Test normalize piece length output perfect power of 2.\"\"\" value = utils . normalize_piece_length ( piece_length ) log = math . log2 ( value ) assert int ( log ) == log # nosec","title":"test_normalize_plength_value()"},{"location":"tests/#tests.test_utils.test_path_piece_length_max","text":"Test path_piece_length for dir return piece_length < Maximum. Source code in tests\\test_utils.py def test_path_piece_length_max ( tdir ): \"\"\"Test path_piece_length for dir return piece_length < Maximum.\"\"\" result = utils . path_piece_length ( tdir ) assert result <= MAX_BLOCK # nosec","title":"test_path_piece_length_max()"},{"location":"tests/#tests.test_utils.test_path_piece_length_min","text":"Test path_piece_length for dir return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_min ( tdir ): \"\"\"Test path_piece_length for dir return piece_length is power of 2.\"\"\" result = utils . path_piece_length ( tdir ) assert result >= MIN_BLOCK # nosec","title":"test_path_piece_length_min()"},{"location":"tests/#tests.test_utils.test_path_piece_length_pow2","text":"Test path_piece_length for file return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_pow2 ( tdir ): \"\"\"Test path_piece_length for file return piece_length is power of 2.\"\"\" result = utils . path_piece_length ( tdir ) assert result % MIN_BLOCK == 0 # nosec","title":"test_path_piece_length_pow2()"},{"location":"tests/#tests.test_utils.test_path_size_file","text":"Test path_size function for tempfile. Source code in tests\\test_utils.py def test_path_size_file ( tfile ): \"\"\"Test path_size function for tempfile.\"\"\" size = os . path . getsize ( tfile ) val = utils . path_size ( tfile ) assert size == val # nosec","title":"test_path_size_file()"},{"location":"tests/#tests.test_utils.test_path_size_file_gt0","text":"Test path_size function for tempfile is greater than zero. Source code in tests\\test_utils.py def test_path_size_file_gt0 ( tfile ): \"\"\"Test path_size function for tempfile is greater than zero.\"\"\" val = utils . path_size ( tfile ) assert val > 0 # nosec","title":"test_path_size_file_gt0()"},{"location":"tests/#tests.test_utils.test_path_stat_base2_plen","text":"Test path_stat function return piece length is power of 2. Source code in tests\\test_utils.py def test_path_stat_base2_plen ( tdir ): \"\"\"Test path_stat function return piece length is power of 2.\"\"\" _ , _ , piece_length = utils . path_stat ( tdir ) assert piece_length % MIN_BLOCK == 0 # nosec","title":"test_path_stat_base2_plen()"},{"location":"tests/#tests.test_utils.test_path_stat_eq_filelist","text":"Test path_stat function return filelist. Source code in tests\\test_utils.py def test_path_stat_eq_filelist ( tdir ): \"\"\"Test path_stat function return filelist.\"\"\" filelist , _ , _ = utils . path_stat ( tdir ) assert len ( filelist ) >= 1 # nosec","title":"test_path_stat_eq_filelist()"},{"location":"tests/#tests.test_utils.test_path_stat_eq_size","text":"Test path_stat function return identically correct size. Source code in tests\\test_utils.py def test_path_stat_eq_size ( tdir ): \"\"\"Test path_stat function return identically correct size.\"\"\" filelist , size , _ = utils . path_stat ( tdir ) assert size == sum ([ os . path . getsize ( x ) for x in filelist ]) # nosec","title":"test_path_stat_eq_size()"},{"location":"tests/#tests.test_utils.test_path_stat_gt0_filelist","text":"Test path_stat function for tempdir1 sorted > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_filelist ( tdir ): \"\"\"Test path_stat function for tempdir1 sorted > 0.\"\"\" filelist , _ , _ = utils . path_stat ( tdir ) assert len ( filelist ) > 0 # nosec","title":"test_path_stat_gt0_filelist()"},{"location":"tests/#tests.test_utils.test_path_stat_gt0_plen","text":"Test path_stat function return piece length > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_plen ( tdir ): \"\"\"Test path_stat function return piece length > 0.\"\"\" _ , _ , piece_length = utils . path_stat ( tdir ) assert piece_length >= MIN_BLOCK # nosec","title":"test_path_stat_gt0_plen()"},{"location":"tests/#tests.test_utils.test_path_stat_gt0_size","text":"Test path_stat function return size > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_size ( tdir ): \"\"\"Test path_stat function return size > 0.\"\"\" _ , size , _ = utils . path_stat ( tdir ) assert size > 0 # nosec","title":"test_path_stat_gt0_size()"},{"location":"tests/#tests.test_utils.test_path_stat_gtsize_plen","text":"Test path_stat function return size > piece length. Source code in tests\\test_utils.py def test_path_stat_gtsize_plen ( tdir ): \"\"\"Test path_stat function return size > piece length.\"\"\" _ , size , piece_length = utils . path_stat ( tdir ) assert size > piece_length # nosec","title":"test_path_stat_gtsize_plen()"},{"location":"tests/#tests.test_utils.tfile","text":"Return temporary file. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temporary file.\"\"\" tle = testfile () yield tle rmpath ( tle ) Testing functions for torrentfile module.","title":"tfile()"},{"location":"tests/#tests.test_torrentfile.maketorrent","text":"Torrent making factory. Source code in tests\\test_torrentfile.py def maketorrent ( args , v = None ): \"\"\"Torrent making factory.\"\"\" if v not in [ 2 , 3 ]: torrent = TorrentFile ( ** args ) elif v == 2 : torrent = TorrentFileV2 ( ** args ) elif v == 3 : torrent = TorrentFileHybrid ( ** args ) torrent . assemble () return torrent . write ()","title":"maketorrent()"},{"location":"tests/#tests.test_torrentfile.metav1d","text":"Return generated metadata v1 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav1d ( tdir ): \"\"\"Return generated metadata v1 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args ) yield outfile , meta rmpath ([ tdir , outfile ])","title":"metav1d()"},{"location":"tests/#tests.test_torrentfile.metav2d","text":"Return generated metadata v2 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav2d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , v = 2 ) yield outfile , meta rmpath ([ tdir , outfile ])","title":"metav2d()"},{"location":"tests/#tests.test_torrentfile.metav3d","text":"Return generated metadata v2 for directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def metav3d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , v = 3 ) yield outfile , meta rmpath ([ tdir , outfile ])","title":"metav3d()"},{"location":"tests/#tests.test_torrentfile.smallfile","text":"Generate Sized file a tiny bit larger than BLOCK_SIZE. Source code in tests\\test_torrentfile.py @pytest . fixture def smallfile (): \"\"\"Generate Sized file a tiny bit larger than BLOCK_SIZE.\"\"\" path = testfile ( exp = 14 ) with open ( path , \"ab\" ) as fd : fd . write ( b \"000000000000000\" ) yield path rmpath ( path )","title":"smallfile()"},{"location":"tests/#tests.test_torrentfile.tdir","text":"Return temp directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir ( request ): \"\"\"Return temp directory.\"\"\" return build ( request . param )","title":"tdir()"},{"location":"tests/#tests.test_torrentfile.tdir1","text":"Return temporary directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" , params = Temp . structs ) def tdir1 ( request ): \"\"\"Return temporary directory.\"\"\" folder = build ( request . param ) args = { \"path\" : folder , \"announce\" : \"https://tracker.com/announce\" } yield folder , args rmpath ( folder )","title":"tdir1()"},{"location":"tests/#tests.test_torrentfile.test_exception_path_error","text":"Test MissingPathError exception. Source code in tests\\test_torrentfile.py def test_exception_path_error (): \"\"\"Test MissingPathError exception.\"\"\" try : raise utils . MissingPathError ( \"this is a message\" ) except utils . MissingPathError : assert True # nosec","title":"test_exception_path_error()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_0_length","text":"Test Hybrid with zero length file. Source code in tests\\test_torrentfile.py def test_hybrid_0_length (): \"\"\"Test Hybrid with zero length file.\"\"\" path = Path ( Temp . root ) / \"empty\" path . touch () args = { \"path\" : str ( path ), \"announce\" : \"announce\" , } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"announce\" ] == \"announce\" # nosec torrent . write () torpath = path . with_suffix ( \".torrent\" ) assert os . path . exists ( torpath ) # nosec rmpath ([ path , torpath ])","title":"test_hybrid_0_length()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_outfile","text":"Test Hybrid class with output as argument. Source code in tests\\test_torrentfile.py def test_hybrid_outfile ( tdir1 ): \"\"\"Test Hybrid class with output as argument.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFileHybrid ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_hybrid_outfile()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_sized_file","text":"Test pad_remaining function in hybrid FileHash class. Source code in tests\\test_torrentfile.py def test_hybrid_sized_file ( smallfile ): \"\"\"Test pad_remaining function in hybrid FileHash class.\"\"\" args = { \"path\" : smallfile , \"announce\" : \"announce\" , \"piece_length\" : 15 } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"announce\" ] == args [ \"announce\" ] # nosec assert torrent . meta [ \"info\" ][ \"piece length\" ] == 2 ** 15 # nosec","title":"test_hybrid_sized_file()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_under_block_sized","text":"Test pad_remaining function in hybrid FileHash class. Source code in tests\\test_torrentfile.py def test_hybrid_under_block_sized (): \"\"\"Test pad_remaining function in hybrid FileHash class.\"\"\" smallest = os . path . join ( Temp . root , \"smallest\" ) with open ( smallest , \"wb\" ) as fd : letters = b \"abcdefghijklmnopqrstuvwxyzABZDEFGHIJKLMNOPQRSTUVWXYZ\" size = len ( letters ) while size < 16000 : fd . write ( letters ) size += len ( letters ) args = { \"path\" : smallest , \"piece_length\" : 2 ** 14 } torrent = TorrentFileHybrid ( ** args ) assert torrent . meta [ \"info\" ][ \"piece length\" ] == 2 ** 14 # nosec rmpath ( smallest )","title":"test_hybrid_under_block_sized()"},{"location":"tests/#tests.test_torrentfile.test_hybrid_with_outfile","text":"Test Hybrid class with output in kwargs. Source code in tests\\test_torrentfile.py def test_hybrid_with_outfile ( tdir1 ): \"\"\"Test Hybrid class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFileHybrid ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_hybrid_with_outfile()"},{"location":"tests/#tests.test_torrentfile.test_meta_no_args_v1","text":"Test construct TorrentFile with no arguments. Source code in tests\\test_torrentfile.py def test_meta_no_args_v1 (): \"\"\"Test construct TorrentFile with no arguments.\"\"\" try : assert TorrentFile ( announce = \"url\" ) # nosec except utils . MissingPathError : assert True # nosec","title":"test_meta_no_args_v1()"},{"location":"tests/#tests.test_torrentfile.test_meta_no_args_v2","text":"Test construct TorrentFileV2 with no arguments. Source code in tests\\test_torrentfile.py def test_meta_no_args_v2 (): \"\"\"Test construct TorrentFileV2 with no arguments.\"\"\" try : assert TorrentFileV2 ( private = True ) # nosec except utils . MissingPathError : assert True # nosec","title":"test_meta_no_args_v2()"},{"location":"tests/#tests.test_torrentfile.test_metafile_assemble","text":"Test MetaFile assemble file Exception. Source code in tests\\test_torrentfile.py def test_metafile_assemble ( tdir1 ): \"\"\"Test MetaFile assemble file Exception.\"\"\" fd , args = tdir1 meta = MetaFile ( ** args ) try : meta . assemble () except NotImplementedError : assert True # nosec rmpath ( fd )","title":"test_metafile_assemble()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_dir","text":"Test temporary directory. Source code in tests\\test_torrentfile.py def test_torrentfile_dir ( tdir1 ): \"\"\"Test temporary directory.\"\"\" _ , args = tdir1 torrent = TorrentFile ( ** args ) assert torrent . meta is not None # nosec","title":"test_torrentfile_dir()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_dir_comment","text":"Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_comment ( tdir1 ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir1 args [ \"private\" ] = True args [ \"comment\" ] = \"This is a comment\" torrent = TorrentFile ( ** args ) meta = torrent . meta assert \"private\" in meta [ \"info\" ] and \"comment\" in meta [ \"info\" ] # nosec","title":"test_torrentfile_dir_comment()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_dir_private","text":"Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_private ( tdir1 ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir1 args [ \"private\" ] = True args [ \"piece_length\" ] = 1048576 torrent = TorrentFile ( ** args ) meta = torrent . meta assert \"private\" in meta [ \"info\" ] # nosec","title":"test_torrentfile_dir_private()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_with_outfile","text":"Test TorrentFile class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfile_with_outfile ( tdir1 ): \"\"\"Test TorrentFile class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFile ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_torrentfile_with_outfile()"},{"location":"tests/#tests.test_torrentfile.test_torrentfile_write_outfile","text":"Test TorrentFile class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfile_write_outfile ( tdir1 ): \"\"\"Test TorrentFile class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFile ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_torrentfile_write_outfile()"},{"location":"tests/#tests.test_torrentfile.test_torrentfilev2_outfile","text":"Test TorrentFile2 class with output as argument. Source code in tests\\test_torrentfile.py def test_torrentfilev2_outfile ( tdir1 ): \"\"\"Test TorrentFile2 class with output as argument.\"\"\" path , args = tdir1 outfile = path + \".torrent\" torrent = TorrentFileV2 ( ** args ) torrent . write ( outfile = outfile ) assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_torrentfilev2_outfile()"},{"location":"tests/#tests.test_torrentfile.test_torrentfilev2_with_outfile","text":"Test TorrentFileV2 class with output in kwargs. Source code in tests\\test_torrentfile.py def test_torrentfilev2_with_outfile ( tdir1 ): \"\"\"Test TorrentFileV2 class with output in kwargs.\"\"\" path , args = tdir1 outfile = path + \".torrent\" args [ \"outfile\" ] = outfile torrent = TorrentFileV2 ( ** args ) torrent . write () assert os . path . exists ( outfile ) # nosec rmpath ( outfile )","title":"test_torrentfilev2_with_outfile()"},{"location":"tests/#tests.test_torrentfile.test_v1_info_keys_dir","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"name\" , \"private\" , \"source\" , \"comment\" , \"pieces\" ]) def test_v1_info_keys_dir ( metav1d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v1_info_keys_dir()"},{"location":"tests/#tests.test_torrentfile.test_v1_meta_keys","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"announce\" , \"info\" , \"creation date\" , \"created by\" ]) def test_v1_meta_keys ( metav1d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d assert key in meta # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v1_meta_keys()"},{"location":"tests/#tests.test_torrentfile.test_v2_0_length","text":"Test TorrentFileV2 with zero length file. Source code in tests\\test_torrentfile.py def test_v2_0_length (): \"\"\"Test TorrentFileV2 with zero length file.\"\"\" path = Path ( Temp . root ) / \"empty\" path . touch () args = { \"path\" : str ( path ), \"announce\" : \"announce\" , } torrent = TorrentFileV2 ( ** args ) torrent . write () torpath = path . with_suffix ( \".torrent\" ) assert os . path . exists ( torpath ) # nosec rmpath ([ path , torpath ])","title":"test_v2_0_length()"},{"location":"tests/#tests.test_torrentfile.test_v2_info_keys_dir","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" ]) def test_v2_info_keys_dir ( metav2d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v2_info_keys_dir()"},{"location":"tests/#tests.test_torrentfile.test_v2_meta_keys","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" , \"created by\" ]) def test_v2_meta_keys ( metav2d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d assert key in meta # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v2_meta_keys()"},{"location":"tests/#tests.test_torrentfile.test_v3_info_keys_dir","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'field' , [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" ]) def test_v3_info_keys_dir ( metav3d , field ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert field in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v3_info_keys_dir()"},{"location":"tests/#tests.test_torrentfile.test_v3_info_keys_pieces","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'key' , [ \"piece length\" , \"name\" , \"private\" , \"source\" , \"comment\" , \"pieces\" ]) def test_v3_info_keys_pieces ( metav3d , key ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v3_info_keys_pieces()"},{"location":"tests/#tests.test_torrentfile.test_v3_meta_keys","text":"Test metadata. Source code in tests\\test_torrentfile.py @pytest . mark . parametrize ( 'field' , [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" , \"created by\" ]) def test_v3_meta_keys ( metav3d , field ): \"\"\"Test metadata.\"\"\" outfile , meta = metav3d assert field in meta # nosec assert os . path . exists ( outfile ) # nosec Test main module functionality.","title":"test_v3_meta_keys()"},{"location":"tests/#tests.test_main.test_class_annlist_v2","text":"Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_annlist_v2()"},{"location":"tests/#tests.test_main.test_class_list_annlist","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : [ \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_list_annlist()"},{"location":"tests/#tests.test_main.test_class_list_annlist_v2","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : [ \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_list_annlist_v2()"},{"location":"tests/#tests.test_main.test_class_single_file_small","text":"Test when single file is slightly larger than piece length. Source code in tests\\test_main.py @pytest . mark . parametrize ( \"hasher\" , [ TorrentFileV2 , TorrentFileHybrid ]) def test_class_single_file_small ( hasher ): \"\"\"Test when single file is slightly larger than piece length.\"\"\" path = testfile ( exp = 15 ) with open ( path , \"ab\" ) as binfile : binfile . write (( Temp . seq * 2 ) . encode ( \"utf-8\" )) args = { \"path\" : path , \"piece_length\" : 15 , \"source\" : \"example1\" } torrent = hasher ( ** args ) tpath , _ = torrent . write () assert os . path . exists ( tpath ) # nosec","title":"test_class_single_file_small()"},{"location":"tests/#tests.test_main.test_class_tuple_annlist","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker3/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_tuple_annlist()"},{"location":"tests/#tests.test_main.test_class_tuple_annlist_v2","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFileV2 ( ** kwargs ) url = \"https://tracker2/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_tuple_annlist_v2()"},{"location":"tests/#tests.test_main.test_class_with_annlist","text":"Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_with_annlist ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"path\" : path , \"announce\" : ( \"https://tracker1.to/announce\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker3/announce\" announce_list = torrent . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_class_with_annlist()"},{"location":"tests/#tests.test_main.test_main_annlist_single","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_main_annlist_single()"},{"location":"tests/#tests.test_main.test_main_annlist_single_v1","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v1 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"1\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single_v1()"},{"location":"tests/#tests.test_main.test_main_annlist_single_v2","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"2\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single_v2()"},{"location":"tests/#tests.test_main.test_main_annlist_single_v3","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"--meta-version\" , \"3\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single_v3()"},{"location":"tests/#tests.test_main.test_main_annlist_v2","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"2\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"announce\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_v2()"},{"location":"tests/#tests.test_main.test_main_annlist_v3","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"3\" , ] sys . argv . insert ( 1 , path ) parser = main () url = \"https://tracker4/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_main_annlist_v3()"},{"location":"tests/#tests.test_main.test_main_announce_list","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_announce_list ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ path , \"-a\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ] parser = main () url = \"https://tracker4/announce\" announce_list = parser . meta [ \"announce list\" ] seq = [ item for sub in announce_list for item in sub ] assert url in seq # nosec","title":"test_main_announce_list()"},{"location":"tests/#tests.test_main.test_main_func","text":"Test main script function. Source code in tests\\test_main.py def test_main_func ( tfile ): \"\"\"Test main script function.\"\"\" args , path = tfile opath = os . path . join ( Temp . root , \"test.torrent\" ) sys . argv = args + [ path , \"-o\" , opath ] main () assert os . path . exists ( opath ) # nosec rmpath ( opath )","title":"test_main_func()"},{"location":"tests/#tests.test_main.tfile","text":"Create fixture for tests. Source code in tests\\test_main.py @pytest . fixture ( scope = \"module\" , params = list ( range ( 14 , 26 ))) def tfile ( request ): \"\"\"Create fixture for tests.\"\"\" args = [ \"torrentfile\" , \"--private\" , \"--announce\" , \"https://tracker1.to/announce\" , \"--source\" , \"TFile\" , ] t_file = testfile ( exp = request . param ) yield args , t_file rmpath ( t_file ) Testing functions for the progress module.","title":"tfile()"},{"location":"tests/#tests.test_progress.mktorrent","text":"Compile bittorrent meta file. Source code in tests\\test_progress.py def mktorrent ( args , v = None ): \"\"\"Compile bittorrent meta file.\"\"\" if v == 3 : torrent = TorrentFileHybrid ( ** args ) elif v == 2 : torrent = TorrentFileV2 ( ** args ) else : torrent = TorrentFile ( ** args ) base = os . path . basename ( args [ 'path' ]) name = f \" { base } . { v } .torrent\" outfile = os . path . join ( Temp . root , name ) torrent . write ( outfile ) return outfile","title":"mktorrent()"},{"location":"tests/#tests.test_progress.struct1","text":"Return single struct list. Source code in tests\\test_progress.py @pytest . fixture def struct1 (): \"\"\"Return single struct list.\"\"\" path = build ( Temp . structs [ 1 ]) return path","title":"struct1()"},{"location":"tests/#tests.test_progress.test_checker_class","text":"Test Checker Class against meta files. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class ( struct , version ): \"\"\"Test Checker Class against meta files.\"\"\" path = build ( struct ) args = { \"path\" : path , \"announce\" : \"https://announce.com/announce\" } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) assert checker . result == \"100\" # nosec rmpath ([ outfile , path ])","title":"test_checker_class()"},{"location":"tests/#tests.test_progress.test_checker_class_allfiles","text":"Test Checker class when all files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_allfiles ( version , struct ): \"\"\"Test Checker class when all files are missing from contents.\"\"\" path = Path ( build ( struct )) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) def traverse ( path ): \"\"\"Traverse internal subdirectories.\"\"\" if path . is_file (): rmpath ( path ) elif path . is_dir (): for item in path . iterdir (): traverse ( item ) traverse ( path ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec rmpath ( outfile ) Temp . rmdirs ()","title":"test_checker_class_allfiles()"},{"location":"tests/#tests.test_progress.test_checker_class_allpaths","text":"Test Checker class when all files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_class_allpaths ( version , struct ): \"\"\"Test Checker class when all files are missing from contents.\"\"\" path = Path ( build ( struct )) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) for item in path . iterdir (): rmpath ( item ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec","title":"test_checker_class_allpaths()"},{"location":"tests/#tests.test_progress.test_checker_class_half_file","text":"Test Checker class with half size single file. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_half_file ( version ): \"\"\"Test Checker class with half size single file.\"\"\" path = testfile ( exp = 25 ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 15 } outfile = mktorrent ( args , v = version ) half = int (( 2 ** 25 ) / 2 ) barr = bytearray ( half ) with open ( path , \"rb\" ) as content : content . readinto ( barr ) with open ( path , \"wb\" ) as content : content . write ( barr ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec","title":"test_checker_class_half_file()"},{"location":"tests/#tests.test_progress.test_checker_class_missing","text":"Test Checker class when files are missing from contents. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_class_missing ( version , struct1 ): \"\"\"Test Checker class when files are missing from contents.\"\"\" path = struct1 args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 16 } outfile = mktorrent ( args , v = version ) rmpath ( os . path . join ( path , \"file1\" )) rmpath ( os . path . join ( path , \"file3\" )) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) < 100 # nosec","title":"test_checker_class_missing()"},{"location":"tests/#tests.test_progress.test_checker_cli_args","text":"Test exclusive Checker Mode CLI. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_cli_args ( struct , version ): \"\"\"Test exclusive Checker Mode CLI.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) sys . argv [ 1 :] = [ \"--re-check\" , outfile , t3dir ] output = main () assert output == \"100\" # nosec rmpath ( outfile ) Temp . rmdirs ()","title":"test_checker_cli_args()"},{"location":"tests/#tests.test_progress.test_checker_first_piece","text":"Test Checker Class when first piece is slightly alterred. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_first_piece ( struct , version ): \"\"\"Test Checker Class when first piece is slightly alterred.\"\"\" path = build ( struct ) args = { \"path\" : path , \"announce\" : \"https://announce.com/announce\" } outfile = mktorrent ( args , v = version ) def change ( path ): \"\"\"Change some bytes in file.\"\"\" if os . path . isfile ( path ): data = open ( path , \"rb\" ) . read () new = b 'some_different_bytes_to_swap' data = new + data [ len ( new ):] open ( path , \"wb\" ) . write ( data ) elif os . path . isdir ( path ): for item in os . listdir ( path ): change ( os . path . join ( path , item )) change ( path ) checker = CheckerClass ( outfile , path ) assert int ( checker . result ) != 100 # nosec rmpath ([ outfile , path ])","title":"test_checker_first_piece()"},{"location":"tests/#tests.test_progress.test_checker_no_content","text":"Test Checker class with directory that points to nothing. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_no_content ( struct , version ): \"\"\"Test Checker class with directory that points to nothing.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) CheckerClass . register_callback ( lambda * x : print ( x )) checker = CheckerClass ( outfile , t3dir ) assert checker . result == \"100\" # nosec rmpath ( outfile )","title":"test_checker_no_content()"},{"location":"tests/#tests.test_progress.test_checker_no_meta_file","text":"Test Checker when incorrect metafile is provided. Source code in tests\\test_progress.py def test_checker_no_meta_file (): \"\"\"Test Checker when incorrect metafile is provided.\"\"\" try : CheckerClass ( \"peaches\" , \"$\" ) except FileNotFoundError : assert True # nosec","title":"test_checker_no_meta_file()"},{"location":"tests/#tests.test_progress.test_checker_no_root_dir","text":"Test Checker when incorrect root directory is provided. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_no_root_dir ( struct ): \"\"\"Test Checker when incorrect root directory is provided.\"\"\" tdir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : tdir , \"private\" : 1 } outfile = mktorrent ( args , v = 1 ) try : CheckerClass ( outfile , \"peaches\" ) except FileNotFoundError : assert True # nosec rmpath ( outfile )","title":"test_checker_no_root_dir()"},{"location":"tests/#tests.test_progress.test_checker_parent_dir","text":"Test providing the parent directory for torrent checking feature. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_parent_dir ( struct , version ): \"\"\"Test providing the parent directory for torrent checking feature.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , os . path . dirname ( t3dir )) assert checker . result == \"100\" # nosec rmpath ( outfile ) Temp . rmdirs ()","title":"test_checker_parent_dir()"},{"location":"tests/#tests.test_progress.test_checker_result_property","text":"Test Checker class with half size single file. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_result_property ( version ): \"\"\"Test Checker class with half size single file.\"\"\" path = testfile ( exp = 20 ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 , \"piece_length\" : 2 ** 14 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) result = checker . result assert checker . result == result # nosec rmpath ( outfile )","title":"test_checker_result_property()"},{"location":"tests/#tests.test_progress.test_checker_with_file","text":"Test checker with single file torrent. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 26 ))) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_checker_with_file ( version , size ): \"\"\"Test checker with single file torrent.\"\"\" tfile = testfile ( exp = size ) args = { \"announce\" : \"announce\" , \"path\" : tfile , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , tfile ) assert checker . result == \"100\" # nosec rmpath ( outfile )","title":"test_checker_with_file()"},{"location":"tests/#tests.test_progress.test_checker_wrong_root_dir","text":"Test Checker when incorrect root directory is provided. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_checker_wrong_root_dir ( struct ): \"\"\"Test Checker when incorrect root directory is provided.\"\"\" tdir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : tdir , \"private\" : 1 } path = Path ( tdir ) newpath = path . parent / ( path . name + \"FAKE\" ) os . mkdir ( newpath ) newpath . touch ( newpath / \"file1\" ) outfile = mktorrent ( args , v = 1 ) try : CheckerClass ( outfile , str ( newpath )) except FileNotFoundError : assert True # nosec rmpath ( outfile ) rmpath ( newpath )","title":"test_checker_wrong_root_dir()"},{"location":"tests/#tests.test_progress.test_metafile_checker","text":"Test metadata checker class. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"struct\" , Temp . structs ) @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) def test_metafile_checker ( struct , version ): \"\"\"Test metadata checker class.\"\"\" path = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : path , \"private\" : 1 } outfile = mktorrent ( args , v = version ) checker = CheckerClass ( outfile , path ) assert checker . result == \"100\" # nosec rmpath ([ outfile , path ])","title":"test_metafile_checker()"},{"location":"tests/#tests.test_progress.test_partial_metafiles","text":"Test Checker with data that is expected to be incomplete. Source code in tests\\test_progress.py @pytest . mark . parametrize ( \"version\" , [ 1 , 2 , 3 ]) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_partial_metafiles ( struct , version ): \"\"\"Test Checker with data that is expected to be incomplete.\"\"\" t3dir = build ( struct ) args = { \"announce\" : \"announce\" , \"path\" : t3dir , \"private\" : 1 } outfile = mktorrent ( args , v = version ) def shortenfile ( path ): \"\"\"Shorten a few files for testing purposes.\"\"\" with open ( path , \"rb\" ) as bfile : data = bfile . read () with open ( path , \"wb\" ) as bfile : bfile . write ( data [: - 2 ** 12 ]) for item in os . listdir ( t3dir ): full = os . path . join ( t3dir , item ) if os . path . isfile ( full ): shortenfile ( full ) testdir = os . path . dirname ( t3dir ) checker = CheckerClass ( outfile , testdir ) assert checker . result != \"100\" # nosec rmpath ( outfile ) Testing operation and coverage for context module in tests directory.","title":"test_partial_metafiles()"},{"location":"tests/#tests.test_context.spaths","text":"Return a list of each file in all structs. Source code in tests\\test_context.py def spaths (): \"\"\"Return a list of each file in all structs.\"\"\" paths = [ j for i in Temp . structs for j in i ] return paths","title":"spaths()"},{"location":"tests/#tests.test_context.test_build_func","text":"Test testfile function result size from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"start\" , list ( range ( 14 , 20 ))) @pytest . mark . parametrize ( \"stop\" , list ( range ( 21 , 27 ))) @pytest . mark . parametrize ( \"struct\" , Temp . structs ) def test_build_func ( struct , start , stop ): \"\"\"Test testfile function result size from context module.\"\"\" root = build ( struct , start , stop ) assert os . path . exists ( root ) # nosec rmpath ( root )","title":"test_build_func()"},{"location":"tests/#tests.test_context.test_mkdirs","text":"Test mkdirs function from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"struct\" , spaths ()) def test_mkdirs ( struct ): \"\"\"Test mkdirs function from context module.\"\"\" fd = mkdirs ( struct ) assert os . path . exists ( os . path . dirname ( fd )) # nosec rmpath ( os . path . dirname ( fd ))","title":"test_mkdirs()"},{"location":"tests/#tests.test_context.test_rmpath","text":"Test rmpath function from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"struct\" , spaths ()) def test_rmpath ( struct ): \"\"\"Test rmpath function from context module.\"\"\" fd = os . path . dirname ( mkdirs ( struct )) rmpath ( fd ) assert not os . path . exists ( fd ) # nosec rmpath ( fd )","title":"test_rmpath()"},{"location":"tests/#tests.test_context.test_seq","text":"Test seq function for random string output. Source code in tests\\test_context.py def test_seq (): \"\"\"Test seq function for random string output.\"\"\" output = Temp . seq assert isinstance ( output , str ) # nosec","title":"test_seq()"},{"location":"tests/#tests.test_context.test_structs","text":"Test temp directory structures. Source code in tests\\test_context.py def test_structs (): \"\"\"Test temp directory structures.\"\"\" assert len ( Temp . structs ) == 3 # nosec","title":"test_structs()"},{"location":"tests/#tests.test_context.test_testfile_func","text":"Test testfile function result exists from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 27 ))) def test_testfile_func ( size ): \"\"\"Test testfile function result exists from context module.\"\"\" path = testfile ( exp = size ) assert os . path . exists ( path ) # nosec rmpath ( path )","title":"test_testfile_func()"},{"location":"tests/#tests.test_context.test_testfile_func1","text":"Test testfile function result size from context module. Source code in tests\\test_context.py @pytest . mark . parametrize ( \"size\" , list ( range ( 14 , 27 ))) def test_testfile_func1 ( size ): \"\"\"Test testfile function result size from context module.\"\"\" path = testfile ( exp = size ) assert os . path . getsize ( path ) == 2 ** size # nosec rmpath ( path )","title":"test_testfile_func1()"},{"location":"tests/#tests.test_context.test_xz_teardown","text":"Test teardown function from context module. Source code in tests\\test_context.py def test_xz_teardown (): \"\"\"Test teardown function from context module.\"\"\" teardown () assert not os . path . exists ( Temp . root ) # nosec os . mkdir ( Temp . root )","title":"test_xz_teardown()"},{"location":"torrent/","text":"Torrent Module Base and Subclasses for bittorrent meta files. This module metafile2 contains classes and functions related to constructing .torrent files using Bittorrent v2 Protocol !!! classes TorrentFile : construct .torrent file. TorrentFileV2 : construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes. !!! constants BLOCK_SIZE ( int ): size of leaf hashes for merkle tree. HASH_SIZE ( int ): Length of a sha256 hash. Notes Implementation details for Bittorrent Protocol v2. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' in this context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On most platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require valid UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in the same order as in the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key. From Bittorrent.org Documentation pages. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: announce The URL of the tracker. info This maps to a dictionary, with keys described below. All strings in a .torrent file that contains text must be UTF-8 encoded. info dictionary The name key maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length is almost always a power of two, most commonly 2 18 = 256 K (BitTorrent prior to version 3.2 uses 2 20 = 1 M as default). pieces maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. There is also a key length or a key files , but not both or neither. If length is present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. In the single file case, length maps to the length of the file in bytes. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: length - The length of the file, in bytes. path - A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name (a zero length list is an error case). In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory. MetaFile Base Class for all TorrentFile classes. Parameters: Name Type Description Default path `str` target path to torrent content. required announce `str` Tracker URL. required comment `str` A comment. required piece_length `int` Size of torrent pieces. required private `bool` For private trackers? required outfile `str` target path to write .torrent file. required source `str` Private tracker source. required __init__ ( self , path = None , announce = None , private = False , source = None , piece_length = None , comment = None , outfile = None ) special Construct MetaFile superclass and assign local attributes. Keyword parameters include path, announce, private, source, piece_length, comment, outfile. Source code in torrentfile\\torrent.py def __init__ ( self , path = None , announce = None , private = False , source = None , piece_length = None , comment = None , outfile = None ): \"\"\"Construct MetaFile superclass and assign local attributes. Keyword parameters include path, announce, private, source, piece_length, comment, outfile. \"\"\" if not path : raise utils . MissingPathError # base path to torrent content. self . path = path # Format piece_length attribute. if piece_length : self . piece_length = utils . normalize_piece_length ( piece_length ) else : self . piece_length = utils . path_piece_length ( self . path ) # Assign announce URL to empty string if none provided. if not announce : self . announce = \"\" self . announce_list = [[ \"\" ]] # Most torrent clients have editting trackers as a feature. elif isinstance ( announce , str ): self . announce = announce self . announce_list = [[ announce ]] elif isinstance ( announce , Sequence ): self . announce = announce [ 0 ] # if announce has more than 1 argumnt self . announce_list = [ announce ] if private : self . private = 1 else : self . private = private self . source = source self . comment = comment self . outfile = outfile self . meta = { \"announce\" : self . announce , \"announce list\" : self . announce_list , \"created by\" : f \"TorrentFile:v { version } \" , \"creation date\" : int ( datetime . timestamp ( datetime . now ())), \"info\" : {} } if self . comment : self . meta [ \"info\" ][ \"comment\" ] = self . comment if self . private : self . meta [ \"info\" ][ \"private\" ] = self . private if self . source : self . meta [ \"info\" ][ \"source\" ] = self . source self . meta [ \"info\" ][ \"name\" ] = os . path . basename ( self . path ) self . meta [ \"info\" ][ \"piece length\" ] = self . piece_length assemble ( self ) Overload in subclasses. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Overload in subclasses. Raises: NotImplementedError (`Exception`) \"\"\" raise NotImplementedError sort_meta ( self ) Sort the info and meta dictionaries. Source code in torrentfile\\torrent.py def sort_meta ( self ): \"\"\"Sort the info and meta dictionaries.\"\"\" meta = self . meta meta [ \"info\" ] = dict ( sorted ( list ( meta [ \"info\" ] . items ()))) meta = dict ( sorted ( list ( meta . items ()))) return meta write ( self , outfile = None ) Write meta information to .torrent file. Parameters: Name Type Description Default outfile `str`, default=None Destination path for .torrent file. None Returns: Type Description outfile (`str`) Where the .torrent file was writen. meta ( dict ): .torrent meta information. Source code in torrentfile\\torrent.py def write ( self , outfile = None ): \"\"\"Write meta information to .torrent file. Args: outfile (`str`, default=None): Destination path for .torrent file. Returns: outfile (`str`): Where the .torrent file was writen. meta (`dict`): .torrent meta information. \"\"\" if outfile is not None : self . outfile = outfile if self . outfile is None : self . outfile = self . path + \".torrent\" self . meta = self . sort_meta () pyben . dump ( self . meta , self . outfile ) return self . outfile , self . meta TorrentFile ( MetaFile ) Class for creating Bittorrent meta files. Construct Torrentfile class instance object. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str`) Tracker URL. required announce_list(`str` or `list` Additional Tracker URLs. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required __init__ ( self , ** kwargs ) special Construct TorrentFile class instance with given keyword args. Parameters: Name Type Description Default kwargs `dict` dictionary of keyword args passed to superclass. {} Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Construct TorrentFile class instance with given keyword args. Args: kwargs (`dict`): dictionary of keyword args passed to superclass. \"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Making Bittorrent V1 meta file.\" ) self . assemble () assemble ( self ) Assemble components of torrent metafile. Returns: Type Description `dict` metadata dictionary for torrent file Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble components of torrent metafile. Returns: `dict`: metadata dictionary for torrent file \"\"\" info = self . meta [ \"info\" ] size , filelist = utils . filelist_total ( self . path ) if os . path . isfile ( self . path ): info [ \"length\" ] = size else : info [ \"files\" ] = [ { \"length\" : os . path . getsize ( path ), \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } for path in filelist ] pieces = bytearray () feeder = Feeder ( filelist , self . piece_length , size ) for piece in feeder : pieces . extend ( piece ) info [ \"pieces\" ] = pieces TorrentFileHybrid ( MetaFile ) Construct the Hybrid torrent meta file with provided parameters. Parameters: Name Type Description Default path `str` path to torrentfile target. required announce `str` Tracker URL. required announce_list `list` Additional tracker URLs. required comment `str` Some comment. required source `str` Used for private trackers. required outfile `str` target path to write output. required private `bool` Used for private trackers. required piece_length `int` torrentfile data piece length. required __init__ ( self , ** kwargs ) special Create Bittorrent v1 v2 hybrid metafiles. Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Create Bittorrent v1 v2 hybrid metafiles.\"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Creating Hybrid torrent file.\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = [] self . files = [] self . assemble () assemble ( self ) Assemble the parts of the torrentfile into meta dictionary. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble the parts of the torrentfile into meta dictionary.\"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"files\" ] = self . files info [ \"pieces\" ] = b \"\" . join ( self . pieces ) self . meta [ \"piece layers\" ] = self . piece_layers return info TorrentFileV2 ( MetaFile ) Class for creating Bittorrent meta v2 files. Parameters: Name Type Description Default path `str` Path to torrent file or directory. required piece_length `int` Size of each piece of torrent data. required announce `str` Tracker URL. required announce_list 'list` List of additional trackers. required private `int` 1 if private torrent else 0. required source `str` Source tracker. required comment `str` Comment string. required outfile `str` Path to write metfile to. required __init__ ( self , ** kwargs ) special Construct TorrentFileV2 Class instance from given parameters. Parameters: Name Type Description Default kwargs `dict` keywword arguments to pass to superclass. {} Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Construct `TorrentFileV2` Class instance from given parameters. Args: kwargs (`dict`): keywword arguments to pass to superclass. \"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Create .torrent v2 file.\" ) self . piece_layers = {} self . hashes = [] self . assemble () assemble ( self ) Assemble then return the meta dictionary for encoding. Returns: Type Description meta (`dict`) Metainformation about the torrent. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble then return the meta dictionary for encoding. Returns: meta (`dict`): Metainformation about the torrent. \"\"\" logging . debug ( \"Continue filling meta dictionary for .torrent file.\" ) info = self . meta [ \"info\" ] if os . path . isfile ( self . path ): logging . debug ( \"'path' points to a single file.\" ) info [ \"file tree\" ] = { info [ \"name\" ]: self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : logging . debug ( \"'path' points to a directory.\" ) info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"meta version\" ] = 2 self . meta [ \"piece layers\" ] = self . piece_layers","title":"Torrent"},{"location":"torrent/#torrent-module","text":"Base and Subclasses for bittorrent meta files. This module metafile2 contains classes and functions related to constructing .torrent files using Bittorrent v2 Protocol !!! classes TorrentFile : construct .torrent file. TorrentFileV2 : construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes. !!! constants BLOCK_SIZE ( int ): size of leaf hashes for merkle tree. HASH_SIZE ( int ): Length of a sha256 hash.","title":"Torrent Module"},{"location":"torrent/#torrentfile.torrent--notes","text":"Implementation details for Bittorrent Protocol v2. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' in this context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On most platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require valid UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in the same order as in the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key. From Bittorrent.org Documentation pages. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: announce The URL of the tracker. info This maps to a dictionary, with keys described below. All strings in a .torrent file that contains text must be UTF-8 encoded.","title":"Notes"},{"location":"torrent/#torrentfile.torrent--info-dictionary","text":"The name key maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length is almost always a power of two, most commonly 2 18 = 256 K (BitTorrent prior to version 3.2 uses 2 20 = 1 M as default). pieces maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. There is also a key length or a key files , but not both or neither. If length is present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. In the single file case, length maps to the length of the file in bytes. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: length - The length of the file, in bytes. path - A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name (a zero length list is an error case). In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory.","title":"info dictionary"},{"location":"torrent/#torrentfile.torrent.MetaFile","text":"Base Class for all TorrentFile classes. Parameters: Name Type Description Default path `str` target path to torrent content. required announce `str` Tracker URL. required comment `str` A comment. required piece_length `int` Size of torrent pieces. required private `bool` For private trackers? required outfile `str` target path to write .torrent file. required source `str` Private tracker source. required","title":"MetaFile"},{"location":"torrent/#torrentfile.torrent.MetaFile.__init__","text":"Construct MetaFile superclass and assign local attributes. Keyword parameters include path, announce, private, source, piece_length, comment, outfile. Source code in torrentfile\\torrent.py def __init__ ( self , path = None , announce = None , private = False , source = None , piece_length = None , comment = None , outfile = None ): \"\"\"Construct MetaFile superclass and assign local attributes. Keyword parameters include path, announce, private, source, piece_length, comment, outfile. \"\"\" if not path : raise utils . MissingPathError # base path to torrent content. self . path = path # Format piece_length attribute. if piece_length : self . piece_length = utils . normalize_piece_length ( piece_length ) else : self . piece_length = utils . path_piece_length ( self . path ) # Assign announce URL to empty string if none provided. if not announce : self . announce = \"\" self . announce_list = [[ \"\" ]] # Most torrent clients have editting trackers as a feature. elif isinstance ( announce , str ): self . announce = announce self . announce_list = [[ announce ]] elif isinstance ( announce , Sequence ): self . announce = announce [ 0 ] # if announce has more than 1 argumnt self . announce_list = [ announce ] if private : self . private = 1 else : self . private = private self . source = source self . comment = comment self . outfile = outfile self . meta = { \"announce\" : self . announce , \"announce list\" : self . announce_list , \"created by\" : f \"TorrentFile:v { version } \" , \"creation date\" : int ( datetime . timestamp ( datetime . now ())), \"info\" : {} } if self . comment : self . meta [ \"info\" ][ \"comment\" ] = self . comment if self . private : self . meta [ \"info\" ][ \"private\" ] = self . private if self . source : self . meta [ \"info\" ][ \"source\" ] = self . source self . meta [ \"info\" ][ \"name\" ] = os . path . basename ( self . path ) self . meta [ \"info\" ][ \"piece length\" ] = self . piece_length","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.MetaFile.assemble","text":"Overload in subclasses. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Overload in subclasses. Raises: NotImplementedError (`Exception`) \"\"\" raise NotImplementedError","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.MetaFile.sort_meta","text":"Sort the info and meta dictionaries. Source code in torrentfile\\torrent.py def sort_meta ( self ): \"\"\"Sort the info and meta dictionaries.\"\"\" meta = self . meta meta [ \"info\" ] = dict ( sorted ( list ( meta [ \"info\" ] . items ()))) meta = dict ( sorted ( list ( meta . items ()))) return meta","title":"sort_meta()"},{"location":"torrent/#torrentfile.torrent.MetaFile.write","text":"Write meta information to .torrent file. Parameters: Name Type Description Default outfile `str`, default=None Destination path for .torrent file. None Returns: Type Description outfile (`str`) Where the .torrent file was writen. meta ( dict ): .torrent meta information. Source code in torrentfile\\torrent.py def write ( self , outfile = None ): \"\"\"Write meta information to .torrent file. Args: outfile (`str`, default=None): Destination path for .torrent file. Returns: outfile (`str`): Where the .torrent file was writen. meta (`dict`): .torrent meta information. \"\"\" if outfile is not None : self . outfile = outfile if self . outfile is None : self . outfile = self . path + \".torrent\" self . meta = self . sort_meta () pyben . dump ( self . meta , self . outfile ) return self . outfile , self . meta","title":"write()"},{"location":"torrent/#torrentfile.torrent.TorrentFile","text":"Class for creating Bittorrent meta files. Construct Torrentfile class instance object. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str`) Tracker URL. required announce_list(`str` or `list` Additional Tracker URLs. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required","title":"TorrentFile"},{"location":"torrent/#torrentfile.torrent.TorrentFile.__init__","text":"Construct TorrentFile class instance with given keyword args. Parameters: Name Type Description Default kwargs `dict` dictionary of keyword args passed to superclass. {} Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Construct TorrentFile class instance with given keyword args. Args: kwargs (`dict`): dictionary of keyword args passed to superclass. \"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Making Bittorrent V1 meta file.\" ) self . assemble ()","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentFile.assemble","text":"Assemble components of torrent metafile. Returns: Type Description `dict` metadata dictionary for torrent file Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble components of torrent metafile. Returns: `dict`: metadata dictionary for torrent file \"\"\" info = self . meta [ \"info\" ] size , filelist = utils . filelist_total ( self . path ) if os . path . isfile ( self . path ): info [ \"length\" ] = size else : info [ \"files\" ] = [ { \"length\" : os . path . getsize ( path ), \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } for path in filelist ] pieces = bytearray () feeder = Feeder ( filelist , self . piece_length , size ) for piece in feeder : pieces . extend ( piece ) info [ \"pieces\" ] = pieces","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid","text":"Construct the Hybrid torrent meta file with provided parameters. Parameters: Name Type Description Default path `str` path to torrentfile target. required announce `str` Tracker URL. required announce_list `list` Additional tracker URLs. required comment `str` Some comment. required source `str` Used for private trackers. required outfile `str` target path to write output. required private `bool` Used for private trackers. required piece_length `int` torrentfile data piece length. required","title":"TorrentFileHybrid"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid.__init__","text":"Create Bittorrent v1 v2 hybrid metafiles. Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Create Bittorrent v1 v2 hybrid metafiles.\"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Creating Hybrid torrent file.\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = [] self . files = [] self . assemble ()","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid.assemble","text":"Assemble the parts of the torrentfile into meta dictionary. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble the parts of the torrentfile into meta dictionary.\"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"files\" ] = self . files info [ \"pieces\" ] = b \"\" . join ( self . pieces ) self . meta [ \"piece layers\" ] = self . piece_layers return info","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2","text":"Class for creating Bittorrent meta v2 files. Parameters: Name Type Description Default path `str` Path to torrent file or directory. required piece_length `int` Size of each piece of torrent data. required announce `str` Tracker URL. required announce_list 'list` List of additional trackers. required private `int` 1 if private torrent else 0. required source `str` Source tracker. required comment `str` Comment string. required outfile `str` Path to write metfile to. required","title":"TorrentFileV2"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2.__init__","text":"Construct TorrentFileV2 Class instance from given parameters. Parameters: Name Type Description Default kwargs `dict` keywword arguments to pass to superclass. {} Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Construct `TorrentFileV2` Class instance from given parameters. Args: kwargs (`dict`): keywword arguments to pass to superclass. \"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Create .torrent v2 file.\" ) self . piece_layers = {} self . hashes = [] self . assemble ()","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2.assemble","text":"Assemble then return the meta dictionary for encoding. Returns: Type Description meta (`dict`) Metainformation about the torrent. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble then return the meta dictionary for encoding. Returns: meta (`dict`): Metainformation about the torrent. \"\"\" logging . debug ( \"Continue filling meta dictionary for .torrent file.\" ) info = self . meta [ \"info\" ] if os . path . isfile ( self . path ): logging . debug ( \"'path' points to a single file.\" ) info [ \"file tree\" ] = { info [ \"name\" ]: self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : logging . debug ( \"'path' points to a directory.\" ) info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"meta version\" ] = 2 self . meta [ \"piece layers\" ] = self . piece_layers","title":"assemble()"},{"location":"utils/","text":"Utils Utility functions and classes used throughout package. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory. MissingPathError ( Exception ) Path parameter is required to specify target content. Creating a .torrent file with no contents seems rather silly. Parameters: Name Type Description Default message `any` Message for user. required __init__ ( self , message = None ) special Raise when creating a meta file without specifying target content. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py def __init__ ( self , message = None ): \"\"\"Raise when creating a meta file without specifying target content. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Path arguement is missing and required { str ( message ) } \" super () . __init__ ( message ) PieceLengthValueError ( Exception ) Piece Length parameter must equal a perfect power of 2. Parameters: Name Type Description Default message `any` Message for user. required __init__ ( self , message = None ) special Raise when creating a meta file with incorrect piece length value. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py def __init__ ( self , message = None ): \"\"\"Raise when creating a meta file with incorrect piece length value. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Incorrect value for piece length: { str ( message ) } \" super () . __init__ ( message ) filelist_total ( path ) Search directory tree for files. Parameters: Name Type Description Default path `str` Path to file or directory base required sort `bool` Return list sorted. Defaults to False. required Returns: Type Description (`list`) All file paths within directory tree. Source code in torrentfile\\utils.py def filelist_total ( path ): \"\"\"Search directory tree for files. Args: path (`str`): Path to file or directory base sort (`bool`): Return list sorted. Defaults to False. Returns: (`list`): All file paths within directory tree. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) return file_size , [ path ] total = 0 filelist = [] if os . path . isdir ( path ): for _ , full in sortfiles ( path ): size , paths = filelist_total ( full ) total += size filelist . extend ( paths ) return total , filelist get_file_list ( path ) Return a sorted list of file paths contained in directory. Parameters: Name Type Description Default path `str` target file or directory. required Returns: Type Description filelist (`list`) sorted list of file paths. Source code in torrentfile\\utils.py def get_file_list ( path ): \"\"\"Return a sorted list of file paths contained in directory. Args: path (`str`): target file or directory. Returns: filelist (`list`): sorted list of file paths. \"\"\" _ , filelist = filelist_total ( path ) return filelist get_piece_length ( size ) Calculate the ideal piece length for bittorrent data. Parameters: Name Type Description Default size `int` Total bits of all files incluided in .torrent file. required Returns: Type Description piece_length (`int`) Ideal peace length size arguement. Source code in torrentfile\\utils.py def get_piece_length ( size ): \"\"\"Calculate the ideal piece length for bittorrent data. Args: size (`int`): Total bits of all files incluided in .torrent file. Returns: piece_length (`int`): Ideal peace length size arguement. \"\"\" exp = 14 while size / ( 2 ** exp ) > 200 and exp < 23 : exp += 1 return 2 ** exp normalize_piece_length ( piece_length ) Verify input piece_length is valid and convert accordingly. Parameters: Name Type Description Default piece_length `int` The piece length provided by user. required Returns: Type Description piece_length (`int`) normalized piece length. Exceptions: Type Description PieceLengthValueError If piece length is improper value. Source code in torrentfile\\utils.py def normalize_piece_length ( piece_length ): \"\"\"Verify input piece_length is valid and convert accordingly. Args: piece_length (`int`): The piece length provided by user. Returns: piece_length (`int`): normalized piece length. Raises: PieceLengthValueError: If piece length is improper value. \"\"\" if isinstance ( piece_length , str ): if piece_length . isnumeric (): piece_length = int ( piece_length ) else : raise PieceLengthValueError ( piece_length ) if 13 < piece_length < 26 : return 2 ** piece_length if piece_length <= 13 : raise PieceLengthValueError ( piece_length ) log = int ( math . log2 ( piece_length )) if 2 ** log == piece_length : return piece_length raise PieceLengthValueError path_piece_length ( path ) Calculate piece length for input path and contents. Parameters: Name Type Description Default path `str` The absolute path to directory and contents. required Returns: Type Description piece_length (`int`) The size of pieces of torrent content. Source code in torrentfile\\utils.py def path_piece_length ( path ): \"\"\"Calculate piece length for input path and contents. Args: path (`str`): The absolute path to directory and contents. Returns: piece_length (`int`): The size of pieces of torrent content. \"\"\" psize = path_size ( path ) return get_piece_length ( psize ) path_size ( path ) Return the total size of all files in path recursively. Parameters: Name Type Description Default path `str` path to target file or directory. required Returns: Type Description size (`int`) total size of files. Source code in torrentfile\\utils.py def path_size ( path ): \"\"\"Return the total size of all files in path recursively. Args: path (`str`): path to target file or directory. Returns: size (`int`): total size of files. \"\"\" total_size , _ = filelist_total ( path ) return total_size path_stat ( path ) Calculate directory statistics. Parameters: Name Type Description Default path `str` The path to start calculating from. required Returns: Type Description filelist (`list`) List of all files contained in Directory size ( int ): Total sum of bytes from all contents of dir piece_length ( int ): The size of pieces of the torrent contents. Source code in torrentfile\\utils.py def path_stat ( path ): \"\"\"Calculate directory statistics. Args: path (`str`): The path to start calculating from. Returns: filelist (`list`): List of all files contained in Directory size (`int`): Total sum of bytes from all contents of dir piece_length (`int`): The size of pieces of the torrent contents. \"\"\" total_size , filelist = filelist_total ( path ) piece_length = get_piece_length ( total_size ) return ( filelist , total_size , piece_length ) sortfiles ( path ) Sort entries in path. Parameters: Name Type Description Default path `str` Target directory for sorting contents. required !!! yields item, full ( str , str ): Next item in sorted order. Source code in torrentfile\\utils.py def sortfiles ( path ): \"\"\"Sort entries in path. Args: path (`str`): Target directory for sorting contents. Yields: item, full (`str`, `str`): Next item in sorted order. \"\"\" items = sorted ( os . listdir ( path ), key = str . lower ) for item in items : full = os . path . join ( path , item ) yield item , full","title":"Utils"},{"location":"utils/#utils","text":"Utility functions and classes used throughout package. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory.","title":"Utils"},{"location":"utils/#torrentfile.utils.MissingPathError","text":"Path parameter is required to specify target content. Creating a .torrent file with no contents seems rather silly. Parameters: Name Type Description Default message `any` Message for user. required","title":"MissingPathError"},{"location":"utils/#torrentfile.utils.MissingPathError.__init__","text":"Raise when creating a meta file without specifying target content. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py def __init__ ( self , message = None ): \"\"\"Raise when creating a meta file without specifying target content. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Path arguement is missing and required { str ( message ) } \" super () . __init__ ( message )","title":"__init__()"},{"location":"utils/#torrentfile.utils.PieceLengthValueError","text":"Piece Length parameter must equal a perfect power of 2. Parameters: Name Type Description Default message `any` Message for user. required","title":"PieceLengthValueError"},{"location":"utils/#torrentfile.utils.PieceLengthValueError.__init__","text":"Raise when creating a meta file with incorrect piece length value. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py def __init__ ( self , message = None ): \"\"\"Raise when creating a meta file with incorrect piece length value. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Incorrect value for piece length: { str ( message ) } \" super () . __init__ ( message )","title":"__init__()"},{"location":"utils/#torrentfile.utils.filelist_total","text":"Search directory tree for files. Parameters: Name Type Description Default path `str` Path to file or directory base required sort `bool` Return list sorted. Defaults to False. required Returns: Type Description (`list`) All file paths within directory tree. Source code in torrentfile\\utils.py def filelist_total ( path ): \"\"\"Search directory tree for files. Args: path (`str`): Path to file or directory base sort (`bool`): Return list sorted. Defaults to False. Returns: (`list`): All file paths within directory tree. \"\"\" if os . path . isfile ( path ): file_size = os . path . getsize ( path ) return file_size , [ path ] total = 0 filelist = [] if os . path . isdir ( path ): for _ , full in sortfiles ( path ): size , paths = filelist_total ( full ) total += size filelist . extend ( paths ) return total , filelist","title":"filelist_total()"},{"location":"utils/#torrentfile.utils.get_file_list","text":"Return a sorted list of file paths contained in directory. Parameters: Name Type Description Default path `str` target file or directory. required Returns: Type Description filelist (`list`) sorted list of file paths. Source code in torrentfile\\utils.py def get_file_list ( path ): \"\"\"Return a sorted list of file paths contained in directory. Args: path (`str`): target file or directory. Returns: filelist (`list`): sorted list of file paths. \"\"\" _ , filelist = filelist_total ( path ) return filelist","title":"get_file_list()"},{"location":"utils/#torrentfile.utils.get_piece_length","text":"Calculate the ideal piece length for bittorrent data. Parameters: Name Type Description Default size `int` Total bits of all files incluided in .torrent file. required Returns: Type Description piece_length (`int`) Ideal peace length size arguement. Source code in torrentfile\\utils.py def get_piece_length ( size ): \"\"\"Calculate the ideal piece length for bittorrent data. Args: size (`int`): Total bits of all files incluided in .torrent file. Returns: piece_length (`int`): Ideal peace length size arguement. \"\"\" exp = 14 while size / ( 2 ** exp ) > 200 and exp < 23 : exp += 1 return 2 ** exp","title":"get_piece_length()"},{"location":"utils/#torrentfile.utils.normalize_piece_length","text":"Verify input piece_length is valid and convert accordingly. Parameters: Name Type Description Default piece_length `int` The piece length provided by user. required Returns: Type Description piece_length (`int`) normalized piece length. Exceptions: Type Description PieceLengthValueError If piece length is improper value. Source code in torrentfile\\utils.py def normalize_piece_length ( piece_length ): \"\"\"Verify input piece_length is valid and convert accordingly. Args: piece_length (`int`): The piece length provided by user. Returns: piece_length (`int`): normalized piece length. Raises: PieceLengthValueError: If piece length is improper value. \"\"\" if isinstance ( piece_length , str ): if piece_length . isnumeric (): piece_length = int ( piece_length ) else : raise PieceLengthValueError ( piece_length ) if 13 < piece_length < 26 : return 2 ** piece_length if piece_length <= 13 : raise PieceLengthValueError ( piece_length ) log = int ( math . log2 ( piece_length )) if 2 ** log == piece_length : return piece_length raise PieceLengthValueError","title":"normalize_piece_length()"},{"location":"utils/#torrentfile.utils.path_piece_length","text":"Calculate piece length for input path and contents. Parameters: Name Type Description Default path `str` The absolute path to directory and contents. required Returns: Type Description piece_length (`int`) The size of pieces of torrent content. Source code in torrentfile\\utils.py def path_piece_length ( path ): \"\"\"Calculate piece length for input path and contents. Args: path (`str`): The absolute path to directory and contents. Returns: piece_length (`int`): The size of pieces of torrent content. \"\"\" psize = path_size ( path ) return get_piece_length ( psize )","title":"path_piece_length()"},{"location":"utils/#torrentfile.utils.path_size","text":"Return the total size of all files in path recursively. Parameters: Name Type Description Default path `str` path to target file or directory. required Returns: Type Description size (`int`) total size of files. Source code in torrentfile\\utils.py def path_size ( path ): \"\"\"Return the total size of all files in path recursively. Args: path (`str`): path to target file or directory. Returns: size (`int`): total size of files. \"\"\" total_size , _ = filelist_total ( path ) return total_size","title":"path_size()"},{"location":"utils/#torrentfile.utils.path_stat","text":"Calculate directory statistics. Parameters: Name Type Description Default path `str` The path to start calculating from. required Returns: Type Description filelist (`list`) List of all files contained in Directory size ( int ): Total sum of bytes from all contents of dir piece_length ( int ): The size of pieces of the torrent contents. Source code in torrentfile\\utils.py def path_stat ( path ): \"\"\"Calculate directory statistics. Args: path (`str`): The path to start calculating from. Returns: filelist (`list`): List of all files contained in Directory size (`int`): Total sum of bytes from all contents of dir piece_length (`int`): The size of pieces of the torrent contents. \"\"\" total_size , filelist = filelist_total ( path ) piece_length = get_piece_length ( total_size ) return ( filelist , total_size , piece_length )","title":"path_stat()"},{"location":"utils/#torrentfile.utils.sortfiles","text":"Sort entries in path. Parameters: Name Type Description Default path `str` Target directory for sorting contents. required !!! yields item, full ( str , str ): Next item in sorted order. Source code in torrentfile\\utils.py def sortfiles ( path ): \"\"\"Sort entries in path. Args: path (`str`): Target directory for sorting contents. Yields: item, full (`str`, `str`): Next item in sorted order. \"\"\" items = sorted ( os . listdir ( path ), key = str . lower ) for item in items : full = os . path . join ( path , item ) yield item , full","title":"sortfiles()"}]}