{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TorrentFile","text":""},{"location":"#overview","title":"\ud83c\udf10 Overview","text":"<p>A <code>simple</code> and <code>convenient</code> tool for creating, reviewing, editing, and/or validating bittorrent meta files (aka torrent files). <code>torrentfile</code> supports all versions of Bittorrent files, including hybrid meta files, and has full unicode support.</p> <p>A GUI frontend for this project can be found at https://github.com/alexpdev/TorrentfileQt</p>"},{"location":"#requirements","title":"\ud83d\udd0c Requirements","text":"<ul> <li>Python 3.6+</li> <li>Tested on Linux, Windows and Mac</li> </ul>"},{"location":"#install","title":"\ud83d\udcbb Install","text":"<p>via PyPi:</p> <pre><code>pip install torrentfile\n</code></pre> <p>via Git:</p> <pre><code>git clone https://github.com/alexpdev/torrentfile.git\ncd torrentfile\npip install .\n</code></pre> <p>Download pre-compiled binaries from the release page.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>Documentation can be found  here or in the <code>docs</code> directory.</p> <p>torrentfile is under active development, and is subject to significant changes in the codebase between releases.</p>"},{"location":"#usage-documentation","title":"\ud83d\ude80 Usage &amp; Documentation","text":"<p>Usage examples can be found in the project documentation on the examples page.</p>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>Apache Software License v2.0 - See LICENSE</p>"},{"location":"#issues-requests-prs","title":"\ud83d\udca1 Issues &amp; Requests &amp; PRs","text":"<p>If you encounter any bugs or would like to request a new feature please open a new issue.</p> <p>PRs and other contributions are welcome</p> <p>https://github.com/alexpdev/torrentfile/issues</p>"},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#creating-bittorrent-files","title":"Creating Bittorrent Files","text":"<p>Basic torrent file creation is as easy and using the <code>create</code> sub-commnand and providing the path to the contents.</p> <pre><code>torrentfile create /path/to/content\n</code></pre> <p>You can add one or more trackers by using any one of <code>-t</code>, <code>--tracker</code>, <code>-a</code>, <code>--announce</code>  flags and listing their URL as a space separated list.</p> <pre><code>torrentfile create /path/to/content -a http://tracker1.com http://tracker2.net\n</code></pre> <p>If you intend to distribute the file on a private tracker then you should use one of <code>-p</code>, <code>--private</code> flags, which tells your Bittorrent clients to disable DHT and multitracker protocols.</p> <pre><code>torrentfile create /path/to/content --private\n</code></pre> <p>By default <code>torrentfile</code> displays a progress bar indicating how much of the content has already been processed.  To turn off this display you can either use <code>--quiet</code> mode in as a global flag or you can set the <code>--prog</code> flag to 0.</p> <pre><code>torrentfile --quiet create /path/to/content\n</code></pre> <pre><code>torrentfile create /path/to/content --prog 0\n</code></pre> <p><code>torrentfile</code> extracts the name of the contents top level file or directory and saves the torrent file to the current working directory with the extracted title.</p> <p>For example running the follwing command would create <code>./content.torrent</code>.</p> <pre><code>torrentfile create /path/to/content\n</code></pre> <p>To specify an alternative path or filename you may use the <code>-o</code>, <code>--out</code> flags followed by the relative or absolute path to your preferred output location.</p> <pre><code>torrentfile create /path/to/content -o /some/other/path/torrent.torrent\n</code></pre> <p>If the path <code>--out</code> path specified is an existing directory, then the torrent file will be saved to that directory, with same filename as the default top level path name.</p> <p>For example the following command would create a torrent file at <code>/some/other/path/content.torrent</code>.</p> <pre><code>torrentfile create /path/to/content -o /some/other/path/\n</code></pre> <p>Bittorrent protocol V1 is still the most common version in use for torrent files,  therefore by default <code>torrentfile</code> uses the version 1 format when creating the file. However <code>torrentfile</code> has full support for creating V2 format torrent files as well as  hybrid V1 &amp; V2 format files. Use the <code>--meta-version</code> flag to specify which file format should be used during torrent file creation. Options include <code>1</code>(v1 default), <code>2</code>(v2), or <code>3</code>(v1 &amp; v2).</p> <pre><code>torrentfile create /path/to/content --meta-version 2\n</code></pre> <pre><code>torrentfile create /path/to/content --meta-version 3 </code></pre> <p>NEW FEATURE in v0.8.8:</p> <p><code>torrentfile</code> now includes the option to command line flags for the <code>create</code> sub-command from an <code>ini</code> style configuration file, by using the <code>--config</code> and optional <code>--config-path</code> options to specify the path to the configuration file.  If <code>--config-path</code> is ommited, then <code>torrentfile</code> will look by default in the current working directory for a file named <code>torrentfile.ini</code>. If the file is not discovered in the current working directory,  it will move on to look <code>~/.torrentfile/torrentfile.ini</code> followed by <code>~/.config/torrentfile.ini</code>.  Please see the  documentation for more details on how the configuration file should be formatted.</p>"},{"location":"#checkrecheck-torrent","title":"Check/Recheck Torrent","text":"<p>The <code>recheck</code> subcommand allows you to scan a Bittorrent file and compare it\u2019s contents,  against a file or directory containing the contents the torrent file was created from. The output provided by this process gives a detailed perspective if any files are missing or have been corrupted in any way.  Supports any version of Bittorrent file.</p> <pre><code>torrentfile recheck /path/to/some.torrent /path/to/content\n</code></pre>"},{"location":"#edit-torrent","title":"Edit Torrent","text":"<p>To edit specific fields of the torrent file, there is the <code>edit</code> subcommand.  Using this subcommand you can specify the field with one of the available field flags, for example <code>--tracker</code> and specify the value you wish to change it to.</p> <pre><code>torrentfile edit /path/to/content --tracker https://new.tracker.url1.com  https://newtracker.url/2\n</code></pre> <p>You can use the <code>-h</code> flag for a full list of available fields that can be edited.</p> <pre><code>__`torrentfile`__ edit -h\n</code></pre>"},{"location":"#create-magnet","title":"Create Magnet","text":"<p>To create a magnet URI for a pre-existing torrent meta file, use the sub-command <code>magnet</code> or <code>m</code> with the path to the torrent file.</p> <pre><code>torrentfile magnet /path/to/some.torrent\n</code></pre>"},{"location":"#gui","title":"GUI","text":"<p>If you prefer a windowed GUI please check out the official GUI frontend here</p>"},{"location":"Apache2/","title":"Apache License","text":"<p>Version 2.0, January 2004 &lt;http://www.apache.org/licenses/&gt;</p>"},{"location":"Apache2/#terms-and-conditions-for-use-reproduction-and-distribution","title":"Terms and Conditions for use, reproduction, and distribution","text":""},{"location":"Apache2/#1-definitions","title":"1. Definitions","text":"<p>\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d</p> <p>\u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p>"},{"location":"Apache2/#2-grant-of-copyright-license","title":"2. Grant of Copyright License","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p>"},{"location":"Apache2/#3-grant-of-patent-license","title":"3. Grant of Patent License","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p>"},{"location":"Apache2/#4-redistribution","title":"4. Redistribution","text":"<p>You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> <ul> <li>(a) You must give any other recipients of the Work or Derivative Works a copy of     this License; and</li> <li>(b) You must cause any modified files to carry prominent notices stating that You     changed the files; and</li> <li>(c) You must retain, in the Source form of any Derivative Works that You distribute,     all copyright, patent, trademark, and attribution notices from the Source form     of the Work, excluding those notices that do not pertain to any part of the     Derivative Works; and</li> <li>(d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any     Derivative Works that You distribute must include a readable copy of the     attribution notices contained within such NOTICE file, excluding those notices     that do not pertain to any part of the Derivative Works, in at least one of the     following places: within a NOTICE text file distributed as part of the     Derivative Works; within the Source form or documentation, if provided along     with the Derivative Works; or, within a display generated by the Derivative     Works, if and wherever such third-party notices normally appear. The contents of     the NOTICE file are for informational purposes only and do not modify the     License. You may add Your own attribution notices within Derivative Works that     You distribute, alongside or as an addendum to the NOTICE text from the Work,     provided that such additional attribution notices cannot be construed as     modifying the License.</li> </ul> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p>"},{"location":"Apache2/#5-submission-of-contributions","title":"5. Submission of Contributions","text":"<p>Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p>"},{"location":"Apache2/#6-trademarks","title":"6. Trademarks","text":"<p>This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p>"},{"location":"Apache2/#7-disclaimer-of-warranty","title":"7. Disclaimer of Warranty","text":"<p>Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p>"},{"location":"Apache2/#8-limitation-of-liability","title":"8. Limitation of Liability","text":"<p>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p>"},{"location":"Apache2/#9-accepting-warranty-or-additional-liability","title":"9. Accepting Warranty or Additional Liability","text":"<p>While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"Apache2/#appendix-how-to-apply-the-apache-license-to-your-work","title":"APPENDIX: How to apply the Apache License to your work","text":"<p>To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets <code>[]</code> replaced with your own identifying information. (Don\u2019t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u201cprinted page\u201d as the copyright notice for easier identification within third-party archives.</p> <pre><code>Copyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"api/","title":"TorrentFile","text":""},{"location":"api/#api-and-source","title":"API and Source","text":""},{"location":"api/#torrent-module","title":"<code>Torrent</code> Module","text":"module <code>torrentfile.</code><code>torrent</code> <p>Classes and procedures pertaining to the creation of torrent meta files.</p> Classes <ul> <li><code>MetaFile</code> \u2014 Base Class for all TorrentFile classes.</li> <li><code>TorrentFile</code> \u2014 Class for creating Bittorrent meta files.</li> <li><code>TorrentFileV2</code> \u2014 Class for creating Bittorrent meta v2 files.</li> <li><code>TorrentFileHybrid</code> \u2014 Construct the Hybrid torrent meta file with provided parameters.</li> <li><code>TorrentAssembler</code> \u2014 Assembler class for Bittorrent version 2 and hybrid meta files.</li> </ul>"},{"location":"api/#classes","title":"Classes","text":"<ul> <li> <p><code>TorrentFile</code>     construct .torrent file.</p> </li> <li> <p><code>TorrentFileV2</code>     construct .torrent v2 files using provided data.</p> </li> <li> <p><code>MetaFile</code>     base class for all MetaFile classes.</p> </li> </ul>"},{"location":"api/#constants","title":"Constants","text":"<ul> <li> <p>BLOCK_SIZE : int     size of leaf hashes for merkle tree.</p> </li> <li> <p>HASH_SIZE : int     Length of a sha256 hash.</p> </li> </ul>"},{"location":"api/#bittorrent-v2","title":"Bittorrent V2","text":"<p>From Bittorrent.org Documentation pages.</p> <p>Implementation details for Bittorrent Protocol v2.</p> <p>Note</p> <p>All strings in a .torrent file that contain text must be UTF-8 encoded.</p>"},{"location":"api/#meta-version-2-dictionary","title":"Meta Version 2 Dictionary:","text":"<ul> <li> <p>\u201cannounce\u201d:     The URL of the tracker.</p> </li> <li> <p>\u201cinfo\u201d:     This maps to a dictionary, with keys described below.</p> <ul> <li> <p>\u201cname\u201d:     A display name for the torrent. It is purely advisory.</p> </li> <li> <p>\u201cpiece length\u201d:     The number of bytes that each logical piece in the peer     protocol refers to. I.e. it sets the granularity of piece, request,     bitfield and have messages. It must be a power of two and at least     6KiB.</p> </li> <li> <p>\u201cmeta version\u201d:     An integer value, set to 2 to indicate compatibility     with the current revision of this specification. Version 1 is not     assigned to avoid confusion with BEP3. Future revisions will only     increment this issue to indicate an incompatible change has been made,     for example that hash algorithms were changed due to newly discovered     vulnerabilities. Lementations must check this field first and indicate     that a torrent is of a newer version than they can handle before     performing other idations which may result in more general messages     about invalid files. Files are mapped into this piece address space so     that each non-empty</p> </li> <li> <p>\u201cfile tree\u201d:     A tree of dictionaries where dictionary keys represent UTF-8     encoded path elements. Entries with zero-length keys describe the     properties of the composed path at that point. \u2018UTF-8 encoded\u2019     context only means that if the native encoding is known at creation     time it must be converted to UTF-8. Keys may contain invalid UTF-8     sequences or characters and names that are reserved on specific     filesystems. Implementations must be prepared to sanitize them. On     platforms path components exactly matching \u2018.\u2019 and \u2018..\u2019 must be     sanitized since they could lead to directory traversal attacks and     conflicting path descriptions. On platforms that require UTF-8     path components this sanitizing step must happen after normalizing     overlong UTF-8 encodings.     File is aligned to a piece boundary and occurs in same order as     the file tree. The last piece of each file may be shorter than the     specified piece length, resulting in an alignment gap.</p> </li> <li> <p>\u201clength\u201d:     Length of the file in bytes. Presence of this field indicates     that the dictionary describes a file, not a directory. Which means     it must not have any sibling entries.</p> </li> <li> <p>\u201cpieces root\u201d:     For non-empty files this is the the root hash of a merkle     tree with a branching factor of 2, constructed from 16KiB blocks     of the file. The last block may be shorter than 16KiB. The     remaining leaf hashes beyond the end of the file required to     construct upper layers of the merkle tree are set to zero. As of     meta version 2 SHA2-256 is used as digest function for the merkle     tree. The hash is stored in its binary form, not as human-readable     string.</p> </li> </ul> </li> <li> <p>\u201cpiece layers\u201d:     A dictionary of strings. For each file in the file tree that     is larger than the piece size it contains one string value.     The keys are the merkle roots while the values consist of concatenated     hashes of one layer within that merkle tree. The layer is chosen so     that one hash covers piece length bytes. For example if the piece     size is 16KiB then the leaf hashes are used. If a piece size of     128KiB is used then 3rd layer up from the leaf hashes is used. Layer     hashes which exclusively cover data beyond the end of file, i.e.     are only needed to balance the tree, are omitted. All hashes are     stored in their binary format. A torrent is not valid if this field is     absent, the contained hashes do not match the merkle roots or are     not from the correct layer.</p> </li> </ul> <p>Important</p> <p>The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key.</p>"},{"location":"api/#bittorrent-v1","title":"Bittorrent V1","text":""},{"location":"api/#v1-meta-dictionary","title":"v1 meta-dictionary","text":"<ul> <li> <p>announce:     The URL of the tracker.</p> </li> <li> <p>info:     This maps to a dictionary, with keys described below.</p> <ul> <li> <p><code>name</code>:     maps to a UTF-8 encoded string which is the suggested name to     save the file (or directory) as. It is purely advisory.</p> </li> <li> <p><code>piece length</code>:     maps to the number of bytes in each piece the file is split     into. For the purposes of transfer, files are split into     fixed-size pieces which are all the same length except for     possibly the last one which may be truncated.</p> </li> <li> <p><code>piece length</code>:     is almost always a power of two, most commonly 2^18 = 256 K</p> </li> <li> <p><code>pieces</code>:     maps to a string whose length is a multiple of 20. It is to be     subdivided into strings of length 20, each of which is the SHA1     hash of the piece at the corresponding index.</p> </li> <li> <p><code>length</code>:     In the single file case, maps to the length of the file in bytes.</p> </li> <li> <p><code>files</code>:     If present then the download represents a single file, otherwise it     represents a set of files which go in a directory structure.     For the purposes of the other keys, the multi-file case is treated     as only having a single file by concatenating the files in the order     they appear in the files list. The files list is the value <code>files</code>     maps to, and is a list of dictionaries containing the following keys:</p> <ul> <li> <p><code>path</code>:     A list of UTF-8 encoded strings corresponding to subdirectory     names, the last of which is the actual file name</p> </li> <li> <p><code>length</code>:     Maps to the length of the file in bytes.</p> </li> </ul> </li> <li> <p><code>length</code>:     Only present if the content is a single file. Maps to the length     of the file in bytes.</p> </li> </ul> </li> </ul> <p>Note</p> <p>In the single file case, the name key is the name of a file, in the muliple file case, it\u2019s the name of a directory.</p>"},{"location":"api/#utils-module","title":"<code>Utils</code> Module","text":"module <code>torrentfile.</code><code>utils</code> <p>Utility functions and classes used throughout package.</p> <p>Functions:   get_piece_length: calculate ideal piece length for torrent file.   sortfiles: traverse directory in sorted order yielding paths encountered.   path_size: Sum the sizes of each file in path.   get_file_list: Return list of all files contained in directory.   path_stat: Get ideal piece length, total size, and file list for directory.   path_piece_length: Get ideal piece length based on size of directory.</p> <p>Classes:     MissingPathError: Custom exception raised when no path was provided to CLI.     PieceLengthValueError: Custom exception raised when incorrect input value     used for piece length field.</p> Classes <ul> <li><code>Memo</code> \u2014 Memoize cache.</li> <li><code>MissingPathError</code> \u2014 Path parameter is required to specify target content.</li> <li><code>PieceLengthValueError</code> \u2014 Piece Length parameter must equal a perfect power of 2.</li> <li><code>ArgumentError</code> \u2014 Exception for mismatched or mistyped CLI arguments.</li> </ul> Functions <ul> <li><code>check_path_writable</code><code>(</code><code>path</code><code>)</code> (bool) \u2014 Test if output path is writable.</li> <li><code>copypath</code><code>(</code><code>source</code>, <code>dest</code><code>)</code> \u2014 Copy the file located at source to dest.</li> <li><code>debug_is_on</code><code>(</code><code>)</code> (bool) \u2014 Return True if debug mode is on in environment variables.</li> <li><code>get_file_list</code><code>(</code><code>path</code><code>)</code> (list :) \u2014 Return a sorted list of file paths contained in directory.</li> <li><code>get_piece_length</code><code>(</code><code>size</code><code>)</code> (int) \u2014 Calculate the ideal piece length for bittorrent data.</li> <li><code>humanize_bytes</code><code>(</code><code>amount</code><code>)</code> (str) \u2014 Convert integer into human readable memory sized denomination.</li> <li><code>next_power_2</code><code>(</code><code>value</code><code>)</code> (int) \u2014 Calculate the next perfect power of 2 equal to or greater than value.</li> <li><code>normalize_piece_length</code><code>(</code><code>piece_length</code><code>)</code> (int) \u2014 Verify input piece_length is valid and convert accordingly.</li> <li><code>path_piece_length</code><code>(</code><code>path</code><code>)</code> (int) \u2014 Calculate piece length for input path and contents.</li> <li><code>path_size</code><code>(</code><code>path</code><code>)</code> (int) \u2014 Return the total size of all files in path recursively.</li> <li><code>path_stat</code><code>(</code><code>path</code><code>)</code> (list) \u2014 Calculate directory statistics.</li> <li><code>toggle_debug_mode</code><code>(</code><code>switch_on</code><code>)</code> \u2014 Switch the environment variable debug indicator on or off.</li> </ul>"},{"location":"api/#edit-module","title":"<code>Edit</code> Module","text":"module <code>torrentfile.</code><code>edit</code> <p>Edit torrent module.</p> <p>Provides a facility by which certain properties of a torrent meta file can be edited by the user. The various command line arguments indicate which fields should be edited, and what the new value should be.  Depending on what fields are chosen to edit, this command can trigger a new info hash which means the torrent will no longer be able to participate in the same swarm as the original unedited torrent.</p> Functions <ul> <li><code>edit_torrent</code><code>(</code><code>metafile</code>, <code>args</code><code>)</code> (dict) \u2014 Edit the properties and values in a torrent meta file.</li> <li><code>filter_empty</code><code>(</code><code>args</code>, <code>meta</code>, <code>info</code><code>)</code> \u2014 Remove the fields that were not used by the original file creator.</li> </ul>"},{"location":"api/#keywords","title":"Keywords","text":"<p>private comment source trackers web-seeds</p>"},{"location":"api/#interactive-module","title":"<code>Interactive</code> Module","text":"module <code>torrentfile.</code><code>interactive</code> <p>Module contains the procedures used for Interactive Mode.</p> Classes <ul> <li><code>InteractiveEditor</code> \u2014 Interactive dialog class for torrent editing.</li> <li><code>InteractiveCreator</code> \u2014 Class namespace for interactive program options.</li> </ul> Functions <ul> <li><code>create_torrent</code><code>(</code><code>)</code> \u2014 Create new torrent file interactively.</li> <li><code>edit_action</code><code>(</code><code>)</code> \u2014 Edit the editable values of the torrent meta file.</li> <li><code>get_input</code><code>(</code><code>*args</code><code>)</code> (str) \u2014 Determine appropriate input function to call.</li> <li><code>recheck_torrent</code><code>(</code><code>)</code> \u2014 Check torrent download completed percentage.</li> <li><code>select_action</code><code>(</code><code>)</code> \u2014 Operate TorrentFile program interactively through terminal.</li> <li><code>showcenter</code><code>(</code><code>txt</code><code>)</code> \u2014 Print text to screen in the center position of the terminal.</li> <li><code>showtext</code><code>(</code><code>txt</code><code>)</code> \u2014 Print contents of txt to screen.</li> </ul>"},{"location":"api/#this-module-has-been-deprecated","title":"This module has been deprecated.","text":""},{"location":"api/#cli-module","title":"<code>CLI</code> Module","text":"module <code>torrentfile.</code><code>cli</code> <p>Command Line Interface for TorrentFile project.</p> <p>This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments.</p> Classes <ul> <li><code>Config</code> \u2014 Class the controls the logging configuration and output settings.</li> <li><code>TorrentFileHelpFormatter</code> \u2014 Formatting class for help tips provided by the CLI.</li> </ul> Functions <ul> <li><code>execute</code><code>(</code><code>args</code><code>)</code> (list) \u2014 Execute program with provided list of arguments.</li> <li><code>execute</code><code>(</code><code>args</code><code>)</code> (list) \u2014 Execute program with provided list of arguments.</li> <li><code>main</code><code>(</code><code>)</code> \u2014 Initiate main function for CLI script.</li> </ul>"},{"location":"api/#functions","title":"Functions","text":"<p>main_script :     process command line arguments and run program. activate_logger :     turns on debug mode and logging facility.</p>"},{"location":"api/#classes_1","title":"Classes","text":"<p>Config : class     controls logging configuration TorrentFileHelpFormatter : HelpFormatter     the command line help message formatter</p>"},{"location":"api/#recheck-module","title":"<code>Recheck</code> Module","text":"module <code>torrentfile.</code><code>recheck</code> <p>Module container Checker Class.</p> <p>The CheckerClass takes a torrentfile and tha path to it\u2019s contents. It will then iterate through every file and directory contained and compare their data to values contained within the torrent file. Completion percentages will be printed to screen for each file and at the end for the torrentfile as a whole.</p> Classes <ul> <li><code>Checker</code> \u2014 Check a given file or directory to see if it matches a torrentfile.</li> <li><code>FeedChecker</code> \u2014 Validates torrent content.</li> <li><code>HashChecker</code> \u2014 Iterate through contents of meta data and verify with file contents.</li> </ul>"},{"location":"api/#hasher-module","title":"<code>Hasher</code> Module","text":"module <code>torrentfile.</code><code>hasher</code> <p>Piece/File Hashers for Bittorrent meta file contents.</p> Classes <ul> <li><code>Hasher</code> \u2014 Piece hasher for Bittorrent V1 files.</li> <li><code>HasherV2</code> \u2014 Calculate the root hash and piece layers for file contents.</li> <li><code>HasherHybrid</code> \u2014 Calculate root and piece hashes for creating hybrid torrent file.</li> <li><code>FileHasher</code> \u2014 Calculate root and piece hashes for creating hybrid torrent file.</li> </ul> Functions <ul> <li><code>merkle_root</code><code>(</code><code>blocks</code><code>)</code> (bytes) \u2014 Calculate the merkle root for a seq of sha256 hash digests.</li> </ul>"},{"location":"api/#coverage-map","title":"Coverage Map","text":""},{"location":"changelog/","title":"TorrentFile","text":""},{"location":"changelog/#version-089","title":"Version 0.8.9","text":"<ul> <li>fixed bug with the config file parsing</li> <li>added checks to ensure the config file is parsed correctly</li> <li>added checks for applying configfile parameters to torrent properly</li> <li>deprecated and removed the <code>--cwd</code> command line flag as it is now default behaviour</li> <li>removed unittests testing the <code>--cwd</code> behaviour</li> </ul>"},{"location":"changelog/#version-088","title":"Version 0.8.8","text":"<ul> <li>added loading create torrent options from a configuration file</li> <li>added unit tests for configuration functions</li> <li>update documentation with new information about configuration file</li> <li>added CLI options for indicating the use of a configuration file <code>--config</code></li> <li>added a CLI option that specifies where to look for config file  <code>--config-path</code></li> <li>removed interactive <code>-i</code> mode from cli options as it is now deprecated.</li> </ul>"},{"location":"changelog/#version-087","title":"Version 0.8.7","text":"<ul> <li>Added the rename subcommand</li> <li>Added unittests for the new subcommand</li> <li>Default command is now \u201ccreate\u201d when user ommits entering subcommand</li> <li>Added unittests for default command</li> <li>Added shortcut command <code>tfile</code> as an alternative to <code>torrentfile</code></li> </ul>"},{"location":"changelog/#version-086","title":"Version 0.8.6","text":"<ul> <li>Fixed bug with argument parser that allowed for duplicate aliases</li> <li>Added support for python 3.11</li> <li>Updated CI/CD Workflow</li> <li>Updated documentation</li> <li>Deprecated the -i interactive argument option and added warnings in documentation</li> </ul>"},{"location":"changelog/#version-085","title":"Version 0.8.5","text":"<ul> <li>Fixed bug with linux platforms not installing a binary cli command</li> <li>Fixed debug logging errors with the rebuild command</li> <li>Improved log message readability</li> <li>Compatability upgrades for torrentfileQt synchronization</li> <li>Added coverage details to documentation folder</li> </ul>"},{"location":"changelog/#version-084","title":"Version 0.8.4","text":"<ul> <li>Documentation Updates</li> <li>Fixed logging issues with rebuild module.</li> <li>Improved algorithm for rebuild module.</li> <li>Improved testing for rebuild module.</li> </ul>"},{"location":"changelog/#version-083","title":"Version 0.8.3","text":"<ul> <li>Added the callback mixin to the rebuild module</li> <li>Fix compatability with GUI frontend torrentfileQt.</li> </ul>"},{"location":"changelog/#version-082","title":"Version 0.8.2","text":"<ul> <li>Rebuild subcommand now checks on a hash by hash basis</li> <li>Fixed coverage issues</li> <li>Added unittests for the rebuild command</li> <li>Fixed bug with torrentfile creation when a file was a perfect power of 2</li> <li>Reconfigured the rebuild module</li> <li>Reconfigured the rebuild cli flags and arguments</li> </ul>"},{"location":"changelog/#version-081","title":"Version 0.8.1","text":"<ul> <li>Further improvements to documentation</li> <li>Fixed bug that interrupted the creation process when using gui version</li> <li>Added unittests</li> <li>Improved docstrings and docstring formatting</li> <li>Renamed a couple of methods</li> </ul>"},{"location":"changelog/#version-080","title":"Version 0.8.0","text":"<ul> <li>overhaul documentation</li> <li>reconfigured CI files and configuration and packaging files</li> <li>Convert to pyproject.toml setuptools packaging info source</li> </ul>"},{"location":"changelog/#version-0712","title":"Version 0.7.12","text":"<ul> <li>Changed default behavior to save torrent files to cwd</li> <li>edited all unittests to reflect default behavior</li> <li>added deprecation messages for the cli arg and class paramteter</li> <li>last update to version 0.7.x</li> </ul>"},{"location":"changelog/#version-0711","title":"Version 0.7.11","text":"<ul> <li>Fixed issue with progress bar displaying inaccurate details</li> <li>Other minor bug fixes</li> <li>Updated output for Recheck subcommand for better readability</li> <li>Updated documentation</li> <li>Updated Readme</li> <li>added quiet mode to cli global options <code>-q</code></li> <li>Added unit test to fix coverage gaps</li> <li>Fixed warnings created by pylint</li> </ul>"},{"location":"changelog/#version-0710","title":"Version 0.7.10","text":"<ul> <li>Added rebuild module and subcommand see docs for more info</li> <li>Added documentation entry for rebuild subcommand</li> <li>improved logging messages</li> <li>added unit tests</li> <li>improved and expanded on type hints</li> <li>minor bug fixes</li> </ul>"},{"location":"changelog/#version-079","title":"Version 0.7.9","text":"<ul> <li>complete rewrite of the recheck procedures</li> <li>Recheck now provides more accuracy and more details</li> <li>improvements to the new custom progressbar</li> <li>changed the cli argument for the progress bar</li> <li>the options are now just 0 and 1</li> <li>included new unit tests for all new features</li> <li>marked unused functions as deprecated</li> <li>added a new hasher object for v2 and hybrid torrents</li> <li>minor bug fixes and styling changes</li> </ul>"},{"location":"changelog/#version-078","title":"Version 0.7.8","text":"<ul> <li>more updates to logging</li> <li>major improvements to progress bar</li> <li>removed tqdm as dependency</li> <li>implemented custom progress bar logic</li> <li>new cli argument controlling the progress bar</li> <li>support for pyben 0.3.1</li> <li>added threading to recheck module</li> <li>added mixins module</li> <li>unit test updates and improvements</li> </ul>"},{"location":"changelog/#version-075","title":"Version 0.7.5","text":"<ul> <li>updates to logging facility</li> <li>fixed bug in created hybrid torrent files</li> <li>fixed cli when subcomman not chosen</li> <li>doc updates</li> <li>unit test updates and improvements</li> </ul>"},{"location":"changelog/#version-072","title":"Version 0.7.2","text":"<ul> <li>cleaned up readme and help messages</li> <li>removed useless print statements</li> <li>improved CI tooling and checking</li> <li>minor bug fixes</li> </ul>"},{"location":"changelog/#version-071","title":"Version 0.7.1","text":"<ul> <li>split CI integration into separate platform specific files</li> <li>added new cli argument <code>--cwd</code> which changes the default save   to location to the current working directory (this will be default in future)</li> <li>added unit tests to cover the new argument</li> <li>Changed license to a the more permissive Apache 2 software license</li> </ul>"},{"location":"changelog/#version-070","title":"Version 0.7.0","text":"<ul> <li>Fixed issues with logging to file.</li> <li>Finished adding tests for Unicode Support</li> <li>Deprecated some unneccessary code</li> <li>Clean up documentation and README</li> <li>removed config files no longer in use.</li> </ul>"},{"location":"changelog/#version-0613","title":"Version 0.6.13","text":"<ul> <li>Fixed bug that created a torrent file with no name.</li> <li>Fixed bug that would error if cli path was listed after announce urls</li> <li>Added full unicode support.</li> <li>Added Unittests for new features and bug fixes</li> </ul>"},{"location":"changelog/#version-0611","title":"Version 0.6.11","text":"<ul> <li>Fixed bug that occured during recheck when file of 0 length is included.</li> <li>Altered Recheck algorithm to process 0 length files.</li> <li>Only effected meta version 2 and hybrid torrent files.</li> <li>Added unittests to cover the situation.</li> </ul>"},{"location":"changelog/#version-0610","title":"Version 0.6.10","text":"<ul> <li>Updates to documentation</li> <li>Integrated Type hints in source code</li> <li>Updated build and CI process</li> </ul>"},{"location":"changelog/#version-069","title":"Version 0.6.9","text":"<ul> <li>The \u2013progress flag is now \u2013noprogress</li> <li>Default behavior is to show progress bar</li> <li>use \u2013noprogress to not show</li> <li>added CLI Help format strings</li> <li>added custom CLI help formatter class</li> <li>Titled Help Message section headers</li> <li>Fixed a bunch of error pages created by mkdocs</li> </ul>"},{"location":"changelog/#version-068","title":"Version 0.6.8","text":"<ul> <li>Documentation for newest features</li> <li>CLI usage examples</li> <li>Improved unittests</li> <li>made progress bar active by default</li> </ul>"},{"location":"changelog/#version-067","title":"Version 0.6.7","text":"<ul> <li>Updates to API</li> </ul>"},{"location":"changelog/#version-066","title":"Version 0.6.6","text":"<ul> <li>bug that created faulty Bittorrent V2 meta files in some instances.</li> <li>back to working as it should.</li> </ul>"},{"location":"changelog/#version-065","title":"Version 0.6.5","text":"<ul> <li>Support for creating Magnet URI\u2019s</li> <li>Added optional progress bar for torrent creation</li> <li>Log File handler</li> <li>CLI args page in documentation</li> <li>verbose and logging bugs</li> <li>multi tracker errors bug</li> </ul>"},{"location":"changelog/#version-064","title":"Version 0.6.4","text":"<ul> <li>CLI interface add subcommands</li> <li>added interactive mode</li> <li>Re-wrote the recheck module</li> <li>fixed documentation and docstrings</li> <li>linting and testing errors</li> </ul>"},{"location":"changelog/#version-063","title":"Version 0.6.3","text":"<ul> <li>Fixed Bug that would format list of trackers incorrectly</li> <li>CLI Bug Fixes</li> </ul>"},{"location":"changelog/#version-062","title":"Version 0.6.2","text":"<ul> <li>Bug fixes</li> <li>Documentation error pages</li> </ul>"},{"location":"changelog/#version-060","title":"Version 0.6.0","text":"<ul> <li>cli commands alterations</li> <li>debug logging during creation process</li> </ul>"},{"location":"changelog/#version-052","title":"Version 0.5.2","text":"<ul> <li>Fixed Bug that was adding wrong fields to info dict</li> </ul>"},{"location":"changelog/#version-050","title":"Version 0.5.0","text":"<ul> <li>Slew of new unit tests</li> <li>Stricter linting features</li> <li>Alternative method of -re-check feature</li> <li>Bug Fixes</li> <li>CLI help formatting errors</li> </ul>"},{"location":"changelog/#version-048","title":"Version 0.4.8","text":"<ul> <li>Improved Algorithm performance for ReCheck.</li> <li>Additions to documentation.</li> </ul>"},{"location":"changelog/#version-047","title":"Version 0.4.7","text":"<ul> <li>Fixed A bug that misspelled a field when creating Hybrid torrent files.</li> <li>Re-Check procedure for v2 and hybrid torrent file checking.</li> </ul>"},{"location":"changelog/#version-046","title":"Version 0.4.6","text":"<ul> <li>CLI Help and Usage Messages.</li> <li>Expanded CLI args.</li> <li>Completely new CheckerClass which replaces old Checker</li> <li>Hooks for GUI or other 3rd party apps to hook into Checking</li> <li>Documentation and Unit tests for new CheckerClass</li> </ul>"},{"location":"changelog/#version-045","title":"Version 0.4.5","text":"<ul> <li>Documentation and docstrings improvements</li> <li>Better code formating and more detailed docstrings</li> <li>More unit tests.</li> </ul>"},{"location":"changelog/#version-042","title":"Version 0.4.2","text":"<ul> <li>The ReChecker feature now supports v1, v2, &amp; hybrid .torrent file.</li> <li>Bug in CLI for python &lt; 3.8</li> </ul>"},{"location":"changelog/#version-041","title":"Version 0.4.1","text":"<ul> <li>Added tests for hybrid class</li> <li>Added logging features</li> <li>new cli flag to activate debug mode</li> <li>Documentation theme.</li> <li>Fixed Bug that allowed improper piece length values.</li> </ul>"},{"location":"changelog/#version-040","title":"Version 0.4.0","text":"<ul> <li>Fixed bugs in creating hybrid files.</li> <li>Bug Fix that broke cli.</li> </ul>"},{"location":"changelog/#version-030","title":"Version 0.3.0","text":"<ul> <li>Added/Improved support for hybrid meta files.</li> <li>Many additions to testing suit including linting and coverage tests.</li> </ul>"},{"location":"changelog/#version-028","title":"Version 0.2.8","text":"<ul> <li>Styling fixes.</li> <li>Bug Fixes.</li> <li>Prelimenary support for bittorrent hybrid meta files.</li> <li>Bug Fixes</li> </ul>"},{"location":"changelog/#version-027","title":"Version 0.2.7","text":"<ul> <li>major imporvements to torrentfile-GUI.</li> <li>minor adjustments to this package for integration.</li> <li>Code consolidation</li> <li>Bug Fixes</li> <li>Documentation additions</li> <li>Implemented CI/CD Integration</li> </ul>"},{"location":"changelog/#version-023","title":"Version 0.2.3","text":"<ul> <li>Bug Fixes</li> <li>Code Style and Formatting</li> <li>Added more unittests</li> </ul>"},{"location":"changelog/#version-021","title":"Version 0.2.1","text":"<ul> <li>Bittorrent Protocol V2 Support</li> <li>v2 metafile options to cli</li> <li>v2 metafile tests</li> </ul>"},{"location":"changelog/#version-017","title":"Version 0.1.7","text":"<ul> <li>Docstrings Improvements.</li> <li>Added documentation rederer.</li> <li>Improved readme file.</li> <li>formatting</li> </ul>"},{"location":"changelog/#version-012","title":"Version 0.1.2","text":"<ul> <li>Added a Command Line Interface</li> <li>Rough Graphical User Interface</li> <li>Minor Bug Fixes</li> <li>Improved unittest coverage</li> </ul>"},{"location":"changelog/#version-010","title":"Version 0.1.0","text":"<ul> <li>added SHA256 support</li> <li>Feeder class for seemless file switching</li> <li>Fixed the primary entrypoint function.</li> <li>Improved docstrings</li> <li>Bug fixes</li> </ul>"},{"location":"changelog/#version-002","title":"Version 0.0.2","text":"<ul> <li>Added Unittests</li> <li>added bencode support</li> <li>added hashing support</li> </ul>"},{"location":"changelog/#version-001","title":"Version 0.0.1","text":"<ul> <li>Initial concept and planning</li> </ul>"},{"location":"overview/","title":"torrentfile Manual","text":""},{"location":"overview/#synopsis","title":"Synopsis","text":"<p><code>torrentfile</code> is a command line utility for working with Bittorrent files(.torrent). Some of the tools available include creating torrent files, editing portions of a torrent files, checking the integrity or completeness of downloaded torrent contents, displaying details of a torrentfile, generating magnet URLs for torrentfiles, and individual or batch rebuilding of torrent contents into their original directory structure.</p> <pre><code>torrentfile [options]`&lt;subcommand&gt;` [options] `&lt;args&gt;`\n</code></pre> <ul> <li> <p><code>-h</code></p> </li> <li> <p>displays all relevant command line options and subcommands.</p> </li> <li> <p><code>-V</code></p> </li> <li> <p>displays program and version.</p> </li> <li> <p><code>-v</code></p> </li> <li> <p>enables debug mode and outputs a large amount of information to the terminal.</p> </li> </ul>"},{"location":"overview/#sub-commands","title":"Sub-commands","text":""},{"location":"overview/#create","title":"create","text":"<p>alias: <code>c</code></p> <p>The create subcommand is used for generating new torrent files. The only required argument is the path(<code>&lt;path&gt;</code>) to the contents file or directory.</p> <pre><code>torrentfile create [options]`&lt;path&gt;`\ntorrentfile c [options] `&lt;path&gt;`\n</code></pre> <ul> <li> <p><code>-a</code> <code>-t</code> <code>--announce</code> <code>--tracker</code></p> </li> <li> <p>Adds the list of url\u2019s that follow to the list of trackers for the newly created torrent file.</p> </li> <li> <p>Example <code>-t http://url1 https://url2 ...</code></p> </li> <li> <p><code>-p</code> <code>--private</code></p> </li> <li> <p>Indicates that the torrent will be used on a private tracker. Disables multi-tracker protocols and DHT.</p> </li> <li> <p><code>--web-seed</code></p> </li> <li> <p>Adds the list of urls that follow to the list of web-seed addresses for the newly created torrent file.</p> </li> <li> <p><code>--http-seed</code></p> </li> <li> <p>Same as the <code>-web-seed</code> argument except using Hoffman style web-seeds.</p> </li> <li> <p><code>-c</code> <code>--comment</code></p> </li> <li> <p>Includes the comment that follows to the metadata saved in the newly created torrent file.</p> </li> <li> <p>Example: <code>--comment \"Created for MyTrackerExample.com\"</code></p> </li> <li> <p><code>--source</code></p> </li> <li> <p>Creates a source field in the info dictionary with the string that follows as the value. Frequently used for cross-seeding on private trackers.</p> </li> <li> <p>Example: <code>--source MyTrackerExample</code></p> </li> <li> <p><code>--piece-length</code></p> </li> <li> <p>Uses the number that follows as the piece-length size for the newly created torrent file. If option isn\u2019t used the program will pick the ideal size.  Acceptable values include 14-29 which is interpreted as the number to raise 2 by  (e.g. 14 is interpreted as 16384), or any perfect power of 2 greater than or equal  to 16 KiB and less than 1 GiB.</p> </li> <li> <p>Example: <code>--piece-length 14</code> or <code>--piece-length 16384</code>.</p> </li> <li> <p><code>--meta-version</code></p> </li> <li> <p>Use the following number as the Bittorrent version the torrent will be used on. The default is 1.</p> </li> <li>Options: 1 - Bittorrent v1,    2 - Bittorrent v2,    3 - Bittorrent v1 &amp; v2</li> <li> <p>Examples: <code>--meta-version 2</code>, <code>--meta-version 3</code></p> </li> <li> <p><code>-o</code> <code>--out</code></p> </li> <li> <p>Specify the full path to the newly created torrent file.  The default is to save it adjacent to the content.</p> </li> <li> <p>Example: if content is at <code>/home/user/torrents/content</code> the default would create <code>/home/user/torrents/content.torrent</code></p> </li> <li> <p><code>--progress</code> <code>--prog</code></p> </li> <li> <p>Options (0, 1):  No status bar will be shown if 0.  Otherwise the default and \u201c1\u201d means progress bar is shown</p> </li> <li> <p><code>--config</code></p> </li> <li> <p>Load options from a configuration file. default <code>torrentfile.ini</code></p> </li> <li>file can use the same long options names used for the command line</li> <li> <p>The current available options that can be marked in the config file include: <code>announce</code>, <code>source</code>, <code>comment</code>, <code>http-seeds</code>, <code>web-seeds</code>, <code>piece-length</code>, ``</p> </li> <li> <p>Default search paths and priority:</p> <ol> <li><code>./torrentfile.ini</code></li> <li><code>~/.torrentfile/torrentfile.ini</code></li> <li><code>~/.config/torrentfile.ini</code></li> </ol> </li> <li> <p><code>--config-path</code></p> </li> <li> <p>Use in combination with <code>--config</code> to specify path to the configuration file.</p> </li> <li>Example: <code>torrentfile create --config --config-path ./dir/config.ini &lt;content-path&gt;</code></li> </ul> <p>Example Configuration File</p> <p><code>torrentfile.ini</code> <pre><code>[config]\nprivate = false\ncomment = example torrent comment\nannounce =\n    https://tracker1.net/announce\n    https://example.org/2324announce\nhttp-seed = \n    https://example.url/path/to/content\nweb-seed =\n    ftp://ftp.example.site/content\nmeta-version = 2\npiece-length = 18\nout = /path/to/file/content.torrent\n</code></pre></p>"},{"location":"overview/#info","title":"info","text":"<p>alias: <code>i</code></p> <p>Display detailed information about a torrentfile such as trackers, size of contents, Bittorrent version, any comments left, date the torrent file was created and more. There is only one positional perameter which is the path to the torrent file and there are no optional arguments.</p> <pre><code>torrentfile info`&lt;path&gt;`\ntorrentfile i `&lt;path&gt;`\n</code></pre> <ul> <li><code>/path/to/*.torrent</code></li> <li>The relative or absolute path to the torrent file.</li> </ul>"},{"location":"overview/#edit","title":"edit","text":"<p>Edit some of the different information detailed in a torrent file. The fields that are editable each have option flags detialed below. Each option identifies the field to edit inside the torrent file and what the new value should be. If an option is not used then its field will be ommited in the newly created torrent file. As such if the file is marked as private and it should remain that way, the <code>-p</code> option should be used.</p> <p>alias: <code>e</code></p> <pre><code>torrentfile edit [options]`&lt;path&gt;`\ntorrentfile e [options] `&lt;path&gt;`\n</code></pre> <ul> <li> <p><code>-a</code> <code>-t</code> <code>--announce</code> <code>--tracker</code></p> </li> <li> <p>Adds the list of url\u2019s that follow to the list of trackers for the newly created torrent file.</p> </li> <li> <p>Example <code>-t http://url1 https://url2 ...</code></p> </li> <li> <p><code>-w</code> <code>--web-seeds</code></p> </li> <li> <p>Adds the list of urls that follow to the list of web-seed addresses for     the newly created torrent file.</p> </li> <li> <p><code>--comment</code></p> </li> <li> <p>Includes the comment that follows to the metadata saved in the newly     created torrent file.</p> </li> <li> <p>Example: <code>--comment \"Created for MyTrackerExample.com\"</code></p> </li> <li> <p><code>--source</code></p> </li> <li> <p>Creates a source field in the info dictionary with the string that follows as the value. Frequently used for cross-seeding on private trackers.</p> </li> <li> <p>Example: <code>--source MyTrackerExample</code></p> </li> <li> <p><code>-p</code> <code>--private</code></p> </li> <li> <p>Indicates that the torrent will be used on a private tracker.  Disables multi-tracker protocols and DHT.</p> </li> </ul>"},{"location":"overview/#recheck","title":"recheck","text":"<p>This feature is identical to the \u2018recheck\u2019 function provided by torrent clients. It validates that the file/directory contents match those described in the torrent file.</p> <p>Recheck requires two paths as arguments. The first is the path to a torrent file, and and the second is a path to the file of directory containing the downloaded data from that torrentfile. <code>torrentfile</code> recursively validates each file with the hashes contained in the torrentfile, and displays the total percentage of the file that matches the information from the torrent file. It is also permitted to use the contents parent directory which can help for batch processing many torrent files.</p> <p>alias: <code>r</code>, <code>check</code></p> <pre><code>torrentfile recheck &lt;*.torrent&gt; `&lt;contents&gt;`\ntorrentfile r &lt;*.torrent&gt; `&lt;contents&gt;`\n</code></pre>"},{"location":"overview/#magnet","title":"Magnet","text":"<p>Generate a magnet URL for a torrent file.</p> <p>alias: <code>m</code></p> <pre><code>torrentfile magnet &lt;path/to/*.torrent&gt;\n</code></pre>"},{"location":"overview/#rebuild","title":"Rebuild","text":"<p>Rebuild individual or batches of torrent contents into the original file structure. The program takes a path to a torrent file or directory containing torrent files, the directory containing the torrent contents, and the destination directory to where the rebuilt torrent content wil be located. The program will recursively traverse the content directory searching for file\u2019s that match one of the meta files and creates copies of the matches to the destination directory. The original files are not effected and any existing files in the target directory will not be overwritten.</p> <p>alias: <code>build</code>, <code>b</code></p> <pre><code>torrentfile rebuild -m`&lt;metafiles&gt;` -c `&lt;contents&gt;` -d `&lt;destination&gt;`\n</code></pre> <ul> <li> <p><code>-m</code> <code>--metafiles</code></p> </li> <li> <p>path to a torrent file or a directory containing torrent files for batch processing.</p> </li> <li> <p><code>-c</code> <code>--content</code></p> </li> <li> <p>path to where the contents for the torrentfile can be found.  If the path is     for a directory, the directory will be searched recusively for files that match.     For deeply nested directories with lot\u2019s of files in them, this can take time.</p> </li> <li> <p><code>-d</code> <code>-destination</code></p> </li> <li> <p>path to a directory where the torrent will be rebuilt. Files will be copied     from their original location, not moved.</p> </li> </ul>"},{"location":"usage/","title":"TorrentFile CLI Menu","text":""},{"location":"usage/#help-messages","title":"Help Messages","text":""},{"location":"usage/#main","title":"Main","text":"<pre><code>Usage\n=====\n    torrentfile [options] command [command options]\n\nCommand line tools for creating, editing, checking, building and interacting with Bittorrent metainfo files\n</code></pre> Options -h, \u2013help             show this help message and exit -i, \u2013interactive      select program options interactively -q, \u2013quiet            Turn off all text output. -V, \u2013version          show program version and exit Commands create, edit, info, magnet, recheck, rebuild <pre><code>create (c, new)      Create a new Bittorrent file.\n    edit (e)             Edit existing torrent meta file.\n    info (i)             Show detailed information about a torrent file.\n    magnet (m)           Generate magnet url from an existing Bittorrent meta file.\n    recheck (check)      Gives a detailed look at how much of the torrent is available.\n    rebuild (build)      Re-assemble files obtained from a bittorrent file into the\n                        appropriate file structure for re-seeding.  Read documentation\n                        for more information, or use cases.\n</code></pre>"},{"location":"usage/#create","title":"Create","text":"<pre><code>Usage\n=====\n\ntorrentfile [options] create\n    [-h] [-a`&lt;url&gt;` [`&lt;url&gt;` ...]] [-p]\n    [-s `&lt;source&gt;`] [-m] [-c `&lt;comment&gt;`]\n    [-o `&lt;path&gt;`] [--cwd] [--prog PROGRESS]\n    [--meta-version `&lt;int&gt;`]\n    [--piece-length `&lt;int&gt;`]\n    [-w `&lt;url&gt;` [`&lt;url&gt;` ...]]\n    [--http-seed `&lt;url&gt;` [`&lt;url&gt;` ...]]\n    [`&lt;content&gt;`]\n</code></pre> Positional Arguments <code>&lt;content&gt;</code>              Path to content file or directory Options -h, \u2013help             show this help message and exit -a<code>&lt;url&gt;</code> [<code>&lt;url&gt;</code> \u2026], -t <code>&lt;url&gt;</code> [<code>&lt;url&gt;</code> \u2026], \u2013announce <code>&lt;url&gt;</code> [<code>&lt;url&gt;</code> \u2026], \u2013tracker <code>&lt;url&gt;</code> [<code>&lt;url&gt;</code> \u2026] One or more space-seperated torrent tracker url(s). -p, \u2013private          Creates private torrent with multi-tracker and DHT turned off. -s<code>&lt;source&gt;</code>, \u2013source <code>&lt;source&gt;</code> Add a source string. Useful for cross-seeding. -m, \u2013magnet -c<code>&lt;comment&gt;</code>, \u2013comment <code>&lt;comment&gt;</code> Include a comment in file metadata -o<code>&lt;path&gt;</code>, \u2013out <code>&lt;path&gt;</code> Explicitly specify the path to write the file. \u2013cwd, \u2013current*deprecated* Saving to current directory is default behaviour \u2013prog PROGRESS, \u2013progress PROGRESS Set the progress bar level. Options = 0, 1 (0) = Do not display progress bar. (1) = Display progress bar.(default) <pre><code>--meta-version`&lt;int&gt;`   Bittorrent metafile version.\n                        Options = 1, 2, 3\n                        (1) = Bittorrent v1 (Default)\n                        (2) = Bittorrent v2\n                        (3) = Bittorrent v1 &amp; v2 hybrid\n\n--piece-length`&lt;int&gt;`   (Default: `&lt;blank&gt;`) Number of bytes for per chunk of data transmitted\n                        by Bittorrent client. Acceptable values include integers 14-26 which\n                        will be interpreted as a perfect power of 2.  e.g. 14 = 16KiB pieces.\n                        Examples:: [--piece-length 14] [--piece-length 20]\n\n-w`&lt;url&gt;` [`&lt;url&gt;` ...], --web-seed `&lt;url&gt;` [`&lt;url&gt;` ...]\n                        list of web addresses where torrent data exists (GetRight).\n    --http-seed `&lt;url&gt;` [`&lt;url&gt;` ...]\n                        list of URLs, addresses where content can be found (Hoffman).\n</code></pre>"},{"location":"usage/#edit","title":"Edit","text":"<pre><code>Usage\n=====\ntorrentfile e [-h] [--tracker`&lt;url&gt;` [`&lt;url&gt;` ...]]\n                    [--web-seed `&lt;url&gt;` [`&lt;url&gt;` ...]] [--private]\n                    [--comment `&lt;comment&gt;`] [--source `&lt;source&gt;`]\n                    &lt;*.torrent&gt;\n</code></pre> Positional Arguments &lt;*.torrent&gt;                   path to *.torrent file Optional Arguments -h, \u2013help                    show this help message and exit \u2013tracker<code>&lt;url&gt;</code> [<code>&lt;url&gt;</code> \u2026]   Replace current list of tracker/announce urls with one or more space seperated Bittorrent tracker announce url(s). <pre><code>--web-seed`&lt;url&gt;` [`&lt;url&gt;` ...]  Replace current list of web-seed urls with one or more space seperated url(s)\n\n--private                     Make torrent private.\n--comment`&lt;comment&gt;`           Replaces any existing comment with `&lt;comment&gt;`\n--source `&lt;source&gt;`             Replaces current source with `&lt;source&gt;`\n</code></pre>"},{"location":"usage/#recheck","title":"Recheck","text":"<pre><code>Usage\n=====\ntorrentfile r [-h] &lt;*.torrent&gt;`&lt;content&gt;`\n</code></pre> Positional Arguments &lt;*.torrent&gt;  path to .torrent file. <code>&lt;content&gt;</code>    path to content file or directory Optional Arguments -h, \u2013help   show this help message and exit"},{"location":"usage/#magnet","title":"Magnet","text":"<pre><code>Usage\n=====\ntorrentfile m [-h] &lt;*.torrent&gt;\n</code></pre> Positional Arguments &lt;*.torrent&gt;  Path to Bittorrent meta file. Optional Arguments -h, \u2013help   show this help message and exit"},{"location":"Source/","title":"Source Code Modules","text":"<p><code>torrentfile</code> is an open source project. </p> <p>The official source code can be viewed on github at https://github.com/alexpdev/torrentfile.</p>"},{"location":"Source/#modules","title":"Modules","text":""},{"location":"Source/#cli","title":"cli","text":""},{"location":"Source/#commands","title":"commands","text":""},{"location":"Source/#edit","title":"edit","text":""},{"location":"Source/#hasher","title":"hasher","text":""},{"location":"Source/#interactive","title":"interactive","text":""},{"location":"Source/#mixins","title":"mixins","text":""},{"location":"Source/#rebuild","title":"rebuild","text":""},{"location":"Source/#recheck","title":"recheck","text":""},{"location":"Source/#torrent","title":"torrent","text":""},{"location":"Source/#utils","title":"utils","text":""},{"location":"Source/#version","title":"version","text":""},{"location":"Source/cli/","title":"Cli","text":""},{"location":"Source/cli/#torrentfile.cli","title":"<code>cli</code>","text":"<p>Command Line Interface for TorrentFile project.</p> <p>This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments.</p>"},{"location":"Source/cli/#torrentfile.cli--functions","title":"Functions","text":"<p>main_script :     process command line arguments and run program. activate_logger :     turns on debug mode and logging facility.</p>"},{"location":"Source/cli/#torrentfile.cli--classes","title":"Classes","text":"<p>Config : class     controls logging configuration TorrentFileHelpFormatter : HelpFormatter     the command line help message formatter</p>"},{"location":"Source/cli/#torrentfile.cli.Config","title":"<code>Config</code>","text":"<p>Class the controls the logging configuration and output settings.</p> <p>Controls the logging level, or whether to app should operate in quiet mode.</p>"},{"location":"Source/cli/#torrentfile.cli.Config.activate_logger","title":"<code>activate_logger()</code>  <code>staticmethod</code>","text":"<p>Activate the builtin logging mechanism when passed debug flag from CLI.</p> Source code in <code>torrentfile\\cli.py</code> <pre><code>@staticmethod\ndef activate_logger():\n\"\"\"\n    Activate the builtin logging mechanism when passed debug flag from CLI.\n    \"\"\"\n    logging.basicConfig(level=logging.WARNING)\n    logger = logging.getLogger()\n    console_handler = logging.StreamHandler(stream=sys.stderr)\n    stream_formatter = logging.Formatter(\n        \"[%(asctime)s] [%(levelno)s] %(message)s\",\n        datefmt=\"%H:%M:%S\",\n        style=\"%\",\n    )\n    console_handler.setFormatter(stream_formatter)\n    console_handler.setLevel(logging.DEBUG)\n    logger.setLevel(logging.DEBUG)\n    logger.addHandler(console_handler)\n    logger.debug(\"Debug: ON\")\n    toggle_debug_mode(True)\n</code></pre>"},{"location":"Source/cli/#torrentfile.cli.Config.activate_quiet","title":"<code>activate_quiet()</code>  <code>staticmethod</code>","text":"<p>Activate quiet mode for the duration of the programs life.</p> <p>When quiet mode is enabled, no logging, progress or state information is output to the terminal</p> Source code in <code>torrentfile\\cli.py</code> <pre><code>@staticmethod\ndef activate_quiet():\n\"\"\"\n    Activate quiet mode for the duration of the programs life.\n\n    When quiet mode is enabled, no logging, progress or state information\n    is output to the terminal\n    \"\"\"\n    if sys.stdout or sys.stderr:\n        sys.stdout = io.StringIO()\n        sys.stderr = io.StringIO()\n</code></pre>"},{"location":"Source/cli/#torrentfile.cli.TorrentFileHelpFormatter","title":"<code>TorrentFileHelpFormatter(prog, width = 45, max_help_positions = 45)</code>","text":"<p>         Bases: <code>HelpFormatter</code></p> <p>Formatting class for help tips provided by the CLI.</p> <p>Subclasses Argparse.HelpFormatter.</p> <p>Construct HelpFormat class for usage output.</p> PARAMETER DESCRIPTION <code>prog</code> <p>Name of the program.</p> <p> TYPE: <code>str</code> </p> <code>width</code> <p>Max width of help message output.</p> <p> TYPE: <code>int</code> DEFAULT: <code>45</code> </p> <code>max_help_positions</code> <p>max length until line wrap.</p> <p> TYPE: <code>int</code> DEFAULT: <code>45</code> </p> Source code in <code>torrentfile\\cli.py</code> <pre><code>def __init__(self, prog, width=45, max_help_positions=45):\n\"\"\"\n    Construct HelpFormat class for usage output.\n\n    Parameters\n    ----------\n    prog : str\n        Name of the program.\n    width : int\n        Max width of help message output.\n    max_help_positions : int\n        max length until line wrap.\n    \"\"\"\n    super().__init__(\n        prog, width=width, max_help_position=max_help_positions\n    )\n</code></pre>"},{"location":"Source/cli/#torrentfile.cli.execute","title":"<code>execute(args: list = None) -&gt; list</code>","text":"<p>Execute program with provided list of arguments.</p> <p>If no arguments are given then it defaults to using sys.argv.  This is the main entrypoint for the program and command line interface.</p> PARAMETER DESCRIPTION <code>args</code> <p>Commandline arguments. default=None</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list</code> <p>Depends on what the command line args were.</p> Source code in <code>torrentfile\\cli.py</code> <pre><code>def execute(args: list = None) -&gt; list:\n\"\"\"\n    Execute program with provided list of arguments.\n\n    If no arguments are given then it defaults to using\n    sys.argv.  This is the main entrypoint for the program\n    and command line interface.\n\n    Parameters\n    ----------\n    args : list\n        Commandline arguments. default=None\n\n    Returns\n    -------\n    list\n        Depends on what the command line args were.\n    \"\"\"\n    toggle_debug_mode(False)\n    if not args:\n        if sys.argv[1:]:\n            args = sys.argv[1:]\n        else:\n            args = [\"-h\"]\n\n    parser = ArgumentParser(\n        \"torrentfile\",\n        usage=\"torrentfile &lt;options&gt;\",\n        description=(\n            \"Command line tools for creating, editing, checking, building \"\n            \"and interacting with Bittorrent metainfo files\"\n        ),\n        prefix_chars=\"-\",\n        formatter_class=TorrentFileHelpFormatter,\n        conflict_handler=\"resolve\",\n    )\n\n    parser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        help=\"Turn off all text output.\",\n        dest=\"quiet\",\n        action=\"store_true\",\n    )\n\n    parser.add_argument(\n        \"-V\",\n        \"--version\",\n        action=\"version\",\n        version=f\"torrentfile v{version}\",\n        help=\"show program version and exit\",\n    )\n\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        dest=\"debug\",\n        help=\"output debug information\",\n    )\n\n    parser.set_defaults(func=parser.print_help)\n\n    subparsers = parser.add_subparsers(\n        title=\"Commands\",\n        dest=\"command\",\n        metavar=\"create, edit, info, magnet, recheck, rebuild, rename\\n\",\n    )\n\n    create_parser = subparsers.add_parser(\n        \"create\",\n        help=\"Create a new Bittorrent file.\",\n        prefix_chars=\"-\",\n        aliases=[\"c\", \"new\"],\n        formatter_class=TorrentFileHelpFormatter,\n    )\n\n    create_parser.add_argument(\n        \"-a\",\n        \"-t\",\n        \"--announce\",\n        \"--tracker\",\n        action=\"store\",\n        dest=\"announce\",\n        metavar=\"&lt;url&gt;\",\n        nargs=\"+\",\n        default=[],\n        help=\"One or more space-seperated torrent tracker url(s).\",\n    )\n\n    create_parser.add_argument(\n        \"-p\",\n        \"--private\",\n        action=\"store_true\",\n        dest=\"private\",\n        help=\"Creates private torrent with multi-tracker and DHT turned off.\",\n    )\n\n    create_parser.add_argument(\n        \"-s\",\n        \"--source\",\n        action=\"store\",\n        dest=\"source\",\n        metavar=\"&lt;source&gt;\",\n        help=\"Add a source string. Useful for cross-seeding.\",\n    )\n\n    create_parser.add_argument(\n        \"--config\",\n        action=\"store_true\",\n        dest=\"config\",\n        help=\"\"\"\n        Parse torrent information from a config file. Looks in the current\n        working directory, or the directory named .torrentfile in the users\n        home directory for a torrentfile.ini file. You can also use this\n        option in combination with the --config-path to specify the path to\n        the config file. See documentation for details on properly formatting\n        config file.\n        \"\"\",\n    )\n\n    create_parser.add_argument(\n        \"--config-path\",\n        action=\"store\",\n        metavar=\"&lt;path&gt;\",\n        dest=\"config_path\",\n        help=\"\"\"\n        Use this option in combination with -f or --config\n        options to specify location of config file.\n        \"\"\",\n    )\n\n    create_parser.add_argument(\n        \"-m\",\n        \"--magnet\",\n        action=\"store_true\",\n        dest=\"magnet\",\n    )\n\n    create_parser.add_argument(\n        \"-c\",\n        \"--comment\",\n        action=\"store\",\n        dest=\"comment\",\n        metavar=\"&lt;comment&gt;\",\n        help=\"Include a comment in file metadata\",\n    )\n\n    create_parser.add_argument(\n        \"-o\",\n        \"--out\",\n        action=\"store\",\n        dest=\"outfile\",\n        metavar=\"&lt;path&gt;\",\n        help=\"Explicitly specify the path to write the file .torrent file\",\n    )\n\n    create_parser.add_argument(\n        \"--prog\",\n        \"--progress\",\n        default=\"1\",\n        action=\"store\",\n        dest=\"progress\",\n        help=\"\"\"\n        Set the progress bar level.\n        Options = 0, 1\n        (0) = Do not display progress bar.\n        (1) = Display progress bar.(default)\n        \"\"\",\n    )\n\n    create_parser.add_argument(\n        \"--meta-version\",\n        default=\"1\",\n        choices=[\"1\", \"2\", \"3\"],\n        action=\"store\",\n        dest=\"meta_version\",\n        metavar=\"&lt;int&gt;\",\n        help=\"\"\"\n        Bittorrent metafile version.\n        Options = 1, 2, 3\n        (1) = Bittorrent v1 (Default)\n        (2) = Bittorrent v2\n        (3) = Bittorrent v1 &amp; v2 hybrid\n        \"\"\",\n    )\n\n    create_parser.add_argument(\n        \"--piece-length\",\n        action=\"store\",\n        dest=\"piece_length\",\n        metavar=\"&lt;int&gt;\",\n        help=\"\"\"\n        (Default: auto calculated based on total size of content) Number of\n        bytes for per chunk of data transmitted by Bittorrent client.\n        Acceptable values include integers 14-26 which will be interpreted\n        as exponent for power of 2.  e.g. 14 = 16KiB pieces.\n        Examples:: [--piece-length 14] [--piece-length 20]\n        \"\"\",\n    )\n\n    create_parser.add_argument(\n        \"-w\",\n        \"--web-seed\",\n        action=\"store\",\n        dest=\"url_list\",\n        metavar=\"&lt;url&gt;\",\n        nargs=\"+\",\n        help=\"list of web addresses where torrent data exists (GetRight).\",\n    )\n\n    create_parser.add_argument(\n        \"--http-seed\",\n        action=\"store\",\n        dest=\"httpseeds\",\n        metavar=\"&lt;url&gt;\",\n        nargs=\"+\",\n        help=\"list of URLs, addresses where content can be found (Hoffman).\",\n    )\n\n    create_parser.add_argument(\n        \"content\",\n        action=\"store\",\n        metavar=\"&lt;content&gt;\",\n        nargs=\"?\",\n        help=\"Path to content file or directory\",\n    )\n\n    create_parser.set_defaults(func=create)\n\n    edit_parser = subparsers.add_parser(\n        \"edit\",\n        help=\"\"\"Edit existing torrent meta file.\"\"\",\n        aliases=[\"e\"],\n        prefix_chars=\"-\",\n        formatter_class=TorrentFileHelpFormatter,\n    )\n\n    edit_parser.add_argument(\n        \"metafile\",\n        action=\"store\",\n        help=\"path to *.torrent file\",\n        metavar=\"&lt;*.torrent&gt;\",\n    )\n\n    edit_parser.add_argument(\n        \"--tracker\",\n        action=\"store\",\n        dest=\"announce\",\n        metavar=\"&lt;url&gt;\",\n        nargs=\"+\",\n        help=\"\"\"\n        Replace current list of tracker/announce urls with one or more space\n        seperated Bittorrent tracker announce url(s).\n        \"\"\",\n    )\n\n    edit_parser.add_argument(\n        \"--web-seed\",\n        action=\"store\",\n        dest=\"url_list\",\n        metavar=\"&lt;url&gt;\",\n        nargs=\"+\",\n        help=\"Replace current list of web-seed urls with one or more url(s)\",\n    )\n\n    edit_parser.add_argument(\n        \"--http-seed\",\n        action=\"store\",\n        dest=\"httpseeds\",\n        metavar=\"&lt;url&gt;\",\n        nargs=\"+\",\n        help=\"replace all currently listed addresses with new list (Hoffman).\",\n    )\n\n    edit_parser.add_argument(\n        \"--private\",\n        action=\"store_true\",\n        help=\"Make torrent private.\",\n        dest=\"private\",\n    )\n\n    edit_parser.add_argument(\n        \"--comment\",\n        help=\"Replaces any existing comment with &lt;comment&gt;\",\n        metavar=\"&lt;comment&gt;\",\n        dest=\"comment\",\n        action=\"store\",\n    )\n\n    edit_parser.add_argument(\n        \"--source\",\n        action=\"store\",\n        dest=\"source\",\n        metavar=\"&lt;source&gt;\",\n        help=\"Replaces current source with &lt;source&gt;\",\n    )\n\n    edit_parser.set_defaults(func=edit)\n\n    info_parser = subparsers.add_parser(\n        \"info\",\n        help=\"Show detailed information about a torrent file.\",\n        aliases=[\"i\"],\n        prefix_chars=\"-\",\n        formatter_class=TorrentFileHelpFormatter,\n    )\n\n    info_parser.add_argument(\n        \"metafile\",\n        action=\"store\",\n        metavar=\"&lt;*.torrent&gt;\",\n        help=\"path to pre-existing torrent file.\",\n    )\n\n    info_parser.set_defaults(func=info)\n\n    magnet_parser = subparsers.add_parser(\n        \"magnet\",\n        help=\"Generate magnet url from an existing Bittorrent meta file.\",\n        aliases=[\"m\"],\n        prefix_chars=\"-\",\n        formatter_class=TorrentFileHelpFormatter,\n    )\n\n    magnet_parser.add_argument(\n        \"metafile\",\n        action=\"store\",\n        help=\"Path to Bittorrent meta file.\",\n        metavar=\"&lt;*.torrent&gt;\",\n    )\n\n    magnet_parser.set_defaults(func=magnet)\n\n    check_parser = subparsers.add_parser(\n        \"recheck\",\n        help=\"Gives a detailed look at how much of the torrent is available.\",\n        aliases=[\"check\", \"r\"],\n        prefix_chars=\"-\",\n        formatter_class=TorrentFileHelpFormatter,\n    )\n\n    check_parser.add_argument(\n        \"metafile\",\n        action=\"store\",\n        metavar=\"&lt;*.torrent&gt;\",\n        help=\"path to .torrent file.\",\n    )\n\n    check_parser.add_argument(\n        \"content\",\n        action=\"store\",\n        metavar=\"&lt;content&gt;\",\n        help=\"path to content file or directory\",\n    )\n\n    check_parser.set_defaults(func=recheck)\n\n    rebuild_parser = subparsers.add_parser(\n        \"rebuild\",\n        help=\"\"\"Re-assemble files obtained from a bittorrent file into the\n                appropriate file structure for re-seeding.  Read documentation\n                for more information, or use cases.\"\"\",\n        formatter_class=TorrentFileHelpFormatter,\n    )\n\n    rebuild_parser.add_argument(\n        \"-m\",\n        \"--metafiles\",\n        action=\"store\",\n        metavar=\"&lt;*.torrent&gt;\",\n        nargs=\"+\",\n        dest=\"metafiles\",\n        required=True,\n        help=\"path(s) to .torrent file(s)/folder(s) containing .torrent files\",\n    )\n\n    rebuild_parser.add_argument(\n        \"-c\" \"--contents\",\n        action=\"store\",\n        dest=\"contents\",\n        nargs=\"+\",\n        required=True,\n        metavar=\"&lt;contents&gt;\",\n        help=\"folders that might contain the source contents needed to rebuld\",\n    )\n\n    rebuild_parser.add_argument(\n        \"-d\",\n        \"--destination\",\n        action=\"store\",\n        dest=\"destination\",\n        required=True,\n        metavar=\"&lt;destination&gt;\",\n        help=\"path to where torrents will be re-assembled\",\n    )\n\n    rebuild_parser.set_defaults(func=rebuild)\n\n    rename_parser = subparsers.add_parser(\n        \"rename\",\n        help=\"\"\"Rename a torrent file to it's original name provided in the\n                metadata/the same name you see in your torrent client.\"\"\",\n        formatter_class=TorrentFileHelpFormatter,\n    )\n\n    rename_parser.add_argument(\n        \"target\",\n        action=\"store\",\n        metavar=\"&lt;target&gt;\",\n        help=\"path to file that needs renaming.\",\n    )\n\n    rename_parser.set_defaults(func=rename)\n\n    all_commands = [\n        \"create\",\n        \"new\",\n        \"c\",\n        \"edit\",\n        \"e\",\n        \"info\",\n        \"i\",\n        \"magnet\",\n        \"m\",\n        \"recheck\",\n        \"check\",\n        \"r\",\n        \"rename\",\n        \"rebuild\",\n        \"-i\",\n        \"-h\",\n        \"-V\",\n    ]\n    if not any(i for i in all_commands if i in args):\n        start = 0\n        while args[start] in [\"-v\", \"-q\"]:\n            start += 1\n        args.insert(start, \"create\")\n\n    args = parser.parse_args(args)\n\n    if args.quiet:\n        Config.activate_quiet()\n\n    elif args.debug:\n        Config.activate_logger()\n\n    if hasattr(args, \"func\"):\n        return args.func(args)\n    return args  # pragma: nocover\n</code></pre>"},{"location":"Source/cli/#torrentfile.cli.main","title":"<code>main()</code>","text":"<p>Initiate main function for CLI script.</p> Source code in <code>torrentfile\\cli.py</code> <pre><code>def main():\n\"\"\"\n    Initiate main function for CLI script.\n    \"\"\"\n    execute()\n</code></pre>"},{"location":"Source/commands/","title":"Commands","text":""},{"location":"Source/commands/#torrentfile.commands","title":"<code>commands</code>","text":"<p>The commands module contains the Action Commands executed by the CLI script.</p> <p>Each function pertains to a command line action/subcommand and drives specific features of the application.</p>"},{"location":"Source/commands/#torrentfile.commands--functions","title":"Functions","text":"<ul> <li>create_command</li> <li>info_command</li> <li>edit_command</li> <li>recheck_command</li> <li>magnet_command</li> </ul>"},{"location":"Source/commands/#torrentfile.commands.create","title":"<code>create(args: Namespace) -&gt; Namespace</code>","text":"<p>Execute the create CLI sub-command to create a new torrent metafile.</p> PARAMETER DESCRIPTION <code>args</code> <p>positional and optional CLI arguments.</p> <p> TYPE: <code>Namespace</code> </p> RETURNS DESCRIPTION <code>torrentfile.MetaFile</code> <p>object containing the path to created metafile and its contents.</p> Source code in <code>torrentfile\\commands.py</code> <pre><code>def create(args: Namespace) -&gt; Namespace:\n\"\"\"\n    Execute the create CLI sub-command to create a new torrent metafile.\n\n    Parameters\n    ----------\n    args : Namespace\n        positional and optional CLI arguments.\n\n    Returns\n    -------\n    torrentfile.MetaFile\n        object containing the path to created metafile and its contents.\n    \"\"\"\n    kwargs = vars(args)\n    if args.config:\n        path = find_config_file(args)\n        parse_config_file(path, kwargs)  # pragma: nocover\n\n    if args.outfile:\n        check_path_writable(args.outfile)\n\n    else:  # pragma: nocover\n        samplepath = os.path.join(os.getcwd(), \".torrent\")\n        check_path_writable(samplepath)\n\n    logger.debug(\"Creating torrent from %s\", args.content)\n    if args.meta_version == \"1\":\n        torrent = TorrentFile(**kwargs)\n\n    else:\n        torrent = TorrentAssembler(**kwargs)\n    outfile, meta = torrent.write()\n\n    if args.magnet:\n        magnet(outfile)\n\n    args.torrent = torrent\n    args.kwargs = kwargs\n    args.outfile = outfile\n    args.meta = meta\n\n    print(\"\\nTorrent Save Path: \", os.path.abspath(str(outfile)))\n    logger.debug(\"Output path: %s\", str(outfile))\n    return args\n</code></pre>"},{"location":"Source/commands/#torrentfile.commands.edit","title":"<code>edit(args: Namespace) -&gt; str</code>","text":"<p>Execute the edit CLI sub-command with provided arguments.</p> <p>Provides functionality that can change the details of a torrentfile that preserves all of the hash piece information so as not to break the torrentfile.</p> PARAMETER DESCRIPTION <code>args</code> <p>positional and optional CLI arguments.</p> <p> TYPE: <code>Namespace</code> </p> RETURNS DESCRIPTION <code>str</code> <p>path to edited torrent file.</p> Source code in <code>torrentfile\\commands.py</code> <pre><code>def edit(args: Namespace) -&gt; str:\n\"\"\"\n    Execute the edit CLI sub-command with provided arguments.\n\n    Provides functionality that can change the details of a torrentfile\n    that preserves all of the hash piece information so as not to break\n    the torrentfile.\n\n    Parameters\n    ----------\n    args : Namespace\n        positional and optional CLI arguments.\n\n    Returns\n    -------\n    str\n        path to edited torrent file.\n    \"\"\"\n    metafile = args.metafile\n    logger.info(\"Editing %s Meta File\", str(args.metafile))\n\n    editargs = {\n        \"url-list\": args.url_list,\n        \"httpseeds\": args.httpseeds,\n        \"announce\": args.announce,\n        \"source\": args.source,\n        \"private\": args.private,\n        \"comment\": args.comment,\n    }\n    return edit_torrent(metafile, editargs)\n</code></pre>"},{"location":"Source/commands/#torrentfile.commands.find_config_file","title":"<code>find_config_file(args: Namespace) -&gt; str</code>","text":"<p>Locate the path to the torrentfile configuration file.</p> PARAMETER DESCRIPTION <code>args</code> <p>command line argument values</p> <p> TYPE: <code>Namespace</code> </p> RETURNS DESCRIPTION <code>str</code> <p>path to the configuration file</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>raised if configuration file not found.</p> Source code in <code>torrentfile\\commands.py</code> <pre><code>def find_config_file(args: Namespace) -&gt; str:\n\"\"\"\n    Locate the path to the torrentfile configuration file.\n\n    Parameters\n    ----------\n    args : Namespace\n        command line argument values\n\n    Returns\n    -------\n    str\n        path to the configuration file\n\n    Raises\n    ------\n    FileNotFoundError\n        raised if configuration file not found.\n    \"\"\"\n    path = None\n    error_message = \"Could not find configuration file.\"\n    if args.config_path:\n        if os.path.exists(args.config_path):\n            path = args.config_path\n        else:\n            raise FileNotFoundError(error_message)\n    else:\n        filename = \"torrentfile.ini\"\n        paths = [\n            os.path.join(os.getcwd(), filename),\n            Path.home() / \".torrentfile\" / filename,\n            Path.home() / \".config\" / \".torrentfile\" / filename,\n        ]\n        for subpath in paths:\n            if os.path.exists(subpath):\n                path = subpath\n                break\n    if path is None:\n        raise FileNotFoundError(error_message)\n    return path\n</code></pre>"},{"location":"Source/commands/#torrentfile.commands.info","title":"<code>info(args: Namespace) -&gt; str</code>","text":"<p>Show torrent metafile details to user via stdout.</p> <p>Prints full details of torrent file contents to the terminal in a clean and readable format.</p> PARAMETER DESCRIPTION <code>args</code> <p>command line arguements provided by the user.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The output printed to the terminal.</p> Source code in <code>torrentfile\\commands.py</code> <pre><code>def info(args: Namespace) -&gt; str:\n\"\"\"\n    Show torrent metafile details to user via stdout.\n\n    Prints full details of torrent file contents to the terminal in\n    a clean and readable format.\n\n    Parameters\n    ----------\n    args : dict\n        command line arguements provided by the user.\n\n    Returns\n    -------\n    str\n        The output printed to the terminal.\n    \"\"\"\n    metafile = args.metafile\n    meta = pyben.load(metafile)\n    data = meta[\"info\"]\n    del meta[\"info\"]\n\n    meta.update(data)\n    if \"private\" in meta and meta[\"private\"] == 1:\n        meta[\"private\"] = \"True\"\n\n    if \"announce-list\" in meta:\n        lst = meta[\"announce-list\"]\n        meta[\"announce-list\"] = \", \".join([j for i in lst for j in i])\n\n    if \"url-list\" in meta:\n        meta[\"url-list\"] = \", \".join(meta[\"url-list\"])\n\n    if \"httpseeds\" in meta:\n        meta[\"httpseeds\"] = \", \".join(meta[\"httpseeds\"])\n\n    text = []\n    longest = max(len(i) for i in meta.keys())\n\n    for key, val in meta.items():\n        if key not in [\"pieces\", \"piece layers\", \"files\", \"file tree\"]:\n            prefix = longest - len(key) + 1\n            string = key + (\" \" * prefix) + str(val)\n            text.append(string)\n\n    most = max(len(i) for i in text)\n    text = [\"-\" * most, \"\\n\"] + text + [\"\\n\", \"-\" * most]\n    output = \"\\n\".join(text)\n    logger.info(output)\n    return output\n</code></pre>"},{"location":"Source/commands/#torrentfile.commands.magnet","title":"<code>magnet(metafile: Namespace) -&gt; str</code>","text":"<p>Create a magnet URI from a Bittorrent meta file.</p> PARAMETER DESCRIPTION <code>metafile</code> <p>Namespace class for CLI arguments.</p> <p> TYPE: <code>Namespace</code> </p> RETURNS DESCRIPTION <code>str</code> <p>created magnet URI.</p> Source code in <code>torrentfile\\commands.py</code> <pre><code>def magnet(metafile: Namespace) -&gt; str:\n\"\"\"\n    Create a magnet URI from a Bittorrent meta file.\n\n    Parameters\n    ----------\n    metafile : Namespace\n        Namespace class for CLI arguments.\n\n    Returns\n    -------\n    str\n        created magnet URI.\n    \"\"\"\n    if hasattr(metafile, \"metafile\"):\n        metafile = metafile.metafile\n    if not os.path.exists(metafile):\n        raise FileNotFoundError\n\n    meta = pyben.load(metafile)\n    data = meta[\"info\"]\n    binfo = pyben.dumps(data)\n    infohash = sha1(binfo).hexdigest().upper()  # nosec\n\n    logger.info(\"Magnet Info Hash: %s\", infohash)\n    scheme = \"magnet:\"\n    hasharg = \"?xt=urn:btih:\" + infohash\n    namearg = \"&amp;dn=\" + quote_plus(data[\"name\"])\n\n    if \"announce-list\" in meta:\n        announce_args = [\n            \"&amp;tr=\" + quote_plus(url)\n            for urllist in meta[\"announce-list\"]\n            for url in urllist\n        ]\n    else:\n        announce_args = [\"&amp;tr=\" + quote_plus(meta[\"announce\"])]\n\n    full_uri = \"\".join([scheme, hasharg, namearg] + announce_args)\n    logger.info(\"Created Magnet URI %s\", full_uri)\n    sys.stdout.write(\"\\n\" + full_uri + \"\\n\")\n    return full_uri\n</code></pre>"},{"location":"Source/commands/#torrentfile.commands.parse_config_file","title":"<code>parse_config_file(path: str, kwargs: dict)</code>","text":"<p>Parse configuration file for torrent setup details.</p> PARAMETER DESCRIPTION <code>path</code> <p>path to configuration file</p> <p> TYPE: <code>str</code> </p> <code>kwargs</code> <p>options from command line arguments</p> <p> TYPE: <code>dict</code> </p> Source code in <code>torrentfile\\commands.py</code> <pre><code>def parse_config_file(path: str, kwargs: dict):\n\"\"\"\n    Parse configuration file for torrent setup details.\n\n    Parameters\n    ----------\n    path : str\n        path to configuration file\n    kwargs : dict\n        options from command line arguments\n    \"\"\"\n    config = configparser.ConfigParser()\n    config.read(path)\n\n    for key, val in config[\"config\"].items():\n        if key.lower() in [\"announce\", \"http-seed\", \"web-seed\", \"tracker\"]:\n            val = [i for i in val.split(\"\\n\") if i]\n\n            if key.lower() == \"http-seed\":\n                kwargs[\"httpseeds\"] = val\n\n            elif key.lower() == \"web-seed\":\n                kwargs.setdefault(\"url-list\", [])\n                kwargs[\"url-list\"] = val\n\n            else:\n                kwargs[key.lower()] = val\n\n        elif key.lower() == \"piece-length\":\n            kwargs[\"piece_length\"] = val\n\n        elif key.lower() == \"meta-version\":\n            kwargs[\"meta_version\"] = val\n\n        elif val.lower() == \"true\":\n            kwargs[key.lower()] = True\n\n        elif val.lower() == \"false\":\n            kwargs[key.lower()] = False\n\n        else:\n            kwargs[key.lower()] = val\n</code></pre>"},{"location":"Source/commands/#torrentfile.commands.rebuild","title":"<code>rebuild(args: Namespace) -&gt; int</code>","text":"<p>Attempt to rebuild a torrent based on the a torrent file.</p> <p>Recursively look through a directory for files that belong in a given torrent file, and rebuild as much of the torrent file as possible. Currently only checks if the filename and file size are a match.</p> <ol> <li>Check file hashes to improve accuracy</li> </ol> PARAMETER DESCRIPTION <code>args</code> <p>command line arguments including the paths neccessary</p> <p> TYPE: <code>Namespace</code> </p> RETURNS DESCRIPTION <code>int</code> <p>total number of content files copied to the rebuild directory</p> Source code in <code>torrentfile\\commands.py</code> <pre><code>def rebuild(args: Namespace) -&gt; int:\n\"\"\"\n    Attempt to rebuild a torrent based on the a torrent file.\n\n    Recursively look through a directory for files that belong in\n    a given torrent file, and rebuild as much of the torrent file\n    as possible. Currently only checks if the filename and file\n    size are a match.\n\n    1. Check file hashes to improve accuracy\n\n    Parameters\n    ----------\n    args : Namespace\n        command line arguments including the paths neccessary\n\n    Returns\n    -------\n    int\n        total number of content files copied to the rebuild directory\n    \"\"\"\n    metafiles = args.metafiles\n    dest = args.destination\n    contents = args.contents\n    for path in [*metafiles, *contents]:\n        if not os.path.exists(path):\n            raise FileNotFoundError(path)\n    assembler = Assembler(metafiles, contents, dest)\n    return assembler.assemble_torrents()\n</code></pre>"},{"location":"Source/commands/#torrentfile.commands.recheck","title":"<code>recheck(args: Namespace) -&gt; str</code>","text":"<p>Execute recheck CLI sub-command.</p> <p>Checks the piece hashes within a pre-existing torrent file and does a piece by piece check with the contents of a file or directory for completeness and validation.</p> PARAMETER DESCRIPTION <code>args</code> <p>positional and optional arguments.</p> <p> TYPE: <code>Namespace</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The percentage of content currently saved to disk.</p> Source code in <code>torrentfile\\commands.py</code> <pre><code>def recheck(args: Namespace) -&gt; str:\n\"\"\"\n    Execute recheck CLI sub-command.\n\n    Checks the piece hashes within a pre-existing torrent file\n    and does a piece by piece check with the contents of a file\n    or directory for completeness and validation.\n\n    Parameters\n    ----------\n    args : Namespace\n        positional and optional arguments.\n\n    Returns\n    -------\n    str\n        The percentage of content currently saved to disk.\n    \"\"\"\n    metafile = args.metafile\n    content = args.content\n\n    if os.path.isdir(metafile):\n        raise ArgumentError(\n            f\"Error: Unable to parse directory {metafile}. \"\n            \"Check the order of the parameters.\"\n        )\n\n    logger.debug(\n        \"Validating %s &lt;---------------&gt; %s contents\", metafile, content\n    )\n\n    msg = f\"Rechecking  {metafile} ...\\n\"\n    halfterm = shutil.get_terminal_size().columns / 2\n    padding = int(halfterm - (len(msg) / 2)) * \" \"\n    sys.stdout.write(padding + msg)\n\n    checker = Checker(metafile, content)\n    logger.debug(\"Completed initialization of the Checker class\")\n    result = checker.results()\n\n    message = f\"{content} &lt;- {result}% -&gt; {metafile}\"\n    padding = int(halfterm - (len(message) / 2)) * \" \"\n    sys.stdout.write(padding + message + \"\\n\")\n    sys.stdout.flush()\n    return result\n</code></pre>"},{"location":"Source/commands/#torrentfile.commands.rename","title":"<code>rename(args: Namespace) -&gt; str</code>","text":"<p>Rename a torrent file to it\u2019s original name found in metadata.</p> PARAMETER DESCRIPTION <code>args</code> <p>cli arguments</p> <p> TYPE: <code>Namespace</code> </p> RETURNS DESCRIPTION <code>str</code> <p>renamed file path</p> Source code in <code>torrentfile\\commands.py</code> <pre><code>def rename(args: Namespace) -&gt; str:\n\"\"\"\n    Rename a torrent file to it's original name found in metadata.\n\n    Parameters\n    ----------\n    args: Namespace\n        cli arguments\n\n    Returns\n    -------\n    str\n        renamed file path\n    \"\"\"\n    target = args.target\n    if not target or not os.path.exists(target):\n        raise FileNotFoundError  # pragma: nocover\n    meta = pyben.load(target)\n    name = meta[\"info\"][\"name\"]\n    parent = os.path.dirname(target)\n    new_path = os.path.join(parent, name + \".torrent\")\n    if os.path.exists(new_path):\n        raise FileExistsError  # pragma: nocover\n    os.rename(target, new_path)\n    return new_path\n</code></pre>"},{"location":"Source/edit/","title":"Edit","text":""},{"location":"Source/edit/#torrentfile.edit","title":"<code>edit</code>","text":"<p>Edit torrent module.</p> <p>Provides a facility by which certain properties of a torrent meta file can be edited by the user. The various command line arguments indicate which fields should be edited, and what the new value should be.  Depending on what fields are chosen to edit, this command can trigger a new info hash which means the torrent will no longer be able to participate in the same swarm as the original unedited torrent.</p>"},{"location":"Source/edit/#torrentfile.edit--keywords","title":"Keywords","text":"<p>private comment source trackers web-seeds</p>"},{"location":"Source/edit/#torrentfile.edit.edit_torrent","title":"<code>edit_torrent(metafile: str, args: dict) -&gt; dict</code>","text":"<p>Edit the properties and values in a torrent meta file.</p> PARAMETER DESCRIPTION <code>metafile</code> <p>path to the torrent meta file.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>key value pairs of the properties to be edited.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The edited and nested Meta and info dictionaries.</p> Source code in <code>torrentfile\\edit.py</code> <pre><code>def edit_torrent(metafile: str, args: dict) -&gt; dict:\n\"\"\"\n    Edit the properties and values in a torrent meta file.\n\n    Parameters\n    ----------\n    metafile : str\n        path to the torrent meta file.\n    args : dict\n        key value pairs of the properties to be edited.\n\n    Returns\n    -------\n    dict\n        The edited and nested Meta and info dictionaries.\n    \"\"\"\n    logger.debug(\"editing torrent file %s\", metafile)\n    meta = pyben.load(metafile)\n    info = meta[\"info\"]\n    filter_empty(args, meta, info)\n\n    if \"comment\" in args:\n        info[\"comment\"] = args[\"comment\"]\n\n    if \"source\" in args:\n        info[\"source\"] = args[\"source\"]\n\n    if \"private\" in args:\n        info[\"private\"] = 1\n\n    if \"announce\" in args:\n        val = args.get(\"announce\", None)\n        if isinstance(val, str):\n            vallist = val.split()\n            meta[\"announce\"] = vallist[0]\n            meta[\"announce-list\"] = [vallist]\n        elif isinstance(val, list):\n            meta[\"announce\"] = val[0]\n            meta[\"announce-list\"] = [val]\n\n    if \"url-list\" in args:\n        val = args.get(\"url-list\")\n        if isinstance(val, str):\n            meta[\"url-list\"] = val.split()\n        elif isinstance(val, list):\n            meta[\"url-list\"] = val\n\n    if \"httpseeds\" in args:\n        val = args.get(\"httpseeds\")\n        if isinstance(val, str):\n            meta[\"httpseeds\"] = val.split()\n        elif isinstance(val, list):\n            meta[\"httpseeds\"] = val\n\n    meta[\"info\"] = info\n    os.remove(metafile)\n    pyben.dump(meta, metafile)\n    return meta\n</code></pre>"},{"location":"Source/edit/#torrentfile.edit.filter_empty","title":"<code>filter_empty(args: dict, meta: dict, info: dict)</code>","text":"<p>Remove the fields that were not used by the original file creator.</p> PARAMETER DESCRIPTION <code>args</code> <p>Editable metafile properties from user.</p> <p> TYPE: <code>dict</code> </p> <code>meta</code> <p>Metafile data dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>info</code> <p>Metafile info dictionary.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>torrentfile\\edit.py</code> <pre><code>def filter_empty(args: dict, meta: dict, info: dict):\n\"\"\"\n    Remove the fields that were not used by the original file creator.\n\n    Parameters\n    ----------\n    args : dict\n        Editable metafile properties from user.\n    meta : dict\n        Metafile data dictionary.\n    info : dict\n        Metafile info dictionary.\n    \"\"\"\n    for key, val in list(args.items()):\n        if val is None:\n            del args[key]\n            continue\n\n        if val == \"\":\n            if key in meta:\n                del meta[key]\n            elif key in info:\n                del info[key]\n            del args[key]\n            logger.debug(\"removeing empty fields %s\", val)\n</code></pre>"},{"location":"Source/hasher/","title":"Hasher","text":""},{"location":"Source/hasher/#torrentfile.hasher","title":"<code>hasher</code>","text":"<p>Piece/File Hashers for Bittorrent meta file contents.</p>"},{"location":"Source/hasher/#torrentfile.hasher.FileHasher","title":"<code>FileHasher(path: str, piece_length: int, progress: bool = True, hybrid: bool = False)</code>","text":"<p>         Bases: <code>CbMixin</code>, <code>ProgMixin</code></p> <p>Calculate root and piece hashes for creating hybrid torrent file.</p> <p>Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash.</p> PARAMETER DESCRIPTION <code>path</code> <p>path to target file.</p> <p> TYPE: <code>str</code> </p> <code>piece_length</code> <p>piece length for data chunks.</p> <p> TYPE: <code>int</code> </p> <code>progress</code> <p>default = None</p> <p> TYPE: <code>int</code> DEFAULT: <code>True</code> </p> <p>Construct Hasher class instances for each file in torrent.</p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def __init__(\n    self,\n    path: str,\n    piece_length: int,\n    progress: bool = True,\n    hybrid: bool = False,\n):\n\"\"\"\n    Construct Hasher class instances for each file in torrent.\n    \"\"\"\n    self.path = path\n    self.piece_length = piece_length\n    self.pieces = []\n    self.layer_hashes = []\n    self.piece_layer = None\n    self.root = None\n    self.padding_piece = None\n    self.padding_file = None\n    self.amount = piece_length // BLOCK_SIZE\n    self.end = False\n    self.current = open(path, \"rb\")\n    self.hybrid = hybrid\n    if progress:\n        self.progressbar = True\n        self.prog_start(os.path.getsize(path), path)\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.FileHasher.__iter__","title":"<code>__iter__()</code>","text":"<p>Return <code>self</code>: needed to implement iterator implementation.</p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def __iter__(self):\n\"\"\"Return `self`: needed to implement iterator implementation.\"\"\"\n    return self\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.FileHasher.__next__","title":"<code>__next__() -&gt; bytes</code>","text":"<p>Calculate layer hashes for contents of file.</p> RETURNS DESCRIPTION <code>bytes</code> <p>The layer merckle root hash.</p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def __next__(self) -&gt; bytes:\n\"\"\"\n    Calculate layer hashes for contents of file.\n\n    Returns\n    -------\n    bytes\n        The layer merckle root hash.\n    \"\"\"\n    if self.end:\n        self.end = False\n        raise StopIteration\n    plength = self.piece_length\n    blocks = []\n    piece = sha1()  # nosec\n    total = 0\n    block = bytearray(BLOCK_SIZE)\n    for _ in range(self.amount):\n        size = self.current.readinto(block)\n        if not size:\n            self.end = True\n            break\n        total += size\n        plength -= size\n        blocks.append(sha256(block[:size]).digest())\n        if self.hybrid:\n            piece.update(block[:size])\n    if not blocks:\n        self._calculate_root()\n        raise StopIteration\n    if len(blocks) != self.amount:\n        padding = self._pad_remaining(len(blocks))\n        blocks.extend(padding)\n    self.prog_update(total)\n    layer_hash = merkle_root(blocks)\n    self.layer_hashes.append(layer_hash)\n    self.cb(layer_hash)\n    if self.end:\n        self._calculate_root()\n        self.prog_close()\n    if self.hybrid:\n        if plength &gt; 0:\n            self.padding_file = {\n                \"attr\": \"p\",\n                \"length\": plength,\n                \"path\": [\".pad\", str(plength)],\n            }\n            piece.update(bytes(plength))\n        piece = piece.digest()\n        self.pieces.append(piece)\n        return layer_hash, piece\n    return layer_hash\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.Hasher","title":"<code>Hasher(paths: list, piece_length: int, progress: bool = True)</code>","text":"<p>         Bases: <code>CbMixin</code>, <code>ProgMixin</code></p> <p>Piece hasher for Bittorrent V1 files.</p> <p>Takes a sorted list of all file paths, calculates sha1 hash for fixed size pieces of file data from each file seemlessly until the last piece which may be smaller than others.</p> PARAMETER DESCRIPTION <code>paths</code> <p>List of files.</p> <p> TYPE: <code>list</code> </p> <code>piece_length</code> <p>Size of chuncks to split the data into.</p> <p> TYPE: <code>int</code> </p> <code>progress</code> <p>default = None</p> <p> TYPE: <code>int</code> DEFAULT: <code>True</code> </p> <p>Generate hashes of piece length data from filelist contents.</p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def __init__(self, paths: list, piece_length: int, progress: bool = True):\n\"\"\"Generate hashes of piece length data from filelist contents.\"\"\"\n    self.piece_length = piece_length\n    self.paths = paths\n    self.progress = progress\n    self.total = sum(os.path.getsize(i) for i in self.paths)\n    self.index = 0\n    self.current = open(self.paths[0], \"rb\")\n    if self.progress:\n        total = os.path.getsize(self.paths[0])\n        self.prog_start(total, self.paths[0])\n    logger.debug(\"Hashing %s\", str(self.paths[0]))\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.Hasher.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate through feed pieces.</p> RETURNS DESCRIPTION <code>self</code> <p>Iterator for leaves/hash pieces.</p> <p> TYPE: <code>iterator</code> </p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def __iter__(self):\n\"\"\"\n    Iterate through feed pieces.\n\n    Returns\n    -------\n    self : iterator\n        Iterator for leaves/hash pieces.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.Hasher.__next__","title":"<code>__next__() -&gt; bytes</code>","text":"<p>Generate piece-length pieces of data from input file list.</p> RETURNS DESCRIPTION <code>bytes</code> <p>SHA1 hash of the piece extracted.</p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def __next__(self) -&gt; bytes:\n\"\"\"\n    Generate piece-length pieces of data from input file list.\n\n    Returns\n    -------\n    bytes\n        SHA1 hash of the piece extracted.\n    \"\"\"\n    while True:\n        piece = bytearray(self.piece_length)\n        size = self.current.readinto(piece)\n        if size == 0:\n            if not self.next_file():\n                raise StopIteration\n        elif size &lt; self.piece_length:\n            self.prog_update(size)\n            return self._handle_partial(piece[:size])\n        else:\n            self.prog_update(size)\n            return sha1(piece).digest()  # nosec\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.Hasher.next_file","title":"<code>next_file() -&gt; bool</code>","text":"<p>Seemlessly transition to next file in file list.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if there is a next file otherwise False.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def next_file(self) -&gt; bool:\n\"\"\"\n    Seemlessly transition to next file in file list.\n\n    Returns\n    -------\n    bool:\n        True if there is a next file otherwise False.\n    \"\"\"\n    self.index += 1\n    self.prog_close()\n    if self.index &lt; len(self.paths):\n        path = self.paths[self.index]\n        logger.debug(\"Hashing %s\", str(path))\n        self.current.close()\n        if self.progress:\n            self.prog_start(os.path.getsize(path), path)\n        self.current = open(path, \"rb\")\n        return True\n    return False\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.HasherHybrid","title":"<code>HasherHybrid(path: str, piece_length: int, progress: bool = True)</code>","text":"<p>         Bases: <code>CbMixin</code>, <code>ProgMixin</code></p> <p>Calculate root and piece hashes for creating hybrid torrent file.</p> <p>DEPRECATED</p> <p>Create merkle tree layers from sha256 hashed 16KiB blocks of contents. With a branching factor of 2, merge layer hashes until blocks equal piece_length bytes for the piece layer, and then the root hash.</p> PARAMETER DESCRIPTION <code>path</code> <p>path to target file.</p> <p> TYPE: <code>str</code> </p> <code>piece_length</code> <p>piece length for data chunks.</p> <p> TYPE: <code>int</code> </p> <code>progress</code> <p>default = None</p> <p> TYPE: <code>int</code> DEFAULT: <code>True</code> </p> <p>Construct Hasher class instances for each file in torrent.</p> <p>DEPRECATED</p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def __init__(self, path: str, piece_length: int, progress: bool = True):\n\"\"\"\n    Construct Hasher class instances for each file in torrent.\n\n    **DEPRECATED**\n    \"\"\"\n    self.path = path\n    self.piece_length = piece_length\n    self.pieces = []\n    self.layer_hashes = []\n    self.piece_layer = None\n    self.root = None\n    self.padding_piece = None\n    self.padding_file = None\n    if progress:\n        self.prog_start(os.path.getsize(path), path)\n    self.amount = piece_length // BLOCK_SIZE\n    with open(path, \"rb\") as data:\n        self.process_file(data)\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.HasherHybrid.process_file","title":"<code>process_file(data: bytearray)</code>","text":"<p>Calculate layer hashes for contents of file.</p> <p>DEPRECATED</p> PARAMETER DESCRIPTION <code>data</code> <p>File opened in read mode.</p> <p> TYPE: <code>BytesIO</code> </p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def process_file(self, data: bytearray):\n\"\"\"\n    Calculate layer hashes for contents of file.\n\n    **DEPRECATED**\n\n    Parameters\n    ----------\n    data : BytesIO\n        File opened in read mode.\n    \"\"\"\n    while True:\n        plength = self.piece_length\n        blocks = []\n        piece = sha1()  # nosec\n        total = 0\n        block = bytearray(BLOCK_SIZE)\n        for _ in range(self.amount):\n            size = data.readinto(block)\n            self.prog_update(size)\n            if not size:\n                break\n            total += size\n            plength -= size\n            blocks.append(sha256(block[:size]).digest())\n            piece.update(block[:size])\n        if not blocks:\n            break\n        if len(blocks) != self.amount:\n            padding = self._pad_remaining(len(blocks))\n            blocks.extend(padding)\n        layer_hash = merkle_root(blocks)\n        self.cb(layer_hash)\n        self.layer_hashes.append(layer_hash)\n        if plength &gt; 0:\n            self.padding_file = {\n                \"attr\": \"p\",\n                \"length\": plength,\n                \"path\": [\".pad\", str(plength)],\n            }\n            piece.update(bytes(plength))\n        self.pieces.append(piece.digest())  # nosec\n    self._calculate_root()\n    self.prog_close()\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.HasherV2","title":"<code>HasherV2(path: str, piece_length: int, progress: bool = True)</code>","text":"<p>         Bases: <code>CbMixin</code>, <code>ProgMixin</code></p> <p>Calculate the root hash and piece layers for file contents.</p> <p>DEPRECATED</p> <p>Iterates over 16KiB blocks of data from given file, hashes the data, then creates a hash tree from the individual block hashes until size of hashed data equals the piece-length.  Then continues the hash tree until root hash is calculated.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to file.</p> <p> TYPE: <code>str</code> </p> <code>piece_length</code> <p>Size of layer hashes pieces.</p> <p> TYPE: <code>int</code> </p> <code>progress</code> <p>default = None</p> <p> TYPE: <code>int</code> DEFAULT: <code>True</code> </p> <p>Calculate and store hash information for specific file.</p> <p>DEPRECATED</p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def __init__(self, path: str, piece_length: int, progress: bool = True):\n\"\"\"\n    Calculate and store hash information for specific file.\n\n    **DEPRECATED**\n    \"\"\"\n    self.path = path\n    self.root = None\n    self.piece_layer = None\n    self.layer_hashes = []\n    self.piece_length = piece_length\n    self.num_blocks = piece_length // BLOCK_SIZE\n    if progress:\n        self.prog_start(os.path.getsize(path), path)\n    with open(self.path, \"rb\") as fd:\n        self.process_file(fd)\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.HasherV2.process_file","title":"<code>process_file(fd: str)</code>","text":"<p>Calculate hashes over 16KiB chuncks of file content.</p> <p>DEPRECATED</p> PARAMETER DESCRIPTION <code>fd</code> <p>Opened file in read mode.</p> <p> TYPE: <code>TextIOWrapper</code> </p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def process_file(self, fd: str):\n\"\"\"\n    Calculate hashes over 16KiB chuncks of file content.\n\n    **DEPRECATED**\n\n    Parameters\n    ----------\n    fd : TextIOWrapper\n        Opened file in read mode.\n    \"\"\"\n    while True:\n        blocks = []\n        leaf = bytearray(BLOCK_SIZE)\n        # generate leaves of merkle tree\n\n        for _ in range(self.num_blocks):\n            size = fd.readinto(leaf)\n            self.prog_update(size)\n            if not size:\n                break\n            blocks.append(sha256(leaf[:size]).digest())\n\n        # blocks is empty mean eof\n        if not blocks:\n            break\n        if len(blocks) != self.num_blocks:\n            # when size of file doesn't fill the last block\n            # when the file contains multiple pieces\n            remaining = self.num_blocks - len(blocks)\n            if not self.layer_hashes:\n                # when the there is only one block for file\n                power2 = next_power_2(len(blocks))\n                remaining = power2 - len(blocks)\n\n            # pad the the rest with zeroes to fill remaining space.\n            padding = [bytes(32) for _ in range(remaining)]\n            self.prog_update(HASH_SIZE * remaining)\n            blocks.extend(padding)\n        # calculate the root hash for the merkle tree up to piece-length\n\n        layer_hash = merkle_root(blocks)\n        self.cb(layer_hash)\n        self.layer_hashes.append(layer_hash)\n    self._calculate_root()\n    self.prog_close()\n</code></pre>"},{"location":"Source/hasher/#torrentfile.hasher.merkle_root","title":"<code>merkle_root(blocks: list) -&gt; bytes</code>","text":"<p>Calculate the merkle root for a seq of sha256 hash digests.</p> PARAMETER DESCRIPTION <code>blocks</code> <p>a sequence of sha256 layer hashes.</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>bytes</code> <p>the sha256 root hash of the merkle tree.</p> Source code in <code>torrentfile\\hasher.py</code> <pre><code>def merkle_root(blocks: list) -&gt; bytes:\n\"\"\"\n    Calculate the merkle root for a seq of sha256 hash digests.\n\n    Parameters\n    ----------\n    blocks : list\n        a sequence of sha256 layer hashes.\n\n    Returns\n    -------\n    bytes\n        the sha256 root hash of the merkle tree.\n    \"\"\"\n    if blocks:\n        while len(blocks) &gt; 1:\n            blocks = [\n                sha256(x + y).digest() for x, y in zip(*[iter(blocks)] * 2)\n            ]\n        return blocks[0]\n    return blocks\n</code></pre>"},{"location":"Source/interactive/","title":"Interactive","text":""},{"location":"Source/interactive/#torrentfile.interactive","title":"<code>interactive</code>","text":"<p>Module contains the procedures used for Interactive Mode.</p>"},{"location":"Source/interactive/#torrentfile.interactive--this-module-has-been-deprecated","title":"This module has been deprecated.","text":""},{"location":"Source/interactive/#torrentfile.interactive.InteractiveCreator","title":"<code>InteractiveCreator()</code>","text":"<p>Class namespace for interactive program options.</p> <p>@Deprecated</p> <p>Initialize interactive meta file creator dialog.</p> <p>@Deprecated</p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def __init__(self):\n\"\"\"\n    Initialize interactive meta file creator dialog.\n\n    @Deprecated\n    \"\"\"\n    self.kwargs = {\n        \"announce\": None,\n        \"url_list\": None,\n        \"private\": None,\n        \"source\": None,\n        \"comment\": None,\n        \"piece_length\": None,\n        \"outfile\": None,\n        \"path\": None,\n        \"httpseeds\": None,\n    }\n    self.outfile, self.meta = self.get_props()\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.InteractiveCreator.get_props","title":"<code>get_props()</code>","text":"<p>Gather details for torrentfile from user.</p> <p>@Deprecated</p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def get_props(self):\n\"\"\"\n    Gather details for torrentfile from user.\n\n    @Deprecated\n    \"\"\"\n    piece_length = get_input(\n        \"Piece Length (empty=auto): \", lambda x: x.isdigit()\n    )\n\n    self.kwargs[\"piece_length\"] = piece_length\n    announce = get_input(\n        \"Tracker list (empty): \", lambda x: isinstance(x, str)\n    )\n\n    if announce:\n        self.kwargs[\"announce\"] = announce.split()\n\n    url_list = get_input(\n        \"Web Seed {GetRight} list (empty): \", lambda x: isinstance(x, str)\n    )\n\n    httpseeds = get_input(\n        \"Web Seed {Hoffman} list (empty): \", lambda x: isinstance(x, str)\n    )\n\n    if url_list:\n        self.kwargs[\"url_list\"] = url_list.split()\n    if httpseeds:\n        self.kwargs[\"httpseeds\"] = httpseeds.split()\n    comment = get_input(\"Comment (empty): \", None)\n\n    if comment:\n        self.kwargs[\"comment\"] = comment\n    source = get_input(\"Source (empty): \", None)\n\n    if source:\n        self.kwargs[\"source\"] = source\n\n    private = get_input(\n        \"Private Torrent? {Y/N}: (N)\", lambda x: x in \"yYnN\"\n    )\n\n    if private and private.lower() == \"y\":\n        self.kwargs[\"private\"] = 1\n\n    contents = get_input(\"Content Path: \", os.path.exists)\n    self.kwargs[\"path\"] = contents\n\n    outfile = get_input(\n        f\"Output Path ({contents}.torrent): \",\n        lambda x: os.path.exists(os.path.dirname(x)),\n    )\n\n    if outfile:\n        self.kwargs[\"outfile\"] = outfile\n\n    meta_version = get_input(\n        \"Meta Version {1,2,3}: (1)\", lambda x: x in \"123\"\n    )\n\n    showcenter(f\"creating {outfile}\")\n\n    if meta_version == \"3\":\n        torrent = TorrentFileHybrid(**self.kwargs)\n    elif meta_version == \"2\":\n        torrent = TorrentFileV2(**self.kwargs)\n    else:\n        torrent = TorrentFile(**self.kwargs)\n    return torrent.write()\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.InteractiveEditor","title":"<code>InteractiveEditor(metafile: str)</code>","text":"<p>Interactive dialog class for torrent editing.</p> <p>@Deprecated</p> <p>Initialize the Interactive torrent editor guide.</p> <p>@Deprecated</p> PARAMETER DESCRIPTION <code>metafile</code> <p>user input string identifying the path to a torrent meta file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def __init__(self, metafile: str):\n\"\"\"\n    Initialize the Interactive torrent editor guide.\n\n    @Deprecated\n\n    Parameters\n    ----------\n    metafile : str\n        user input string identifying the path to a torrent meta file.\n    \"\"\"\n    self.metafile = metafile\n    self.meta = pyben.load(metafile)\n    self.info = self.meta[\"info\"]\n\n    self.args = {\n        \"url-list\": self.meta.get(\"url-list\", None),\n        \"httpseeds\": self.meta.get(\"httpseeds\", None),\n        \"announce\": self.meta.get(\"announce-list\", None),\n        \"source\": self.info.get(\"source\", None),\n        \"private\": self.info.get(\"private\", None),\n        \"comment\": self.info.get(\"comment\", None),\n    }\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.InteractiveEditor.edit_props","title":"<code>edit_props()</code>","text":"<p>Loop continuosly for edits until user signals DONE.</p> <p>@Deprecated</p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def edit_props(self):\n\"\"\"\n    Loop continuosly for edits until user signals DONE.\n\n    @Deprecated\n    \"\"\"\n    while True:\n        showcenter(\n            \"Choose the number for a propert the needs editing.\"\n            \"Enter DONE when all editing has been completed.\"\n        )\n\n        props = {\n            1: \"comment\",\n            2: \"source\",\n            3: \"private\",\n            4: \"tracker\",\n            5: \"web-seed\",\n            6: \"httpseeds\",\n        }\n\n        args = {\n            1: \"comment\",\n            2: \"source\",\n            3: \"private\",\n            4: \"announce\",\n            5: \"url-list\",\n            6: \"httpseeds\",\n        }\n\n        txt = \", \".join((str(k) + \": \" + v) for k, v in props.items())\n        prop = get_input(txt)\n        if prop.lower() == \"done\":\n            break\n\n        if prop.isdigit() and 0 &lt; int(prop) &lt; 6:\n            key = props[int(prop)]\n            key2 = args[int(prop)]\n            val = self.args.get(key2)\n            showtext(\n                \"Enter new property value or leave empty for no value.\"\n            )\n            response = get_input(f\"{key.title()} ({val}): \")\n            self.sanatize_response(key2, response)\n\n        else:\n            showtext(\"Invalid input: Try again.\")\n    edit_torrent(self.metafile, self.args)\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.InteractiveEditor.sanatize_response","title":"<code>sanatize_response(key, response)</code>","text":"<p>Convert the input data into a form recognizable by the program.</p> <p>@ Deprecated</p> PARAMETER DESCRIPTION <code>key</code> <p>name of the property and attribute being eddited.</p> <p> TYPE: <code>str</code> </p> <code>response</code> <p>User input value the property is being edited to.</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def sanatize_response(self, key, response):\n\"\"\"\n    Convert the input data into a form recognizable by the program.\n\n    @ Deprecated\n\n    Parameters\n    ----------\n    key : str\n        name of the property and attribute being eddited.\n    response : str\n        User input value the property is being edited to.\n    \"\"\"\n    if key in [\"announce\", \"url-list\", \"httpseeds\"]:\n        val = response.split()\n    else:\n        val = response\n    self.args[key] = val\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.InteractiveEditor.show_current","title":"<code>show_current()</code>","text":"<p>Display the current met file information to screen.</p> <p>@Deprecated</p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def show_current(self):\n\"\"\"\n    Display the current met file information to screen.\n\n    @Deprecated\n    \"\"\"\n    out = \"Current properties and values:\\n\"\n    longest = max(len(label) for label in self.args) + 3\n    for key, val in self.args.items():\n        txt = (key.title() + \":\").ljust(longest) + str(val)\n        out += f\"\\t{txt}\\n\"\n    showtext(out)\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.create_torrent","title":"<code>create_torrent()</code>","text":"<p>Create new torrent file interactively.</p> <p>@Deprecated</p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def create_torrent():\n\"\"\"\n    Create new torrent file interactively.\n\n    @Deprecated\n    \"\"\"\n    showcenter(\"Create Torrent\")\n    showtext(\n        \"\\nEnter values for each of the options for the torrent creator, \"\n        \"or leave blank for program defaults.\\nSpaces are considered item \"\n        \"seperators for options that accept a list of values.\\nValues \"\n        \"enclosed in () indicate the default value, while {} holds all \"\n        \"valid choices available for the option.\\n\\n\"\n    )\n    creator = InteractiveCreator()\n    return creator\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.edit_action","title":"<code>edit_action()</code>","text":"<p>Edit the editable values of the torrent meta file.</p> <p>@Deprecated</p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def edit_action():\n\"\"\"\n    Edit the editable values of the torrent meta file.\n\n    @Deprecated\n    \"\"\"\n    showcenter(\"Edit Torrent\")\n    metafile = get_input(\"Metafile(.torrent): \", os.path.exists)\n    dialog = InteractiveEditor(metafile)\n    dialog.show_current()\n    dialog.edit_props()\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.get_input","title":"<code>get_input(*args: tuple)</code>","text":"<p>Determine appropriate input function to call.</p> <p>@Deprecated</p> PARAMETER DESCRIPTION <code>*args</code> <p>Arbitrary number of args to pass to next function</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The results of the function call.</p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def get_input(*args: tuple):  # pragma: no cover\n\"\"\"\n    Determine appropriate input function to call.\n\n    @Deprecated\n\n    Parameters\n    ----------\n    *args : tuple\n        Arbitrary number of args to pass to next function\n\n    Returns\n    -------\n    str\n        The results of the function call.\n    \"\"\"\n    if len(args) == 2:\n        return _get_input_loop(*args)\n    return _get_input(*args)\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.recheck_torrent","title":"<code>recheck_torrent()</code>","text":"<p>Check torrent download completed percentage.</p> <p>@Deprecated</p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def recheck_torrent():\n\"\"\"\n    Check torrent download completed percentage.\n\n    @Deprecated\n    \"\"\"\n    showcenter(\"Check Torrent\")\n    msg = \"Enter path to torrent contents, and corresponding torrent metafile.\"\n    showtext(msg)\n    metafile = get_input(\n        \"Conent Path (downloads/complete/torrentname):\", os.path.exists\n    )\n    contents = get_input(\"Metafile (*.torrent): \", os.path.exists)\n    checker = Checker(metafile, contents)\n    results = checker.results()\n    showtext(f\"Completion for {metafile} is {results}%\")\n    return results\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.select_action","title":"<code>select_action()</code>","text":"<p>Operate TorrentFile program interactively through terminal.</p> <p>DEPRECATION WARNING: The interactive CLI feature will be deprecated in the future.</p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def select_action():\n\"\"\"\n    Operate TorrentFile program interactively through terminal.\n\n    DEPRECATION WARNING: The interactive CLI feature will be deprecated\n    in the future.\n    \"\"\"\n    showcenter(\"TorrentFile: Starting Interactive Mode\")\n    showcenter(\n        \"DEPRECATION WARNING: The interactive feature will be\"\n        \"deprecated in the near future.\"\n    )\n    action = get_input(\n        \"Enter the action you wish to perform.\\n\"\n        \"Action ( Create (c) | Edit (e) | Recheck (r) ): \"\n    )\n    action = action.lower()\n\n    if \"create\" in action or action == \"c\":\n        return create_torrent()\n\n    if \"check\" in action or action == \"r\":\n        return recheck_torrent()\n\n    if \"edit\" in action or action == \"e\":\n        return edit_action()\n    print(\"Unable to recognize input.  Please try again.\")  # pragma: nocover\n    return select_action()  # pragma: nocover\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.showcenter","title":"<code>showcenter(txt: str)</code>","text":"<p>Print text to screen in the center position of the terminal.</p> <p>@Deprecated</p> PARAMETER DESCRIPTION <code>txt</code> <p>the preformated message to send to stdout.</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def showcenter(txt: str):\n\"\"\"\n    Print text to screen in the center position of the terminal.\n\n    @Deprecated\n\n    Parameters\n    ----------\n    txt : str\n        the preformated message to send to stdout.\n    \"\"\"\n    termlen = shutil.get_terminal_size().columns\n    padding = \" \" * int(((termlen - len(txt)) / 2))\n    string = \"\".join([\"\\n\", padding, txt, \"\\n\"])\n    showtext(string)\n</code></pre>"},{"location":"Source/interactive/#torrentfile.interactive.showtext","title":"<code>showtext(txt)</code>","text":"<p>Print contents of txt to screen.</p> <p>@Deprecated</p> PARAMETER DESCRIPTION <code>txt</code> <p>text to print to terminal.</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\interactive.py</code> <pre><code>def showtext(txt):\n\"\"\"\n    Print contents of txt to screen.\n\n    @Deprecated\n\n    Parameters\n    ----------\n    txt : str\n        text to print to terminal.\n    \"\"\"\n    sys.stdout.write(txt)\n</code></pre>"},{"location":"Source/mixins/","title":"Mixins","text":""},{"location":"Source/mixins/#torrentfile.mixins","title":"<code>mixins</code>","text":"<p>Collection of classes that can be used as Mixins with other base classes.</p> <p>Classes such as TorrentFile, TorrentFilev2, and all Hasher classes can use the progress bar mixin.  And any class is eligible to use the callback mixin.</p>"},{"location":"Source/mixins/#torrentfile.mixins.CbMixin","title":"<code>CbMixin</code>","text":"<p>Mixin class to set a callback during hashing procedure.</p>"},{"location":"Source/mixins/#torrentfile.mixins.CbMixin.cb","title":"<code>cb(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Do nothing.</p> Source code in <code>torrentfile\\mixins.py</code> <pre><code>@classmethod\ndef cb(cls, *args, **kwargs):\n\"\"\"Do nothing.\"\"\"\n</code></pre>"},{"location":"Source/mixins/#torrentfile.mixins.CbMixin.set_callback","title":"<code>set_callback(func)</code>  <code>classmethod</code>","text":"<p>Assign a callback to the Hashing class.</p> PARAMETER DESCRIPTION <code>func</code> <p>the callback function</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>torrentfile\\mixins.py</code> <pre><code>@classmethod\ndef set_callback(cls, func):\n\"\"\"\n    Assign a callback to the Hashing class.\n\n    Parameters\n    ----------\n    func : Callable\n        the callback function\n    \"\"\"\n    cls.cb = func  # pragma: nocover\n</code></pre>"},{"location":"Source/mixins/#torrentfile.mixins.ProgMixin","title":"<code>ProgMixin</code>","text":"<p>Progress bar mixin class.</p> <p>Displays progress of hashing individual files, usefull when hashing really big files.</p>"},{"location":"Source/mixins/#torrentfile.mixins.ProgMixin.is_active","title":"<code>is_active() -&gt; bool</code>","text":"<p>Test to see if there is an active progress bar for object.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if there is, otherwise False.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>torrentfile\\mixins.py</code> <pre><code>def is_active(self) -&gt; bool:\n\"\"\"\n    Test to see if there is an active progress bar for object.\n\n    Returns\n    -------\n    bool :\n        True if there is, otherwise False.\n    \"\"\"\n    if not debug_is_on() and hasattr(self, \"prog\"):\n        return True\n    return False\n</code></pre>"},{"location":"Source/mixins/#torrentfile.mixins.ProgMixin.prog_close","title":"<code>prog_close()</code>","text":"<p>Finalize the last bits of progress bar.</p> <p>Increment the terminal by one line leaving the progress bar in place, and deleting the progress bar object to clear a space for the next one.</p> Source code in <code>torrentfile\\mixins.py</code> <pre><code>def prog_close(self):\n\"\"\"\n    Finalize the last bits of progress bar.\n\n    Increment the terminal by one line leaving the progress bar in place,\n    and deleting the progress bar object to clear a space for the next one.\n    \"\"\"\n    if self.is_active():\n        sys.stdout.flush()\n        sys.stdout.write(\"\\n\")\n        del self.prog\n</code></pre>"},{"location":"Source/mixins/#torrentfile.mixins.ProgMixin.prog_start","title":"<code>prog_start(total: int, path: str, length: int = 50, unit: str = 'bytes')</code>","text":"<p>Generate a new progress bar for the given file path.</p> PARAMETER DESCRIPTION <code>total</code> <p>the total amount of units accumulating towards.</p> <p> TYPE: <code>int</code> </p> <code>path</code> <p>path to file being hashed.</p> <p> TYPE: <code>str</code> </p> <code>length</code> <p>the number of characters of the actual progress bar.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> <code>unit</code> <p>the text representation of the value being measured.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'bytes'</code> </p> Source code in <code>torrentfile\\mixins.py</code> <pre><code>def prog_start(\n    self, total: int, path: str, length: int = 50, unit: str = \"bytes\"\n):\n\"\"\"\n    Generate a new progress bar for the given file path.\n\n    Parameters\n    ----------\n    total : int\n        the total amount of units accumulating towards.\n    path : str\n        path to file being hashed.\n    length : int\n        the number of characters of the actual progress bar.\n    unit : str\n        the text representation of the value being measured.\n    \"\"\"\n    title = path\n    width = shutil.get_terminal_size().columns\n    if len(str(title)) &gt;= width // 2:\n        parts = list(Path(title).parts)\n        while (len(\"//\".join(parts)) &gt; (width // 2)) and (len(parts) &gt; 0):\n            del parts[0]\n        if parts:\n            title = os.path.join(*parts)\n        else:\n            title = os.path.basename(path)  # pragma: nocover\n    length = min(length, width // 2)\n    start = width - int(length * 1.5)\n    self.prog = ProgressBar(total, title, length, unit, start)\n</code></pre>"},{"location":"Source/mixins/#torrentfile.mixins.ProgMixin.prog_update","title":"<code>prog_update(val: int)</code>","text":"<p>Update progress bar.</p> <p>Using the value provided, increment the progress bar by that value.</p> PARAMETER DESCRIPTION <code>val</code> <p>the number of bytes count the progress bar should increase.</p> <p> TYPE: <code>int</code> </p> Source code in <code>torrentfile\\mixins.py</code> <pre><code>def prog_update(self, val: int):\n\"\"\"\n    Update progress bar.\n\n    Using the value provided, increment the progress bar by that value.\n\n    Parameters\n    ----------\n    val : int\n        the number of bytes count the progress bar should increase.\n    \"\"\"\n    if self.is_active():\n        self.prog.state += val\n        pbar = self.prog.get_progress()\n        output = f\"{self.prog.prefix}{pbar}{self.prog.suffix}\\r\"\n        sys.stdout.write(output)\n        sys.stdout.flush()\n</code></pre>"},{"location":"Source/mixins/#torrentfile.mixins.ProgressBar","title":"<code>ProgressBar(total: int, title: str, length: int, unit: str, start: int)</code>","text":"<p>Holds the state and details of the terminal progress bars.</p> PARAMETER DESCRIPTION <code>total</code> <p>the total amount to be accumulated.</p> <p> TYPE: <code>int</code> </p> <code>title</code> <p>the subject of the progress tracker</p> <p> TYPE: <code>str</code> </p> <code>length</code> <p>the width of the progress bar</p> <p> TYPE: <code>int</code> </p> <code>unit</code> <p>the text representation incremented</p> <p> TYPE: <code>str</code> </p> <code>start</code> <p>column where the progress bar should be drawn</p> <p> TYPE: <code>int</code> </p> <p>Construct the progress bar object and store state of it\u2019s properties.</p> Source code in <code>torrentfile\\mixins.py</code> <pre><code>def __init__(\n    self, total: int, title: str, length: int, unit: str, start: int\n):\n\"\"\"\n    Construct the progress bar object and store state of it's properties.\n    \"\"\"\n    self.total = total\n    self.start = start\n    self.length = length\n    self.fill = chr(9608)\n    self.empty = chr(9617)\n    self.state = 0\n    self.unit = unit\n    self.show_total = total\n    if not unit:\n        self.unit = \"\"  # pragma: nocover\n    elif unit == \"bytes\":\n        if self.total &gt; 1_000_000_000:\n            self.show_total = math.floor(self.total / (2**30))\n            self.unit = \"GiB\"\n        elif self.total &gt; 1_000_000:\n            self.show_total = math.floor(self.total / 1048576)\n            self.unit = \"MiB\"\n        elif self.total &gt; 10000:\n            self.show_total = math.floor(self.total / 1024)\n            self.unit = \"KiB\"\n    self.suffix = f\"/{self.show_total} {self.unit}\"\n    title = str(title)\n    if len(title) &gt; start:\n        title = title[: start - 1]  # pragma: nocover\n    padding = (start - len(title)) * \" \"\n    self.prefix = \"\".join([title, padding])\n</code></pre>"},{"location":"Source/mixins/#torrentfile.mixins.ProgressBar.get_progress","title":"<code>get_progress() -&gt; str</code>","text":"<p>Return the size of the filled portion of the progress bar.</p> RETURNS DESCRIPTION <code>str</code> <p>the progress bar characters</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\mixins.py</code> <pre><code>def get_progress(self) -&gt; str:\n\"\"\"\n    Return the size of the filled portion of the progress bar.\n\n    Returns\n    -------\n    str :\n        the progress bar characters\n    \"\"\"\n    if self.state &gt;= self.total:\n        fill = self.length\n    else:\n        fill = math.ceil((self.state / self.total) * self.length)\n    empt = self.length - fill\n    if self.unit == \"GiB\":\n        state = math.floor(self.state / (2**30))\n    elif self.unit == \"MiB\":\n        state = math.floor(self.state / 1048576)\n    elif self.unit == \"KiB\":\n        state = math.floor(self.state / 1024)\n    else:\n        state = self.state\n    progbar = [\"|\", self.fill * fill, self.empty * empt, \"| \", str(state)]\n    return \"\".join(progbar)\n</code></pre>"},{"location":"Source/mixins/#torrentfile.mixins.waiting","title":"<code>waiting(msg: str, flag: list, timeout: int = 20)</code>","text":"<p>Show loading message while thread completes processing.</p> PARAMETER DESCRIPTION <code>msg</code> <p>Message string printed before the progress bar</p> <p> TYPE: <code>str</code> </p> <code>flag</code> <p>Once flag is filled exit loop</p> <p> TYPE: <code>list</code> </p> <code>timeout</code> <p>max amount of time to run the function.</p> <p> TYPE: <code>int</code> DEFAULT: <code>20</code> </p> Source code in <code>torrentfile\\mixins.py</code> <pre><code>def waiting(msg: str, flag: list, timeout: int = 20):\n\"\"\"\n    Show loading message while thread completes processing.\n\n    Parameters\n    ----------\n    msg : str\n        Message string printed before the progress bar\n    flag : list\n        Once flag is filled exit loop\n    timeout : int\n        max amount of time to run the function.\n    \"\"\"\n    then = time.time()\n    codes, fill = list(range(9617, 9620)), chr(9619)\n    size = idx = 0\n    total = shutil.get_terminal_size().columns - len(msg) - 20\n\n    def output(text: str):\n\"\"\"\n        Print parameter message to the console.\n\n        Parameters\n        ----------\n        text : str\n            output message\n        \"\"\"\n        sys.stdout.write(text)\n        sys.stdout.flush()\n\n    output(\"\\n\")\n    time.sleep(0.16)\n    while len(flag) == 0:\n        time.sleep(0.16)\n        filled = (fill * size) + chr(codes[idx]) + (\" \" * (total - size))\n        output(f\"{msg}: {filled}\\r\")\n        idx = idx + 1 if idx + 1 &lt; len(codes) else 0\n        size = size + 1 if size &lt; total else 0\n        if time.time() - then &gt; timeout:\n            break\n    output(\"\\n\")\n</code></pre>"},{"location":"Source/rebuild/","title":"Rebuild","text":""},{"location":"Source/rebuild/#torrentfile.rebuild","title":"<code>rebuild</code>","text":"<p>Clases and functions for the rebuild or reassemble subcommand.</p> <p>Re-assemble a torrent into the propper directory structure as indicated by a torrent meta file, and validate the contents of each file allong the way. Displays a progress bar for each torrent.</p>"},{"location":"Source/rebuild/#torrentfile.rebuild.Assembler","title":"<code>Assembler(metafiles: list, contents: list, dest: str)</code>","text":"<p>         Bases: <code>CbMixin</code></p> <p>Does most of the work in attempting the structure of torrentfiles.</p> <p>Requires three paths as arguments. - torrent metafile or directory containing multiple meta files - directory containing the contents of meta file - directory where torrents will be re-assembled</p> <p>Reassemble given torrent file from given cli arguments.</p> <p>Rebuild metafiles and contents into their original directory structure as much as possible in the destination directory. Takes two paths as parameters, - file or directory containing 1 or more torrent meta files - path to where the contents are belived to be located.</p> PARAMETER DESCRIPTION <code>metafiles</code> <p>path to torrent metafile or directory containing torrent metafiles.</p> <p> TYPE: <code>str</code> </p> <code>contents</code> <p>path to content or directory containing content that belongs to torrentfile.</p> <p> TYPE: <code>str</code> </p> <code>dest</code> <p>path to the directory where rebuild will take place.</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def __init__(self, metafiles: list, contents: list, dest: str):\n\"\"\"\n    Reassemble given torrent file from given cli arguments.\n\n    Rebuild metafiles and contents into their original directory\n    structure as much as possible in the destination directory.\n    Takes two paths as parameters,\n    - file or directory containing 1 or more torrent meta files\n    - path to where the contents are belived to be located.\n\n    Parameters\n    ----------\n    metafiles : str\n        path to torrent metafile or directory containing torrent metafiles.\n    contents : str\n        path to content or directory containing content that belongs to\n        torrentfile.\n    dest: str\n        path to the directory where rebuild will take place.\n    \"\"\"\n    Metadata.set_callback(self._callback)\n    self.counter = 0\n    self._lastlog = None\n    self.contents = contents\n    self.dest = dest\n    self.meta_paths = metafiles\n    self.metafiles = self._get_metafiles()\n    filenames = set()\n    for meta in self.metafiles:\n        filenames |= meta.filenames\n    self.filemap = _index_contents(self.contents, filenames)\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.Assembler.assemble_torrents","title":"<code>assemble_torrents()</code>","text":"<p>Assemble collection of torrent files into original structure.</p> RETURNS DESCRIPTION <code>int</code> <p>number of files copied</p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def assemble_torrents(self):\n\"\"\"\n    Assemble collection of torrent files into original structure.\n\n    Returns\n    -------\n    int\n        number of files copied\n    \"\"\"\n    for metafile in self.metafiles:\n        logger.info(\n            \"#%s Searching contents for %s\", self.counter, metafile.name\n        )\n        self.rebuild(metafile)\n    return self.counter\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.Assembler.rebuild","title":"<code>rebuild(metafile: Metadata) -&gt; None</code>","text":"<p>Build the torrent file structure from contents of directory.</p> <p>Traverse contents dir and compare discovered files with files listed in torrent metadata and copy the matches to the destination directory respecting folder structures along the way.</p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def rebuild(self, metafile: Metadata) -&gt; None:\n\"\"\"\n    Build the torrent file structure from contents of directory.\n\n    Traverse contents dir and compare discovered files\n    with files listed in torrent metadata and copy\n    the matches to the destination directory respecting folder\n    structures along the way.\n    \"\"\"\n    metafile.rebuild(self.filemap, self.dest)\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.Metadata","title":"<code>Metadata(path: str)</code>","text":"<p>         Bases: <code>CbMixin</code>, <code>ProgMixin</code></p> <p>Class containing the metadata contents of a torrent file.</p> <p>Construct metadata object for torrent info.</p> PARAMETER DESCRIPTION <code>path</code> <p>path to the .torrent file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def __init__(self, path: str):\n\"\"\"\n    Construct metadata object for torrent info.\n\n    Parameters\n    ----------\n    path : str\n        path to the .torrent file.\n    \"\"\"\n    self.path = os.path.abspath(path)\n    self.name = None\n    self.piece_length = 1\n    self.meta_version = 1\n    self.pieces = b\"\"\n    self.piece_nodes = []\n    self.length = 0\n    self.files = []\n    self.filenames = set()\n    self.extract()\n    if self.meta_version == 2:\n        self.num_pieces = len(self.filenames)\n    else:\n        self.num_pieces = math.ceil(len(self.pieces) / SHA1)\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.Metadata.extract","title":"<code>extract()</code>","text":"<p>Decode and extract information for the .torrent file.</p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def extract(self):\n\"\"\"\n    Decode and extract information for the .torrent file.\n    \"\"\"\n    meta = pyben.load(self.path)\n    info = meta[\"info\"]\n    self.piece_length = info[\"piece length\"]\n    self.name = info[\"name\"]\n    self.meta_version = info.get(\"meta version\", 1)\n    self.pieces = info.get(\"pieces\", bytes())\n    if self.meta_version == 2:\n        self._parse_tree(info[\"file tree\"], [self.name])\n    elif \"length\" in info:\n        self.length += info[\"length\"]\n        self.is_file = True\n        self.filenames.add(info[\"name\"])\n        self.files.append(\n            {\n                \"path\": Path(self.name).parent,\n                \"filename\": self.name,\n                \"full\": self.name,\n                \"length\": self.length,\n            }\n        )\n    elif \"files\" in info:\n        for f in info[\"files\"]:\n            path = f[\"path\"]\n            full = os.path.join(self.name, *path)\n            self.files.append(\n                {\n                    \"path\": Path(full).parent,\n                    \"filename\": path[-1],\n                    \"full\": full,\n                    \"length\": f[\"length\"],\n                }\n            )\n            self.length += f[\"length\"]\n            self.filenames.add(path[-1])\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.Metadata.rebuild","title":"<code>rebuild(filemap: dict, dest: str)</code>","text":"<p>Rebuild torrent file contents from filemap at dest.</p> <p>Searches through the contents of the meta file and compares filenames with those in the filemap dict, and if found checks their contents, and copies them to the destination path.</p> PARAMETER DESCRIPTION <code>filemap</code> <p>filesystem information</p> <p> TYPE: <code>dict</code> </p> <code>dest</code> <p>destiantion path</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def rebuild(self, filemap: dict, dest: str):\n\"\"\"\n    Rebuild torrent file contents from filemap at dest.\n\n    Searches through the contents of the meta file and compares filenames\n    with those in the filemap dict, and if found checks their contents,\n    and copies them to the destination path.\n\n    Parameters\n    ----------\n    filemap : dict\n        filesystem information\n    dest : str\n        destiantion path\n    \"\"\"\n    self._prog = None\n    if self.meta_version == 2:\n        self._match_v2(filemap, dest)\n    else:\n        self._match_v1(filemap, dest)\n    if self._prog is not None:\n        self.prog_close()\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.PathNode","title":"<code>PathNode(start: int = None, stop: int = None, full: str = None, filename: str = None, path: str = None, length: int = None)</code>","text":"<p>Base class representing information regarding a file included in torrent.</p> <p>Hold file information that contributes to the contents of torrent.</p> PARAMETER DESCRIPTION <code>start</code> <p>where the piece starts, by default None</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>None</code> </p> <code>stop</code> <p>where the piece ends, by default None</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>None</code> </p> <code>full</code> <p>full path, by default None</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>None</code> </p> <code>filename</code> <p>filename, by default None</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>None</code> </p> <code>path</code> <p>parent path, by default None</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>None</code> </p> <code>length</code> <p>size, by default None</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>None</code> </p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def __init__(\n    self,\n    start: int = None,\n    stop: int = None,\n    full: str = None,\n    filename: str = None,\n    path: str = None,\n    length: int = None,\n):\n\"\"\"\n    Hold file information that contributes to the contents of torrent.\n\n    Parameters\n    ----------\n    start : int, optional\n        where the piece starts, by default None\n    stop : int, optional\n        where the piece ends, by default None\n    full : str, optional\n        full path, by default None\n    filename : str, optional\n        filename, by default None\n    path : str, optional\n        parent path, by default None\n    length : int, optional\n        size, by default None\n    \"\"\"\n    self.path = path\n    self.start = start\n    self.stop = stop\n    self.length = length\n    self.filename = filename\n    self.full = full\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.PathNode.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Return size of the file.</p> RETURNS DESCRIPTION <code>int</code> <p>total size</p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Return size of the file.\n\n    Returns\n    -------\n    int\n        total size\n    \"\"\"\n    return self.length\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.PathNode.get_part","title":"<code>get_part(path: str) -&gt; bytes</code>","text":"<p>Extract the part of the file needed to complete the hash.</p> PARAMETER DESCRIPTION <code>path</code> <p>filesystem path location of file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bytes</code> <p>part of the file\u2019s contents</p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def get_part(self, path: str) -&gt; bytes:\n\"\"\"\n    Extract the part of the file needed to complete the hash.\n\n    Parameters\n    ----------\n    path : str\n        filesystem path location of file.\n\n    Returns\n    -------\n    bytes\n        part of the file's contents\n    \"\"\"\n    with open(path, \"rb\") as fd:\n        if self.start:\n            fd.seek(self.start)\n        if self.stop != -1:\n            partial = fd.read(self.stop - self.start)\n        else:\n            partial = fd.read()\n    return partial\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.PieceNode","title":"<code>PieceNode(piece: bytes)</code>","text":"<p>Base class representing a single SHA1 hash block of data from a torrent.</p> <p>Store information about an individual SHA1 hash for a torrent file.</p> <p>extended_summary</p> PARAMETER DESCRIPTION <code>piece</code> <p>SHA1 hash bytes</p> <p> TYPE: <code>bytes</code> </p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def __init__(self, piece: bytes):\n\"\"\"\n    Store information about an individual SHA1 hash for a torrent file.\n\n    _extended_summary_\n\n    Parameters\n    ----------\n    piece : bytes\n        SHA1 hash bytes\n    \"\"\"\n    self.piece = piece\n    self.paths = []\n    self.result = None\n    self.dest = None\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.PieceNode.append","title":"<code>append(pathnode: PathNode)</code>","text":"<p>Append the path argument to the paths list attribute.</p> PARAMETER DESCRIPTION <code>pathnode</code> <p>the pathnode</p> <p> TYPE: <code>PathNode</code> </p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def append(self, pathnode: PathNode):\n\"\"\"\n    Append the path argument to the paths list attribute.\n\n    Parameters\n    ----------\n    pathnode : PathNode\n        the pathnode\n    \"\"\"\n    self.paths.append(pathnode)\n</code></pre>"},{"location":"Source/rebuild/#torrentfile.rebuild.PieceNode.find_matches","title":"<code>find_matches(filemap: dict, dest: str) -&gt; bool</code>","text":"<p>Find the matching files for each path in the node.</p> PARAMETER DESCRIPTION <code>filemap</code> <p>filename and details</p> <p> TYPE: <code>dict</code> </p> <code>dest</code> <p>target destination path</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>success status</p> Source code in <code>torrentfile\\rebuild.py</code> <pre><code>def find_matches(self, filemap: dict, dest: str) -&gt; bool:\n\"\"\"\n    Find the matching files for each path in the node.\n\n    Parameters\n    ----------\n    filemap : dict\n        filename and details\n    dest : str\n        target destination path\n\n    Returns\n    -------\n    bool\n        success status\n    \"\"\"\n    self.dest = dest\n    self.result = self._find_matches(filemap, self.paths[:], bytes())\n    return self.result\n</code></pre>"},{"location":"Source/recheck/","title":"Recheck","text":""},{"location":"Source/recheck/#torrentfile.recheck","title":"<code>recheck</code>","text":"<p>Module container Checker Class.</p> <p>The CheckerClass takes a torrentfile and tha path to it\u2019s contents. It will then iterate through every file and directory contained and compare their data to values contained within the torrent file. Completion percentages will be printed to screen for each file and at the end for the torrentfile as a whole.</p>"},{"location":"Source/recheck/#torrentfile.recheck.Checker","title":"<code>Checker(metafile: str, path: str)</code>","text":"<p>Check a given file or directory to see if it matches a torrentfile.</p> <p>Public constructor for Checker class instance.</p> PARAMETER DESCRIPTION <code>metafile</code> <p>Path to \u201c.torrent\u201d file.</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>Path where the content is located in filesystem.</p> <p> TYPE: <code>str</code> </p>"},{"location":"Source/recheck/#torrentfile.recheck.Checker--example","title":"Example","text":"<pre><code>&gt;&gt; metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\"\n&gt;&gt; location = \"/path/to/location\"\n&gt;&gt; os.path.exists(\"/path/to/location/content_file_or_dir\")\nOut: True\n&gt;&gt; checker = Checker(metafile, location)\n</code></pre> <p>Validate data against hashes contained in .torrent file.</p> PARAMETER DESCRIPTION <code>metafile</code> <p>path to .torrent file</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>path to content or contents parent directory.</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __init__(self, metafile: str, path: str):\n\"\"\"\n    Validate data against hashes contained in .torrent file.\n\n    Parameters\n    ----------\n    metafile : str\n        path to .torrent file\n    path : str\n        path to content or contents parent directory.\n    \"\"\"\n    if not os.path.exists(metafile):\n        raise FileNotFoundError\n    if os.path.isdir(metafile):\n        raise ArgumentError(\n            \"The &lt;metafile&gt; must be a .torrent file. Not a directory\"\n        )\n    self.last_log = None\n    self.log_msg(\"Checking: %s, %s\", metafile, path)\n    self.metafile = metafile\n    self.total = 0\n    self.paths = []\n    self.fileinfo = {}\n    print(\"Extracting data from torrent file...\")\n    self.meta = pyben.load(metafile)\n    self.info = self.meta[\"info\"]\n    self.name = self.info[\"name\"]\n    self.piece_length = self.info[\"piece length\"]\n\n    if \"meta version\" in self.info:\n        if \"pieces\" in self.info:\n            self.meta_version = 3\n        else:\n            self.meta_version = 2\n    else:\n        self.meta_version = 1\n\n    self.root = self.find_root(path)\n    self.check_paths()\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.Checker.check_paths","title":"<code>check_paths()</code>","text":"<p>Gather all file paths described in the torrent file.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def check_paths(self):\n\"\"\"\n    Gather all file paths described in the torrent file.\n    \"\"\"\n    finfo = self.fileinfo\n\n    if \"length\" in self.info:\n        self.log_msg(\"%s points to a single file\", self.root)\n        self.total = self.info[\"length\"]\n        self.paths.append(str(self.root))\n\n        finfo[0] = {\n            \"path\": self.root,\n            \"length\": self.info[\"length\"],\n        }\n\n        if self.meta_version &gt; 1:\n            root = self.info[\"file tree\"][self.name][\"\"][\"pieces root\"]\n            finfo[0][\"pieces root\"] = root\n\n        return\n\n    # Otherwise Content is more than 1 file.\n    self.log_msg(\"%s points to a directory\", self.root)\n    if self.meta_version == 1:\n        for i, item in enumerate(self.info[\"files\"]):\n            self.total += item[\"length\"]\n            base = os.path.join(*item[\"path\"])\n\n            self.fileinfo[i] = {\n                \"path\": str(self.root / base),\n                \"length\": item[\"length\"],\n            }\n\n            self.paths.append(str(self.root / base))\n        return\n\n    self.walk_file_tree(self.info[\"file tree\"], [])\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.Checker.find_root","title":"<code>find_root(path: str) -&gt; str</code>","text":"<p>Check path for torrent content.</p> <p>The path can be a relative or absolute filesystem path.  In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory.  If content points to a directory.  The directory will be checked to see if it matches the torrent\u2019s name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent\u2019s name.</p> PARAMETER DESCRIPTION <code>path</code> <p>root path to torrent content</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>root path to content</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def find_root(self, path: str) -&gt; str:\n\"\"\"\n    Check path for torrent content.\n\n    The path can be a relative or absolute filesystem path.  In the case\n    where the content is a single file, the path may point directly to the\n    the file, or it may point to the parent directory.  If content points\n    to a directory.  The directory will be checked to see if it matches\n    the torrent's name, if not the directories contents will be searched.\n    The returned value will be the absolute path that matches the torrent's\n    name.\n\n    Parameters\n    ----------\n    path : str\n        root path to torrent content\n\n    Returns\n    -------\n    str\n        root path to content\n    \"\"\"\n    if not os.path.exists(path):\n        self.log_msg(\"Could not locate torrent content %s.\", path)\n        raise FileNotFoundError(path)\n\n    root = Path(path)\n    if root.name == self.name:\n        self.log_msg(\"Content found: %s.\", str(root))\n        return root\n\n    if self.name in os.listdir(root):\n        return root / self.name\n\n    self.log_msg(\"Could not locate torrent content in: %s\", str(root))\n    raise FileNotFoundError(root)\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.Checker.iter_hashes","title":"<code>iter_hashes() -&gt; tuple</code>","text":"<p>Produce results of comparing torrent contents piece by piece.</p> YIELDS DESCRIPTION <code>chunck</code> <p>hash of data found on disk</p> <p> TYPE: <code>bytes</code> </p> <code>piece</code> <p>hash of data when complete and correct</p> <p> TYPE: <code>bytes</code> </p> <code>path</code> <p>path to file being hashed</p> <p> TYPE: <code>str</code> </p> <code>size</code> <p>length of bytes hashed for piece</p> <p> TYPE: <code>int</code> </p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def iter_hashes(self) -&gt; tuple:\n\"\"\"\n    Produce results of comparing torrent contents piece by piece.\n\n    Yields\n    ------\n    chunck : bytes\n        hash of data found on disk\n    piece : bytes\n        hash of data when complete and correct\n    path : str\n        path to file being hashed\n    size : int\n        length of bytes hashed for piece\n    \"\"\"\n    matched = consumed = 0\n    checker = self.piece_checker()\n    for chunk, piece, path, size in checker(self):\n        consumed += size\n        matching = 0\n        if chunk == piece:\n            matching += size\n            matched += size\n        yield chunk, piece, path, size\n        total_consumed = str(int(consumed / self.total * 100))\n        percent_matched = str(int(matched / consumed * 100))\n        self.log_msg(\n            \"Processed: %s%%, Matched: %s%%\",\n            total_consumed,\n            percent_matched,\n        )\n    self._result = (matched / consumed) * 100 if consumed &gt; 0 else 0\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.Checker.log_msg","title":"<code>log_msg(*args, level: int = logging.INFO)</code>","text":"<p>Log message <code>msg</code> to logger and send <code>msg</code> to callback hook.</p> PARAMETER DESCRIPTION <code>*args</code> <p>formatting args for log message</p> <p> TYPE: <code>dict</code> DEFAULT: <code>()</code> </p> <code>level</code> <p>Log level for this message; default=<code>logging.INFO</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>logging.INFO</code> </p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def log_msg(self, *args, level: int = logging.INFO):\n\"\"\"\n    Log message `msg` to logger and send `msg` to callback hook.\n\n    Parameters\n    ----------\n    *args : dict\n        formatting args for log message\n    level : int\n        Log level for this message; default=`logging.INFO`\n    \"\"\"\n    message = args[0]\n    if len(args) &gt;= 3:\n        message = message % tuple(args[1:])\n    elif len(args) == 2:\n        message = message % args[1]\n\n    # Repeat log messages should be ignored.\n    if message != self.last_log:\n        self.last_log = message\n        logger.log(level, message)\n        if self._hook and level == logging.INFO:\n            self._hook(message)\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.Checker.piece_checker","title":"<code>piece_checker()</code>","text":"<p>Check individual pieces of the torrent.</p> RETURNS DESCRIPTION <code>HashChecker | FeedChecker</code> <p>Individual piece hasher.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def piece_checker(self):\n\"\"\"\n    Check individual pieces of the torrent.\n\n    Returns\n    -------\n    HashChecker | FeedChecker\n        Individual piece hasher.\n    \"\"\"\n    if self.meta_version == 1:\n        return FeedChecker\n    return HashChecker\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.Checker.register_callback","title":"<code>register_callback(hook)</code>  <code>classmethod</code>","text":"<p>Register hooks from 3rd party programs to access generated info.</p> PARAMETER DESCRIPTION <code>hook</code> <p>callback function for the logging feature.</p> <p> TYPE: <code>function</code> </p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>@classmethod\ndef register_callback(cls, hook):\n\"\"\"\n    Register hooks from 3rd party programs to access generated info.\n\n    Parameters\n    ----------\n    hook : function\n        callback function for the logging feature.\n    \"\"\"\n    cls._hook = hook\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.Checker.results","title":"<code>results()</code>","text":"<p>Generate result percentage and store for future calls.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def results(self):\n\"\"\"\n    Generate result percentage and store for future calls.\n    \"\"\"\n    responses = []\n    for response in self.iter_hashes():\n        responses.append(response)\n\n    self.log_msg(\n        \"Final result for %s recheck:  %s\", self.metafile, self._result\n    )\n\n    return self._result\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.Checker.walk_file_tree","title":"<code>walk_file_tree(tree: dict, partials: list)</code>","text":"<p>Traverse File Tree dictionary to get file details.</p> <p>Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent\u2019s file tree.</p> PARAMETER DESCRIPTION <code>tree</code> <p>File Tree dict extracted from torrent file.</p> <p> TYPE: <code>dict</code> </p> <code>partials</code> <p>list of intermediate pathnames.</p> <p> TYPE: <code>list</code> </p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def walk_file_tree(self, tree: dict, partials: list):\n\"\"\"\n    Traverse File Tree dictionary to get file details.\n\n    Extract full pathnames, length, root hash, and layer hashes\n    for each file included in the .torrent's file tree.\n\n    Parameters\n    ----------\n    tree : dict\n        File Tree dict extracted from torrent file.\n    partials : list\n        list of intermediate pathnames.\n    \"\"\"\n    for key, val in tree.items():\n        # Empty string means the tree's leaf is value\n        if \"\" in val:\n            base = os.path.join(*partials, key)\n            roothash = None\n            length = val[\"\"][\"length\"]\n            roothash = None if not length else val[\"\"][\"pieces root\"]\n            full = str(self.root / base)\n            self.fileinfo[len(self.paths)] = {\n                \"path\": full,\n                \"length\": length,\n                \"pieces root\": roothash,\n            }\n            self.paths.append(full)\n            self.total += length\n        else:\n            self.walk_file_tree(val, partials + [key])\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.FeedChecker","title":"<code>FeedChecker(checker: Checker)</code>","text":"<p>         Bases: <code>ProgMixin</code></p> <p>Validates torrent content.</p> <p>Seemlesly validate torrent file contents by comparing hashes in metafile against data on disk.</p> PARAMETER DESCRIPTION <code>checker</code> <p>the checker class instance.</p> <p> TYPE: <code>object</code> </p> <p>Generate hashes of piece length data from filelist contents.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __init__(self, checker: Checker):\n\"\"\"\n    Generate hashes of piece length data from filelist contents.\n    \"\"\"\n    self.piece_length = checker.piece_length\n    self.paths = checker.paths\n    self.pieces = checker.info[\"pieces\"]\n    self.fileinfo = checker.fileinfo\n    self.piece_map = {}\n    self.index = 0\n    self.piece_count = 0\n    self.it = None\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.FeedChecker.__iter__","title":"<code>__iter__()</code>","text":"<p>Assign iterator and return self.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __iter__(self):\n\"\"\"\n    Assign iterator and return self.\n    \"\"\"\n    self.it = self.iter_pieces()\n    return self\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.FeedChecker.__next__","title":"<code>__next__()</code>","text":"<p>Yield back result of comparison.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __next__(self):\n\"\"\"\n    Yield back result of comparison.\n    \"\"\"\n    try:\n        partial = next(self.it)\n    except StopIteration as itererror:\n        raise StopIteration from itererror\n\n    chunck = sha1(partial).digest()  # nosec\n    start = self.piece_count * SHA1\n    end = start + SHA1\n    piece = self.pieces[start:end]\n    self.piece_count += 1\n    path = self.paths[self.index]\n    return chunck, piece, path, len(partial)\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.FeedChecker.extract","title":"<code>extract(path: str, partial: bytearray) -&gt; bytearray</code>","text":"<p>Split file paths contents into blocks of data for hash pieces.</p> PARAMETER DESCRIPTION <code>path</code> <p>path to content.</p> <p> TYPE: <code>str</code> </p> <code>partial</code> <p>any remaining content from last file.</p> <p> TYPE: <code>bytes</code> </p> RETURNS DESCRIPTION <code>bytearray</code> <p>Hash digest for block of .torrent contents.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def extract(self, path: str, partial: bytearray) -&gt; bytearray:\n\"\"\"\n    Split file paths contents into blocks of data for hash pieces.\n\n    Parameters\n    ----------\n    path : str\n        path to content.\n    partial : bytes\n        any remaining content from last file.\n\n    Returns\n    -------\n    bytearray\n        Hash digest for block of .torrent contents.\n    \"\"\"\n    read = 0\n    length = self.fileinfo[self.index][\"length\"]\n    partial = bytearray() if len(partial) == self.piece_length else partial\n    if path not in self.paths:  # pragma: no cover\n        raise MissingPathError(path)\n    with open(path, \"rb\") as current:\n        while True:\n            bitlength = self.piece_length - len(partial)\n            part = bytearray(bitlength)\n            amount = current.readinto(part)\n            read += amount\n            partial.extend(part[:amount])\n            if amount &lt; bitlength:\n                if amount &gt; 0 and read == length:\n                    self.prog_update(amount)\n                    yield partial\n                break\n            self.prog_update(amount)\n            yield partial\n            partial = bytearray(0)\n    if length != read:\n        for pad in self._gen_padding(partial, length, read):\n            yield pad\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.FeedChecker.iter_pieces","title":"<code>iter_pieces()</code>","text":"<p>Iterate through, and hash pieces of torrent contents.</p> YIELDS DESCRIPTION <code>piece</code> <p>hash digest for block of torrent data.</p> <p> TYPE: <code>bytes</code> </p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def iter_pieces(self):\n\"\"\"\n    Iterate through, and hash pieces of torrent contents.\n\n    Yields\n    ------\n    piece : bytes\n        hash digest for block of torrent data.\n    \"\"\"\n    partial = bytearray()\n    for i, path in enumerate(self.paths):\n        total = self.fileinfo[i][\"length\"]\n        self.prog_start(total, path)\n        self.index = i\n        if os.path.exists(path):\n            for piece in self.extract(path, partial):\n                if (len(piece) == self.piece_length) or (\n                    i + 1 == len(self.paths)\n                ):\n                    yield piece\n                else:\n                    partial = piece\n\n        else:\n            length = self.fileinfo[i][\"length\"]\n            for pad in self._gen_padding(partial, length):\n                if len(pad) == self.piece_length:\n                    yield pad\n                else:\n                    partial = pad\n        self.prog_close()\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.HashChecker","title":"<code>HashChecker(checker: Checker)</code>","text":"<p>         Bases: <code>ProgMixin</code></p> <p>Iterate through contents of meta data and verify with file contents.</p> PARAMETER DESCRIPTION <code>checker</code> <p>the checker instance that maintains variables.</p> <p> TYPE: <code>Checker</code> </p> <p>Construct a HybridChecker instance.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __init__(self, checker: Checker):\n\"\"\"\n    Construct a HybridChecker instance.\n    \"\"\"\n    self.checker = checker\n    self.paths = checker.paths\n    self.piece_length = checker.piece_length\n    self.fileinfo = checker.fileinfo\n    self.piece_layers = checker.meta[\"piece layers\"]\n    self.current = None\n    self.index = -1\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.HashChecker.Padder","title":"<code>Padder(length, piece_length)</code>","text":"<p>Padding class to generate padding hashes wherever needed.</p> PARAMETER DESCRIPTION <code>length</code> <p>the total size of the mock file generating padding for.</p> <p> </p> <code>piece_length</code> <p>the block size that each hash represents.</p> <p> TYPE: <code>int</code> </p> <p>Construct padding class to Mock missing or incomplete files.</p> PARAMETER DESCRIPTION <code>length</code> <p>size of the file</p> <p> TYPE: <code>int</code> </p> <code>piece_length</code> <p>the piece length for each iteration.</p> <p> TYPE: <code>int</code> </p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __init__(self, length, piece_length):\n\"\"\"\n    Construct padding class to Mock missing or incomplete files.\n\n    Parameters\n    ----------\n    length : int\n        size of the file\n    piece_length : int\n        the piece length for each iteration.\n    \"\"\"\n    self.length = length\n    self.piece_length = piece_length\n    self.pad = sha256(bytearray(piece_length)).digest()\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.HashChecker.Padder.__iter__","title":"<code>__iter__()</code>","text":"<p>Return self to correctly implement iterator type.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __iter__(self):\n\"\"\"\n    Return self to correctly implement iterator type.\n    \"\"\"\n    return self  # pragma: nocover\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.HashChecker.Padder.__next__","title":"<code>__next__() -&gt; bytes</code>","text":"<p>Iterate through seemingly endless sha256 hashes of zeros.</p> RETURNS DESCRIPTION <code>tuple</code> <p>returns the padding</p> <p> TYPE: <code>bytes</code> </p> RAISES DESCRIPTION <code>StopIteration</code> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __next__(self) -&gt; bytes:\n\"\"\"\n    Iterate through seemingly endless sha256 hashes of zeros.\n\n    Returns\n    -------\n    tuple :\n        returns the padding\n\n    Raises\n    ------\n    StopIteration\n    \"\"\"\n    if self.length &gt;= self.piece_length:\n        self.length -= self.piece_length\n        return self.pad\n    if self.length &gt; 0:\n        pad = sha256(bytearray(self.length)).digest()\n        self.length -= self.length\n        return pad\n    raise StopIteration\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.HashChecker.__iter__","title":"<code>__iter__()</code>","text":"<p>Assign iterator and return self.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __iter__(self):\n\"\"\"\n    Assign iterator and return self.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.HashChecker.__next__","title":"<code>__next__()</code>","text":"<p>Provide the result of comparison.</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def __next__(self):\n\"\"\"\n    Provide the result of comparison.\n    \"\"\"\n    if self.current is None:\n        self.next_file()\n    try:\n        return self.process_current()\n    except StopIteration as itererr:\n        if self.next_file():\n            return self.process_current()\n        raise StopIteration from itererr\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.HashChecker.advance","title":"<code>advance() -&gt; tuple</code>","text":"<p>Increment the number of pieces processed for the current file.</p> RETURNS DESCRIPTION <code>tuple</code> <p>the piece and size</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def advance(self) -&gt; tuple:\n\"\"\"\n    Increment the number of pieces processed for the current file.\n\n    Returns\n    -------\n    tuple\n        the piece and size\n    \"\"\"\n    start = self.count * SHA256\n    end = start + SHA256\n    piece = self.pieces[start:end]\n    self.count += 1\n    if self.length &gt;= self.piece_length:\n        self.length -= self.piece_length\n        size = self.piece_length\n    else:\n        size = self.length\n        self.length -= self.length\n    return piece, size\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.HashChecker.next_file","title":"<code>next_file() -&gt; bool</code>","text":"<p>Remove all references to  processed files and prepare for the next.</p> RETURNS DESCRIPTION <code>bool</code> <p>if there is a next file found</p> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def next_file(self) -&gt; bool:\n\"\"\"\n    Remove all references to  processed files and prepare for the next.\n\n    Returns\n    -------\n    bool\n        if there is a next file found\n    \"\"\"\n    self.index += 1\n    self.prog_close()\n    if self.current is None or self.index &lt; len(self.paths):\n        self.current = self.paths[self.index]\n        self.length = self.fileinfo[self.index][\"length\"]\n        self.root_hash = self.fileinfo[self.index][\"pieces root\"]\n        if self.length &gt; self.piece_length:\n            self.pieces = self.piece_layers[self.root_hash]\n        else:\n            self.pieces = self.root_hash\n        path = self.paths[self.index]\n        self.prog_start(self.length, path)\n        self.count = 0\n        if os.path.exists(self.current):\n            self.hasher = FileHasher(path, self.piece_length, progress=0)\n        else:\n            self.hasher = self.Padder(self.length, self.piece_length)\n        return True\n    if self.index &gt;= len(self.paths):\n        del self.current\n        del self.length\n        del self.root_hash\n        del self.pieces\n    return False\n</code></pre>"},{"location":"Source/recheck/#torrentfile.recheck.HashChecker.process_current","title":"<code>process_current() -&gt; tuple</code>","text":"<p>Gather necessary information to compare to metafile details.</p> RETURNS DESCRIPTION <code>tuple</code> <p>a tuple containing the layer, piece, current path and size</p> RAISES DESCRIPTION <code>StopIteration</code> Source code in <code>torrentfile\\recheck.py</code> <pre><code>def process_current(self) -&gt; tuple:\n\"\"\"\n    Gather necessary information to compare to metafile details.\n\n    Returns\n    -------\n    tuple\n        a tuple containing the layer, piece, current path and size\n\n    Raises\n    ------\n    StopIteration\n    \"\"\"\n    try:\n        layer = next(self.hasher)\n        piece, size = self.advance()\n        self.prog_update(size)\n        return layer, piece, self.current, size\n    except StopIteration as err:\n        if self.length &gt; 0 and self.count * SHA256 &lt; len(self.pieces):\n            self.hasher = self.Padder(self.length, self.piece_length)\n            piece, size = self.advance()\n            layer = next(self.hasher)\n            self.prog_update(0)\n            return layer, piece, self.current, size\n        raise StopIteration from err\n</code></pre>"},{"location":"Source/torrent/","title":"Torrent","text":""},{"location":"Source/torrent/#torrentfile.torrent","title":"<code>torrent</code>","text":"<p>Classes and procedures pertaining to the creation of torrent meta files.</p>"},{"location":"Source/torrent/#torrentfile.torrent--classes","title":"Classes","text":"<ul> <li> <p><code>TorrentFile</code>     construct .torrent file.</p> </li> <li> <p><code>TorrentFileV2</code>     construct .torrent v2 files using provided data.</p> </li> <li> <p><code>MetaFile</code>     base class for all MetaFile classes.</p> </li> </ul>"},{"location":"Source/torrent/#torrentfile.torrent--constants","title":"Constants","text":"<ul> <li> <p>BLOCK_SIZE : int     size of leaf hashes for merkle tree.</p> </li> <li> <p>HASH_SIZE : int     Length of a sha256 hash.</p> </li> </ul>"},{"location":"Source/torrent/#torrentfile.torrent--bittorrent-v2","title":"Bittorrent V2","text":"<p>From Bittorrent.org Documentation pages.</p> <p>Implementation details for Bittorrent Protocol v2.</p> <p>Note</p> <p>All strings in a .torrent file that contain text must be UTF-8 encoded.</p>"},{"location":"Source/torrent/#torrentfile.torrent--meta-version-2-dictionary","title":"Meta Version 2 Dictionary:","text":"<ul> <li> <p>\u201cannounce\u201d:     The URL of the tracker.</p> </li> <li> <p>\u201cinfo\u201d:     This maps to a dictionary, with keys described below.</p> <ul> <li> <p>\u201cname\u201d:     A display name for the torrent. It is purely advisory.</p> </li> <li> <p>\u201cpiece length\u201d:     The number of bytes that each logical piece in the peer     protocol refers to. I.e. it sets the granularity of piece, request,     bitfield and have messages. It must be a power of two and at least     6KiB.</p> </li> <li> <p>\u201cmeta version\u201d:     An integer value, set to 2 to indicate compatibility     with the current revision of this specification. Version 1 is not     assigned to avoid confusion with BEP3. Future revisions will only     increment this issue to indicate an incompatible change has been made,     for example that hash algorithms were changed due to newly discovered     vulnerabilities. Lementations must check this field first and indicate     that a torrent is of a newer version than they can handle before     performing other idations which may result in more general messages     about invalid files. Files are mapped into this piece address space so     that each non-empty</p> </li> <li> <p>\u201cfile tree\u201d:     A tree of dictionaries where dictionary keys represent UTF-8     encoded path elements. Entries with zero-length keys describe the     properties of the composed path at that point. \u2018UTF-8 encoded\u2019     context only means that if the native encoding is known at creation     time it must be converted to UTF-8. Keys may contain invalid UTF-8     sequences or characters and names that are reserved on specific     filesystems. Implementations must be prepared to sanitize them. On     platforms path components exactly matching \u2018.\u2019 and \u2018..\u2019 must be     sanitized since they could lead to directory traversal attacks and     conflicting path descriptions. On platforms that require UTF-8     path components this sanitizing step must happen after normalizing     overlong UTF-8 encodings.     File is aligned to a piece boundary and occurs in same order as     the file tree. The last piece of each file may be shorter than the     specified piece length, resulting in an alignment gap.</p> </li> <li> <p>\u201clength\u201d:     Length of the file in bytes. Presence of this field indicates     that the dictionary describes a file, not a directory. Which means     it must not have any sibling entries.</p> </li> <li> <p>\u201cpieces root\u201d:     For non-empty files this is the the root hash of a merkle     tree with a branching factor of 2, constructed from 16KiB blocks     of the file. The last block may be shorter than 16KiB. The     remaining leaf hashes beyond the end of the file required to     construct upper layers of the merkle tree are set to zero. As of     meta version 2 SHA2-256 is used as digest function for the merkle     tree. The hash is stored in its binary form, not as human-readable     string.</p> </li> </ul> </li> <li> <p>\u201cpiece layers\u201d:     A dictionary of strings. For each file in the file tree that     is larger than the piece size it contains one string value.     The keys are the merkle roots while the values consist of concatenated     hashes of one layer within that merkle tree. The layer is chosen so     that one hash covers piece length bytes. For example if the piece     size is 16KiB then the leaf hashes are used. If a piece size of     128KiB is used then 3rd layer up from the leaf hashes is used. Layer     hashes which exclusively cover data beyond the end of file, i.e.     are only needed to balance the tree, are omitted. All hashes are     stored in their binary format. A torrent is not valid if this field is     absent, the contained hashes do not match the merkle roots or are     not from the correct layer.</p> </li> </ul> <p>Important</p> <p>The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key.</p>"},{"location":"Source/torrent/#torrentfile.torrent--bittorrent-v1","title":"Bittorrent V1","text":""},{"location":"Source/torrent/#torrentfile.torrent--v1-meta-dictionary","title":"v1 meta-dictionary","text":"<ul> <li> <p>announce:     The URL of the tracker.</p> </li> <li> <p>info:     This maps to a dictionary, with keys described below.</p> <ul> <li> <p><code>name</code>:     maps to a UTF-8 encoded string which is the suggested name to     save the file (or directory) as. It is purely advisory.</p> </li> <li> <p><code>piece length</code>:     maps to the number of bytes in each piece the file is split     into. For the purposes of transfer, files are split into     fixed-size pieces which are all the same length except for     possibly the last one which may be truncated.</p> </li> <li> <p><code>piece length</code>:     is almost always a power of two, most commonly 2^18 = 256 K</p> </li> <li> <p><code>pieces</code>:     maps to a string whose length is a multiple of 20. It is to be     subdivided into strings of length 20, each of which is the SHA1     hash of the piece at the corresponding index.</p> </li> <li> <p><code>length</code>:     In the single file case, maps to the length of the file in bytes.</p> </li> <li> <p><code>files</code>:     If present then the download represents a single file, otherwise it     represents a set of files which go in a directory structure.     For the purposes of the other keys, the multi-file case is treated     as only having a single file by concatenating the files in the order     they appear in the files list. The files list is the value <code>files</code>     maps to, and is a list of dictionaries containing the following keys:</p> <ul> <li> <p><code>path</code>:     A list of UTF-8 encoded strings corresponding to subdirectory     names, the last of which is the actual file name</p> </li> <li> <p><code>length</code>:     Maps to the length of the file in bytes.</p> </li> </ul> </li> <li> <p><code>length</code>:     Only present if the content is a single file. Maps to the length     of the file in bytes.</p> </li> </ul> </li> </ul> <p>Note</p> <p>In the single file case, the name key is the name of a file, in the muliple file case, it\u2019s the name of a directory.</p>"},{"location":"Source/torrent/#torrentfile.torrent.MetaFile","title":"<code>MetaFile(path = None, announce = None, comment = None, piece_length = None, private = False, outfile = None, source = None, progress = 1, cwd = False, httpseeds = None, url_list = None, content = None, meta_version = None, **_)</code>","text":"<p>Base Class for all TorrentFile classes.</p> PARAMETER DESCRIPTION <code>path</code> <p>target path to torrent content.  Default: None</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>announce</code> <p>One or more tracker URL\u2019s.  Default: None</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>comment</code> <p>A comment.  Default: None</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>piece_length</code> <p>Size of torrent pieces.  Default: None</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>private</code> <p>For private trackers.  Default: None</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>outfile</code> <p>target path to write .torrent file. Default: None</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>source</code> <p>Private tracker source. Default: None</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>progress</code> <p>level of progress bar displayed  Default: \u201c1\u201d</p> <p> TYPE: <code>str</code> DEFAULT: <code>1</code> </p> <code>cwd</code> <p>If True change default save location to current directory</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>httpseeds</code> <p>one or more web addresses where torrent content can be found.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>url_list</code> <p>one or more web addressess where torrent content exists.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>content</code> <p>alias for \u2018path\u2019 arg.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>meta_version</code> <p>indicates which Bittorrent protocol to use for hashing content</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <p>Construct MetaFile superclass and assign local attributes.</p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def __init__(\n    self,\n    path=None,\n    announce=None,\n    comment=None,\n    piece_length=None,\n    private=False,\n    outfile=None,\n    source=None,\n    progress=1,\n    cwd=False,\n    httpseeds=None,\n    url_list=None,\n    content=None,\n    meta_version=None,\n    **_,\n):\n\"\"\"\n    Construct MetaFile superclass and assign local attributes.\n    \"\"\"\n    self.private = private\n    self.cwd = cwd\n    self.outfile = outfile\n    self.progress = int(progress)\n    self.comment = comment\n    self.source = source\n    self.meta_version = meta_version\n\n    if content:\n        path = content\n    if not path:\n        if announce and len(announce) &gt; 1 and os.path.exists(announce[-1]):\n            path = announce[-1]\n            announce = announce[:-1]\n        elif url_list and os.path.exists(url_list[-1]):\n            path = url_list[-1]\n            url_list = url_list[:-1]\n        elif httpseeds and os.path.exists(httpseeds[-1]):\n            path = httpseeds[-1]\n            httpseeds = httpseeds[:-1]\n        else:\n            raise utils.MissingPathError(\"Path to content is required.\")\n\n    # base path to torrent content.\n    self.path = path\n\n    logger.debug(\"path parameter found %s\", path)\n\n    # Format piece_length attribute.\n    if piece_length:\n        self.piece_length = utils.normalize_piece_length(piece_length)\n        logger.debug(\"piece length parameter found %s\", piece_length)\n    else:\n        self.piece_length = utils.path_piece_length(self.path)\n        logger.debug(\"piece length calculated %s\", self.piece_length)\n\n    # Assign announce URL to empty string if none provided.\n    if not announce:\n        self.announce, self.announce_list = \"\", [[\"\"]]\n\n    # Most torrent clients have editting trackers as a feature.\n    elif isinstance(announce, str):\n        self.announce, self.announce_list = announce, [[announce]]\n\n    elif isinstance(announce, Sequence):\n        self.announce, self.announce_list = announce[0], [announce]\n\n    self.meta = {\n        \"announce\": self.announce,\n        \"announce-list\": self.announce_list,\n        \"created by\": f\"TorrentFile_v{version}\",\n        \"creation date\": int(datetime.timestamp(datetime.now())),\n        \"info\": {},\n    }\n    if comment:\n        self.meta[\"info\"][\"comment\"] = comment\n        logger.debug(\"comment parameter found %s\", comment)\n    if private:\n        self.meta[\"info\"][\"private\"] = 1\n        logger.debug(\"private parameter triggered\")\n    if source:\n        self.meta[\"info\"][\"source\"] = source\n        logger.debug(\"source parameter found %s\", source)\n    if url_list:\n        self.meta[\"url-list\"] = url_list\n        logger.debug(\"url list parameter found %s\", str(url_list))\n    if httpseeds:\n        self.meta[\"httpseeds\"] = httpseeds\n        logger.debug(\"httpseeds parameter found %s\", str(httpseeds))\n    self.meta[\"info\"][\"piece length\"] = self.piece_length\n\n    self.meta_version = meta_version\n    parent, self.name = os.path.split(self.path)\n    if not self.name:\n        self.name = os.path.basename(parent)\n    self.meta[\"info\"][\"name\"] = self.name\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.MetaFile.assemble","title":"<code>assemble()</code>","text":"<p>Overload in subclasses.</p> RAISES DESCRIPTION <code>Exception</code> <p>NotImplementedError</p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def assemble(self):\n\"\"\"\n    Overload in subclasses.\n\n    Raises\n    ------\n    Exception\n        NotImplementedError\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.MetaFile.set_callback","title":"<code>set_callback(func)</code>  <code>classmethod</code>","text":"<p>Assign a callback function for the Hashing class to call for each hash.</p> PARAMETER DESCRIPTION <code>func</code> <p>The callback function which accepts a single paramter.</p> <p> TYPE: <code>function</code> </p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>@classmethod\ndef set_callback(cls, func):\n\"\"\"\n    Assign a callback function for the Hashing class to call for each hash.\n\n    Parameters\n    ----------\n    func : function\n        The callback function which accepts a single paramter.\n    \"\"\"\n    if \"hasher\" in vars(cls) and vars(cls)[\"hasher\"]:\n        cls.hasher.set_callback(func)\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.MetaFile.sort_meta","title":"<code>sort_meta()</code>","text":"<p>Sort the info and meta dictionaries.</p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def sort_meta(self):\n\"\"\"Sort the info and meta dictionaries.\"\"\"\n    logger.debug(\"sorting dictionary keys\")\n    meta = self.meta\n    meta[\"info\"] = dict(sorted(list(meta[\"info\"].items())))\n    meta = dict(sorted(list(meta.items())))\n    return meta\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.MetaFile.write","title":"<code>write(outfile = None) -&gt; tuple</code>","text":"<p>Write meta information to .torrent file.</p> <p>Final step in the torrent file creation process. After hashing and sorting every piece of content write the contents to file using the bencode encoding.</p> PARAMETER DESCRIPTION <code>outfile</code> <p>Destination path for .torrent file. default=None</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>outfile</code> <p>Where the .torrent file was writen.</p> <p> TYPE: <code>str</code> </p> <code>meta</code> <p>.torrent meta information.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def write(self, outfile=None) -&gt; tuple:\n\"\"\"\n    Write meta information to .torrent file.\n\n    Final step in the torrent file creation process.\n    After hashing and sorting every piece of content\n    write the contents to file using the bencode encoding.\n\n    Parameters\n    ----------\n    outfile : str\n        Destination path for .torrent file. default=None\n\n    Returns\n    -------\n    outfile : str\n        Where the .torrent file was writen.\n    meta : dict\n        .torrent meta information.\n    \"\"\"\n    if outfile:\n        self.outfile = outfile\n    if not self.outfile:  # pragma: nocover\n        path = os.path.join(os.getcwd(), self.name) + \".torrent\"\n        self.outfile = path\n    if str(self.outfile)[-1] in \"\\\\/\":\n        self.outfile = self.outfile + (self.name + \".torrent\")\n    self.meta = self.sort_meta()\n    try:\n        pyben.dump(self.meta, self.outfile)\n    except PermissionError as excp:\n        logger.error(\n            \"Permission Denied: Could not write to %s\", self.outfile\n        )\n        raise PermissionError from excp\n    return self.outfile, self.meta\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.TorrentAssembler","title":"<code>TorrentAssembler(**kwargs)</code>","text":"<p>         Bases: <code>MetaFile</code></p> <p>Assembler class for Bittorrent version 2 and hybrid meta files.</p> <p>This differs from the TorrentFileV2 and TorrentFileHybrid, because it can be used as an iterator and works for both versions.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Keyword arguments for torrent options.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <p>Create Bittorrent v1 v2 hybrid metafiles.</p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def __init__(self, **kwargs):\n\"\"\"\n    Create Bittorrent v1 v2 hybrid metafiles.\n    \"\"\"\n    super().__init__(**kwargs)\n    logger.debug(\"Assembling bittorrent Hybrid file\")\n    self.name = os.path.basename(self.path)\n    self.hashes = []\n    self.piece_layers = {}\n    self.pieces = bytearray()\n    self.files = []\n    self.hybrid = self.meta_version == \"3\"\n    self.total = len(utils.get_file_list(self.path))\n    self.assemble()\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.TorrentAssembler.assemble","title":"<code>assemble()</code>","text":"<p>Assemble the parts of the torrentfile into meta dictionary.</p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def assemble(self):\n\"\"\"\n    Assemble the parts of the torrentfile into meta dictionary.\n    \"\"\"\n    info = self.meta[\"info\"]\n    info[\"meta version\"] = 2\n\n    if os.path.isfile(self.path):\n        info[\"file tree\"] = {self.name: self._traverse(self.path)}\n        info[\"length\"] = os.path.getsize(self.path)\n\n    else:\n        info[\"file tree\"] = self._traverse(self.path)\n        if self.hybrid:\n            info[\"files\"] = self.files\n\n    if self.hybrid:\n        info[\"pieces\"] = self.pieces\n    self.meta[\"piece layers\"] = self.piece_layers\n    return info\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.TorrentFile","title":"<code>TorrentFile(**kwargs)</code>","text":"<p>         Bases: <code>MetaFile</code>, <code>ProgMixin</code></p> <p>Class for creating Bittorrent meta files.</p> <p>Construct Torrentfile class instance object.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Dictionary containing torrent file options.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <p>Construct TorrentFile instance with given keyword args.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>dictionary of keyword args passed to superclass.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def __init__(self, **kwargs):\n\"\"\"\n    Construct TorrentFile instance with given keyword args.\n\n    Parameters\n    ----------\n    **kwargs : dict\n        dictionary of keyword args passed to superclass.\n    \"\"\"\n    super().__init__(**kwargs)\n    logger.debug(\"Assembling bittorrent v1 torrent file\")\n    self.assemble()\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.TorrentFile.assemble","title":"<code>assemble()</code>","text":"<p>Assemble components of torrent metafile.</p> RETURNS DESCRIPTION <code>dict</code> <p>metadata dictionary for torrent file</p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def assemble(self):\n\"\"\"\n    Assemble components of torrent metafile.\n\n    Returns\n    -------\n    dict\n        metadata dictionary for torrent file\n    \"\"\"\n    info = self.meta[\"info\"]\n    size, filelist = utils.filelist_total(self.path)\n    if os.path.isfile(self.path):\n        info[\"length\"] = size\n    else:\n        info[\"files\"] = [\n            {\n                \"length\": os.path.getsize(path),\n                \"path\": os.path.relpath(path, self.path).split(os.sep),\n            }\n            for path in filelist\n        ]\n    pieces = bytearray()\n\n    feeder = Hasher(filelist, self.piece_length, self.progress)\n    for piece in feeder:\n        pieces.extend(piece)\n\n    info[\"pieces\"] = pieces\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.TorrentFileHybrid","title":"<code>TorrentFileHybrid(**kwargs)</code>","text":"<p>         Bases: <code>MetaFile</code>, <code>ProgMixin</code></p> <p>Construct the Hybrid torrent meta file with provided parameters.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Keyword arguments for torrent options.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <p>Create Bittorrent v1 v2 hybrid metafiles.</p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def __init__(self, **kwargs):\n\"\"\"\n    Create Bittorrent v1 v2 hybrid metafiles.\n    \"\"\"\n    super().__init__(**kwargs)\n    logger.debug(\"Assembling bittorrent Hybrid file\")\n    self.name = os.path.basename(self.path)\n    self.hashes = []\n    self.piece_layers = {}\n    self.pieces = []\n    self.files = []\n    self.total = len(utils.get_file_list(self.path))\n    self.assemble()\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.TorrentFileHybrid.assemble","title":"<code>assemble()</code>","text":"<p>Assemble the parts of the torrentfile into meta dictionary.</p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def assemble(self):\n\"\"\"\n    Assemble the parts of the torrentfile into meta dictionary.\n    \"\"\"\n    info = self.meta[\"info\"]\n    info[\"meta version\"] = 2\n\n    if os.path.isfile(self.path):\n        info[\"file tree\"] = {self.name: self._traverse(self.path)}\n        info[\"length\"] = os.path.getsize(self.path)\n\n    else:\n        info[\"file tree\"] = self._traverse(self.path)\n        info[\"files\"] = self.files\n\n    info[\"pieces\"] = b\"\".join(self.pieces)\n    self.meta[\"piece layers\"] = self.piece_layers\n    return info\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.TorrentFileV2","title":"<code>TorrentFileV2(**kwargs)</code>","text":"<p>         Bases: <code>MetaFile</code>, <code>ProgMixin</code></p> <p>Class for creating Bittorrent meta v2 files.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Keyword arguments for torrent file options.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <p>Construct <code>TorrentFileV2</code> Class instance from given parameters.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>keywword arguments to pass to superclass.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def __init__(self, **kwargs):\n\"\"\"\n    Construct `TorrentFileV2` Class instance from given parameters.\n\n    Parameters\n    ----------\n    **kwargs : dict\n        keywword arguments to pass to superclass.\n    \"\"\"\n    super().__init__(**kwargs)\n    logger.debug(\"Assembling bittorrent v2 torrent file\")\n    self.piece_layers = {}\n    self.hashes = []\n    self.total = len(utils.get_file_list(self.path))\n    self.assemble()\n</code></pre>"},{"location":"Source/torrent/#torrentfile.torrent.TorrentFileV2.assemble","title":"<code>assemble()</code>","text":"<p>Assemble then return the meta dictionary for encoding.</p> RETURNS DESCRIPTION <code>meta</code> <p>Metainformation about the torrent.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>torrentfile\\torrent.py</code> <pre><code>def assemble(self):\n\"\"\"\n    Assemble then return the meta dictionary for encoding.\n\n    Returns\n    -------\n    meta : dict\n        Metainformation about the torrent.\n    \"\"\"\n    info = self.meta[\"info\"]\n    if os.path.isfile(self.path):\n        info[\"file tree\"] = {info[\"name\"]: self._traverse(self.path)}\n        info[\"length\"] = os.path.getsize(self.path)\n        self.prog_update(info[\"length\"])\n    else:\n        info[\"file tree\"] = self._traverse(self.path)\n\n    info[\"meta version\"] = 2\n    self.meta[\"piece layers\"] = self.piece_layers\n</code></pre>"},{"location":"Source/utils/","title":"Utils","text":""},{"location":"Source/utils/#torrentfile.utils","title":"<code>utils</code>","text":"<p>Utility functions and classes used throughout package.</p> <p>Functions:   get_piece_length: calculate ideal piece length for torrent file.   sortfiles: traverse directory in sorted order yielding paths encountered.   path_size: Sum the sizes of each file in path.   get_file_list: Return list of all files contained in directory.   path_stat: Get ideal piece length, total size, and file list for directory.   path_piece_length: Get ideal piece length based on size of directory.</p> <p>Classes:     MissingPathError: Custom exception raised when no path was provided to CLI.     PieceLengthValueError: Custom exception raised when incorrect input value     used for piece length field.</p>"},{"location":"Source/utils/#torrentfile.utils.ArgumentError","title":"<code>ArgumentError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for mismatched or mistyped CLI arguments.</p>"},{"location":"Source/utils/#torrentfile.utils.Memo","title":"<code>Memo(func)</code>","text":"<p>Memoize cache.</p> PARAMETER DESCRIPTION <code>func</code> <p>The results of this callable will be cached.</p> <p> TYPE: <code>Callable</code> </p> <p>Construcor for cache.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def __init__(self, func):\n\"\"\"\n    Construcor for cache.\n    \"\"\"\n    self.func = func\n    self.counter = 0\n    self.cache = {}\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.Memo.__call__","title":"<code>__call__(path)</code>","text":"<p>Invoke each time memo function is called.</p> PARAMETER DESCRIPTION <code>path</code> <p>The relative or absolute path being used as key in cache dict.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The results of calling the function with path.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def __call__(self, path):\n\"\"\"\n    Invoke each time memo function is called.\n\n    Parameters\n    ----------\n    path : str\n        The relative or absolute path being used as key in cache dict.\n\n    Returns\n    -------\n    Any :\n        The results of calling the function with path.\n    \"\"\"\n    if path in self.cache and os.path.exists(path):\n        self.counter += 1\n        return self.cache[path]\n    result = self.func(path)\n    self.cache[path] = result\n    return result\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.MissingPathError","title":"<code>MissingPathError(message: str = None)</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Path parameter is required to specify target content.</p> <p>Creating a .torrent file with no contents seems rather silly.</p> PARAMETER DESCRIPTION <code>message</code> <p>Message for user (optional).</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Raise when creating a meta file without specifying target content.</p> <p>The <code>message</code> argument is a message to pass to Exception base class.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def __init__(self, message: str = None):\n\"\"\"\n    Raise when creating a meta file without specifying target content.\n\n    The `message` argument is a message to pass to Exception base class.\n    \"\"\"\n    self.message = f\"Path arguement is missing and required {str(message)}\"\n    super().__init__(message)\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.PieceLengthValueError","title":"<code>PieceLengthValueError(message: str = None)</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Piece Length parameter must equal a perfect power of 2.</p> PARAMETER DESCRIPTION <code>message</code> <p>Message for user (optional).</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Raise when creating a meta file with incorrect piece length value.</p> <p>The <code>message</code> argument is a message to pass to Exception base class.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def __init__(self, message: str = None):\n\"\"\"\n    Raise when creating a meta file with incorrect piece length value.\n\n    The `message` argument is a message to pass to Exception base class.\n    \"\"\"\n    self.message = f\"Incorrect value for piece length: {str(message)}\"\n    super().__init__(message)\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.check_path_writable","title":"<code>check_path_writable(path: str) -&gt; bool</code>","text":"<p>Test if output path is writable.</p> PARAMETER DESCRIPTION <code>path</code> <p>file system path string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if writeable, otherwise raises PermissionError</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def check_path_writable(path: str) -&gt; bool:\n\"\"\"\n    Test if output path is writable.\n\n    Parameters\n    ----------\n    path : str\n        file system path string\n\n    Returns\n    -------\n    bool\n        True if writeable, otherwise raises PermissionError\n    \"\"\"\n    try:\n        if path.endswith(\"\\\\\") or path.endswith(\"/\"):\n            path = os.path.join(path, \".torrent\")\n        fd = open(path, \"ab\")\n        fd.close()\n        os.remove(path)\n    except PermissionError as err:  # pragma: nocover\n        directory = os.path.dirname(path)\n        message = f\"Target directory is not writeable {directory}\"\n        raise PermissionError(message) from err\n    return True\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.copypath","title":"<code>copypath(source: str, dest: str) -&gt; None</code>","text":"<p>Copy the file located at source to dest.</p> <p>If one or more directory paths don\u2019t exist in dest, they will be created. If dest already exists and dest and source are the same size, it will be ignored, however if dest is smaller than source, dest will be overwritten.</p> PARAMETER DESCRIPTION <code>source</code> <p>path to source file</p> <p> TYPE: <code>str</code> </p> <code>dest</code> <p>path to target destination</p> <p> TYPE: <code>str</code> </p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def copypath(source: str, dest: str) -&gt; None:\n\"\"\"\n    Copy the file located at source to dest.\n\n    If one or more directory paths don't exist in dest, they will be created.\n    If dest already exists and dest and source are the same size, it will be\n    ignored, however if dest is smaller than source, dest will be overwritten.\n\n    Parameters\n    ----------\n    source : str\n        path to source file\n    dest : str\n        path to target destination\n    \"\"\"\n    if not os.path.exists(source):\n        return\n    if os.path.exists(dest):\n        if os.path.getsize(source) &lt;= os.path.getsize(dest):\n            return\n        shutil.copy(source, dest)  # pragma: nocover\n        return  # pragma: nocover\n    path_parts = iter(Path(dest).parts[:-1])\n    try:\n        root = next(path_parts)\n    except StopIteration:  # pragma: nocover\n        return\n    if not os.path.exists(root):\n        os.mkdir(root)  # pragma: nocover\n    for part in path_parts:\n        path = os.path.join(root, part)\n        if not os.path.exists(path):\n            os.mkdir(path)\n        root = path\n    shutil.copy(source, dest)\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.debug_is_on","title":"<code>debug_is_on() -&gt; bool</code>","text":"<p>Return True if debug mode is on in environment variables.</p> RETURNS DESCRIPTION <code>bool</code> <p>is debug mode on</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def debug_is_on() -&gt; bool:\n\"\"\"\n    Return True if debug mode is on in environment variables.\n\n    Returns\n    -------\n    bool\n        is debug mode on\n    \"\"\"\n    return os.environ[\"TORRENTFILE_DEBUG\"] == \"ON\"\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.filelist_total","title":"<code>filelist_total(pathstring: str) -&gt; os.PathLike</code>","text":"<p>Perform error checking and format conversion to os.PathLike.</p> PARAMETER DESCRIPTION <code>pathstring</code> <p>An existing filesystem path.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>os.PathLike</code> <p>Input path converted to bytes format.</p> RAISES DESCRIPTION <code>MissingPathError</code> <p>File could not be found.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>@Memo\ndef filelist_total(pathstring: str) -&gt; os.PathLike:\n\"\"\"\n    Perform error checking and format conversion to os.PathLike.\n\n    Parameters\n    ----------\n    pathstring : str\n        An existing filesystem path.\n\n    Returns\n    -------\n    os.PathLike\n        Input path converted to bytes format.\n\n    Raises\n    ------\n    MissingPathError\n        File could not be found.\n    \"\"\"\n    if os.path.exists(pathstring):\n        path = Path(pathstring)\n        return _filelist_total(path)\n    raise MissingPathError\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.get_file_list","title":"<code>get_file_list(path: str) -&gt; list</code>","text":"<p>Return a sorted list of file paths contained in directory.</p> PARAMETER DESCRIPTION <code>path</code> <p>target file or directory.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list</code> <p>sorted list of file paths.</p> <p> TYPE: <code>list</code> </p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def get_file_list(path: str) -&gt; list:\n\"\"\"\n    Return a sorted list of file paths contained in directory.\n\n    Parameters\n    ----------\n    path : str\n        target file or directory.\n\n    Returns\n    -------\n    list :\n        sorted list of file paths.\n    \"\"\"\n    _, filelist = filelist_total(path)\n    return filelist\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.get_piece_length","title":"<code>get_piece_length(size: int) -&gt; int</code>","text":"<p>Calculate the ideal piece length for bittorrent data.</p> PARAMETER DESCRIPTION <code>size</code> <p>Total bits of all files incluided in .torrent file.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Ideal piece length.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def get_piece_length(size: int) -&gt; int:\n\"\"\"\n    Calculate the ideal piece length for bittorrent data.\n\n    Parameters\n    ----------\n    size : int\n        Total bits of all files incluided in .torrent file.\n\n    Returns\n    -------\n    int\n        Ideal piece length.\n    \"\"\"\n    exp = 14\n    while size / (2**exp) &gt; 1000 and exp &lt; 24:\n        exp += 1\n    return 2**exp\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.humanize_bytes","title":"<code>humanize_bytes(amount: int | str) -&gt; str</code>","text":"<p>Convert integer into human readable memory sized denomination.</p> PARAMETER DESCRIPTION <code>amount</code> <p>total number of bytes.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>human readable representation of the given amount of bytes.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def humanize_bytes(amount: int | str) -&gt; str:\n\"\"\"\n    Convert integer into human readable memory sized denomination.\n\n    Parameters\n    ----------\n    amount : int\n        total number of bytes.\n\n    Returns\n    -------\n    str\n        human readable representation of the given amount of bytes.\n    \"\"\"\n    base = 1024\n    amount = float(amount)\n    value = abs(amount)\n    if value == 1:\n        return f\"{amount} Byte\"\n    if value &lt; base:\n        return f\"{amount} Bytes\"\n    for i, s in enumerate(SUFFIXES):\n        unit = base ** (i + 2)\n        if value &lt; unit:\n            break\n    value = base * amount / unit\n    return f\"{value:.1f} {s}\"\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.next_power_2","title":"<code>next_power_2(value: int) -&gt; int</code>","text":"<p>Calculate the next perfect power of 2 equal to or greater than value.</p> PARAMETER DESCRIPTION <code>value</code> <p>integer value that is less than some perfect power of 2.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The next power of 2 greater than value, or value if already power of 2.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def next_power_2(value: int) -&gt; int:\n\"\"\"\n    Calculate the next perfect power of 2 equal to or greater than value.\n\n    Parameters\n    ----------\n    value : int\n        integer value that is less than some perfect power of 2.\n\n    Returns\n    -------\n    int\n        The next power of 2 greater than value, or value if already power of 2.\n    \"\"\"\n    if not value &amp; (value - 1) and value:\n        return value\n    start = 1\n    while start &lt; value:\n        start &lt;&lt;= 1\n    return start\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.normalize_piece_length","title":"<code>normalize_piece_length(piece_length: int) -&gt; int</code>","text":"<p>Verify input piece_length is valid and convert accordingly.</p> PARAMETER DESCRIPTION <code>piece_length</code> <p>The piece length provided by user.</p> <p> TYPE: <code>int | str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>normalized piece length.</p> RAISES DESCRIPTION <code>PieceLengthValueError :</code> <p>Piece length is improper value.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def normalize_piece_length(piece_length: int) -&gt; int:\n\"\"\"\n    Verify input piece_length is valid and convert accordingly.\n\n    Parameters\n    ----------\n    piece_length : int | str\n        The piece length provided by user.\n\n    Returns\n    -------\n    int\n        normalized piece length.\n\n    Raises\n    ------\n    PieceLengthValueError :\n        Piece length is improper value.\n    \"\"\"\n    if isinstance(piece_length, str):\n        if piece_length.isnumeric():\n            piece_length = int(piece_length)\n        else:\n            raise PieceLengthValueError(piece_length)\n\n    if piece_length &gt; (1 &lt;&lt; 14):\n        if 2 ** math.log2(piece_length) == piece_length:\n            return piece_length\n        raise PieceLengthValueError(piece_length)\n\n    if 13 &lt; piece_length &lt; 26:\n        return 2**piece_length\n    if piece_length &lt;= 13:\n        raise PieceLengthValueError(piece_length)\n\n    log = int(math.log2(piece_length))\n    if 2**log == piece_length:\n        return piece_length\n    raise PieceLengthValueError\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.path_piece_length","title":"<code>path_piece_length(path: str) -&gt; int</code>","text":"<p>Calculate piece length for input path and contents.</p> PARAMETER DESCRIPTION <code>path</code> <p>The absolute path to directory and contents.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The size of pieces of torrent content.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def path_piece_length(path: str) -&gt; int:\n\"\"\"\n    Calculate piece length for input path and contents.\n\n    Parameters\n    ----------\n    path : str\n        The absolute path to directory and contents.\n\n    Returns\n    -------\n    int\n        The size of pieces of torrent content.\n    \"\"\"\n    psize = path_size(path)\n    return get_piece_length(psize)\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.path_size","title":"<code>path_size(path: str) -&gt; int</code>","text":"<p>Return the total size of all files in path recursively.</p> PARAMETER DESCRIPTION <code>path</code> <p>path to target file or directory.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>total size of files.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def path_size(path: str) -&gt; int:\n\"\"\"\n    Return the total size of all files in path recursively.\n\n    Parameters\n    ----------\n    path : str\n        path to target file or directory.\n\n    Returns\n    -------\n    int\n        total size of files.\n    \"\"\"\n    total_size, _ = filelist_total(path)\n    return total_size\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.path_stat","title":"<code>path_stat(path: str) -&gt; tuple</code>","text":"<p>Calculate directory statistics.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path to start calculating from.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of all files contained in Directory</p> <code>int</code> <p>Total sum of bytes from all contents of dir</p> <code>int</code> <p>The size of pieces of the torrent contents.</p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def path_stat(path: str) -&gt; tuple:\n\"\"\"\n    Calculate directory statistics.\n\n    Parameters\n    ----------\n    path : str\n        The path to start calculating from.\n\n    Returns\n    -------\n    list\n        List of all files contained in Directory\n    int\n        Total sum of bytes from all contents of dir\n    int\n        The size of pieces of the torrent contents.\n    \"\"\"\n    total_size, filelist = filelist_total(path)\n    piece_length = get_piece_length(total_size)\n    return (filelist, total_size, piece_length)\n</code></pre>"},{"location":"Source/utils/#torrentfile.utils.toggle_debug_mode","title":"<code>toggle_debug_mode(switch_on: bool)</code>","text":"<p>Switch the environment variable debug indicator on or off.</p> PARAMETER DESCRIPTION <code>switch_on</code> <p>if true turn debug mode on otherwise off</p> <p> TYPE: <code>bool</code> </p> Source code in <code>torrentfile\\utils.py</code> <pre><code>def toggle_debug_mode(switch_on: bool):\n\"\"\"\n    Switch the environment variable debug indicator on or off.\n\n    Parameters\n    ----------\n    switch_on : bool\n        if true turn debug mode on otherwise off\n    \"\"\"\n    os.environ[\"TORRENTFILE_DEBUG\"] = \"ON\" if switch_on else \"OFF\"\n</code></pre>"},{"location":"Source/version/","title":"Version","text":""},{"location":"Source/version/#torrentfile.version","title":"<code>version</code>","text":"<p>Holds the release version number.</p>"},{"location":"coverage/","title":"Coverage","text":""}]}